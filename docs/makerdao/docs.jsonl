{"page_content": "MakerDAO Technical Docs\nThe Maker Protocol is the platform through which anyone, anywhere can generate the Dai stablecoin against crypto collateral assets. Learn how it works.\nMakerDAO Documentation Overview\n\u0432\u0496\u04e2\nIntroductory\n @ MakerDAO.world\n\u0432\u0496\u04e2\nGovernance\n @ manual.makerdao.com\n\u0432\u0496\u04e2\nTechnical\n \n@ docs.makerdao.com\n \n\u0432\u04b6\u0497 You are here\n\u0432\u0496\u04e2\nCollateral Onboarding\n @ collateral.makerdao.com\n\u0432\u0496\u04e2\nMIPs Portal\n @ mips.makerdao.com\nIntroduction\nMakerDAO is a decentralized organization dedicated to bringing stability to the cryptocurrency economy. The Maker Protocol employs a two-token system. The first being, Dai, a collateral-backed stablecoin that offers stability. The Maker Foundation and the MakerDAO community believe that a decentralized stablecoin is required to have any business or individual realize the advantages of digital money. Second, there is MKR, a governance token that is used by stakeholders to maintain the system and manage Dai. MKR token holders are the decision-makers of the Maker Protocol, supported by the larger public community and various other external parties.\nMaker is unlocking the power of decentralized finance for everyone by creating an inclusive platform for economic empowerment; enabling everyone with equal access to the global financial marketplace.\nWith the new version of the \nMaker Protocol\n, Multi Collateral Dai (MCD), being released and live on the main Ethereum network, we wanted to go over a few of the changes and features that it comes with. The biggest change to the Maker Protocol is that it now accepts any Ethereum-based asset as collateral to generate Dai given that it has been approved by MKR holders and has been given specific, corresponding Risk Parameters through the Maker decentralized governance process.\nAdditionally, there are a few other newly introduced features that come with the MCD upgrade. \nThese new features include:\n\u0432\u0496\u04e2\nNew Dai token ($DAI)\n\u0432\u0496\u04e2\nSupport for multiple Vault collateral types (Launching with ETH and BAT)\nTo open a Vault, head to \nOasis Borrow\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nDai Savings Rate (DSR)\n\u0432\u0496\u04e2\nTo use the DSR, head to \nOasis Earn\n\u0432\u0496\u04e2\nMore robust peg ensuring mechanisms (MKR acting as backstop)\nStability fees paid every block, rather than on Dai repayment\n\u0432\u0496\u04e2\nNew Maker Terminology\n\u0432\u0496\u04e2\nMKR and governance remains the same\n\u0432\u0496\u04e2\nOasis Trade\n\u0432\u0496\u04e2\nThe Maker Protocol Smart Contract Modules System\nThe Maker Protocol System Diagram\nNext\n - Getting Started\nMaker Protocol 101\nLast modified \n7mo ago", "metadata": {"source": "https://docs.makerdao.com/", "title": "MakerDAO Technical Docs"}}
{"page_content": "The Dai Javascript Library of the Maker Protocol\nDai.js is the JavaScript library that helps developers easily build DeFi  applications on top of the Maker Protocol, MakerDAO's platform of smart contracts.\nIntroduction \n\u200b\nDai.js\n is a JavaScript library that makes it easy to build applications on top of MakerDAO's platform of smart contracts. You can use Maker's contracts to open Vaults (formerly known as CDPs), deposit collateral and generate Dai, trade tokens on decentralized exchanges, and more. \nThe library features a pluggable, service-based architecture, which allows users to easily integrate Maker functionality into their own apps. It also includes convenient configuration presets for out-of-the-box usability and support for both front-end and back-end applications, plus plugins for integrating with Maker governance, hardware wallets, and both Single-Collateral and Multi-Collateral Dai.\nIf you have questions regarding Dai.js that are not answered in the following pages, please reach out to us on the \n#dev\n channel on \nchat.makerdao.com\n or create a \nGithub issue\n.\nBuilding on top of the Maker Protocol - \nPrevious\nDeveloper Guides and Tutorials\nNext\nGetting started\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js", "title": "The Dai Javascript Library of the Maker Protocol"}}
{"page_content": "Developer Guides and Tutorials\nDevelopers can build a variety of experiences using one or more components of the Maker Protocol. This repo contains guides and tutorials to help you understand various approaches to integrate with the Maker Protocol and our partners by interfacing with smart contracts, SDKs, APIs, and products.\nAll guides are organized in sections and by proficiency levels within each section.\nVaults\n\u0420\u0452\u0406\nMaker Vault Integration Guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nMonitoring Collateral Types and Vaults\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nCDP Manager Guide\n\u0420\u0452\u0406\nDai\n\u0420\u0452\u0406\nDai Token\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nDai in Smart Contracts\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nTracking Dai Supply\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nHow to use Permit Function and Relayers to Pay Gas for Dai Transactions in Dai\n\u0420\u0452\u0406\nDai Savings Rate (DSR)\n\u0420\u0452\u0406\nDai Savings Rate integration guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nDsrManager documentation\n\u0420\u0452\u0406\nEmergency Shutdown\n\u0420\u0452\u0406\nEmergency Shutdown guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nEmergency Shutdown Design Patterns\n\u0420\u0452\u0406\nDeveloper Tools\n\u0420\u0452\u0406\nTest Chain Guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nIntroduction to Seth\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nWorking with DSProxy\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nHow to build a Dai.js wallet plugin\n\u0420\u0452\u0406\nOasis Exchange\n\u0420\u0452\u0406\nIntro to OasisDEX Protocol\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nHow to use Oasis Direct Proxy on OasisDEX Protocol\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nOasisDEX Market Maker Guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nOasisDEX Market Taker Guide\n\u0420\u0452\u0406\nGovernance\n\u0420\u0452\u0406\nVote Proxy Setup: Air-gapped Machine\n\u0420\u0452\u0406\nKeepers (Automatic CDP/Liquidation/Auction/Arbitraging Functionality)\n\u0420\u0452\u0406\nKeeper Guides Repo\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nAuctions 101\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nAuction Keeper Setup Guide\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nSimple Arbitrage Keeper\n\u0420\u0452\u0406\nMaker Protocol / Multi Collateral Dai (MCD)\n\u0420\u0452\u0406\nIntroduction and Overview of Multi-Collateral Dai: MCD101\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nUsing MCD-CLI to create and close a Vault on Kovan\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nUsing Seth to create and close a Vault on Kovan\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nUpgrading to MCD - overview for different partners\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nAdd a new collateral type to Maker Protocol - Kovan\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nIntro to the Rate mechanism\n\u0420\u0452\u0406\nPartners\n\u0420\u0452\u0406\nSetting up real money transfers using Wyre API\n\u0420\u0452\u0406\nGnosis Multisig Wallet\n\u0420\u0452\u0406\nMigrating Sai to Dai using Gnosis Multisig Wallet UI\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nActivating Dai Savings Rate on Dai in Gnosis Multisig Wallet\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nVote Proxy Setup with Gnosis Multisig Wallet\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nAdd Dai to DSR through DsrManager with Gnosis Multisig\n\u0420\u0452\u0406\nPartner compilations\nIn order to ensure that integration partners can get up and running quickly, relevant documentation for specific partner types have been compiled in a series of guides.\n\u0420\u0452\u0406\nUpgrading to Multi-Collateral Dai\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nExchanges\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nWallets\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nRemittance services\n\u0000\u0000\u0420\u0452\u0406\n\u0420\u0452\u0406\nMarket Makers\n\u0420\u0452\u0406\nContribution guidelines\nWe welcome submissions of guides and tutorials that cover new types of integrations! Following these guidelines will help us maintain consistency,\nInclude all the sections present in this \nsample guide\n\u0420\u0452\u0406\nCreate a folder with one markdown file using the same name\nAppend a number if a guide needs to be split into multiple parts\nUse \nmarkdownlint\n for ensuring a consistent style in the documents. Rules are found in \n.markdownlint.json\n root folder.\nUse \nMarkdown+Math\n for Math notations.\nLicense\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\u0420\u0452\u0406\n    http://www.apache.org/licenses/LICENSE-2.0\n\u0420\u0452\u0406\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\nSecurity - \nPrevious\nSecurity for the Maker Protocol\nNext\n - Building on top of the Maker Protocol\nThe Dai Javascript Library of the Maker Protocol\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/build/developer-guides-and-tutorials", "title": "Developer Guides and Tutorials"}}
{"page_content": "Pymaker\nA Python API for the Maker Smart Contracts\nIntroduction\nThe Maker Protocol incentivizes external agents, called \nkeepers\n, to automate certain operations around the Ethereum blockchain. In order to ease their development, an API around most of the Maker contracts has been created. It can be used not only by keepers, but may also be found useful by authors of some other, unrelated utilities aiming to interact with these contracts.\nBased on the \nPymaker API\n, a set of reference Maker keepers is being developed. They all used to reside in this repository, but now each of them has an individual one: \nbite-keeper\n (SCD only), \narbitrage-keeper\n, \nauction-keeper\n (MCD only), \ncdp-keeper\n (SCD only), \nmarket-maker-keeper\n.\nYou only need to install this project directly if you want to build your own keepers, or if you want to play with this API library itself. If you just want to install one of reference keepers, go to one of the repositories linked above and start from there. Each of these keepers references some version of \npymaker\n via a Git submodule.\nInstallation\nThis project uses \nPython 3.6.6\n.\nIn order to clone the project and install required third-party packages please execute:\ngit clone https://github.com/makerdao/pymaker.git\ncd pymaker\npip3 install -r requirements.txt\nKnown Ubuntu issues\nIn order for the \nsecp256k\n Python dependency to compile properly, following packages will need to be installed:\nsudo apt-get install build-essential automake libtool pkg-config libffi-dev python-dev python-pip libsecp256k1-dev\n(for Ubuntu 18.04 Server)\nKnown macOS issues\nIn order for the Python requirements to install correctly on \nmacOS\n, please install \nopenssl\n, \nlibtool\n, \npkg-config\n and \nautomake\n using \nHomebrew\n:\nbrew install openssl libtool pkg-config automake\nand set the \nLDFLAGS\n environment variable before you run \npip3 install -r requirements.txt\n:\nexport LDFLAGS=\"-L$(brew --prefix openssl)/lib\" CFLAGS=\"-I$(brew --prefix openssl)/include\" \nAvailable APIs\nThe current version provides APIs around:\nERC20Token\n,\nTub\n, \nTap\n,\nTop\n and \nVox\n (\nhttps://github.com/makerdao/sai\n),\nVat\n, \nCat\n, \nVow\n, \nJug\n, \nFlipper\n, \nFlapper\n, \nFlopper\n (\nhttps://github.com/makerdao/dss\n)\nSimpleMarket\n, \nExpiringMarket\n and \nMatchingMarket\n (\nhttps://github.com/makerdao/maker-otc\n),\nTxManager\n (\nhttps://github.com/makerdao/tx-manager\n),\nDSGuard\n (\nhttps://github.com/dapphub/ds-guard\n),\nDSToken\n (\nhttps://github.com/dapphub/ds-token\n),\nDSEthToken\n (\nhttps://github.com/dapphub/ds-eth-token\n),\nDSValue\n (\nhttps://github.com/dapphub/ds-value\n),\nDSVault\n (\nhttps://github.com/dapphub/ds-vault\n),\nEtherDelta\n (\nhttps://github.com/etherdelta/etherdelta.github.io\n),\n0x v1\n (\nhttps://etherscan.io/address/0x12459c951127e0c374ff9105dda097662a027093#code\n, \nhttps://github.com/0xProject/standard-relayer-api\n),\n0x v2\nDai Savings Rate (Pot)\n(\nhttps://github.com/makerdao/pymaker/blob/master/tests/manual_test_dsr.py#L29\n)\nAPIs around the following functionality have not been implemented:\nGlobal Settlement (End)\nGovernance (DSAuth, DSChief, DSGuard, DSSpell, Mom)\nContributions from the community are much appreciated!\nCode samples\nBelow you can find some code snippets demonstrating how the API can be used both for developing your own keepers and for creating some other utilities interacting with the Maker Protocol ecosystem contracts.\nToken transfer\nThis snippet demonstrates how to transfer some SAI from our default address. The SAI token address is discovered by querying the \nTub\n, so all we need as a \nTub\n address:\nfrom web3 import HTTPProvider, Web3\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.token import ERC20Token\nfrom pymaker.numeric import Wad\nfrom pymaker.sai import Tub\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"http://localhost:8545\"))\n\u0432\u0496\u04e2\ntub = Tub(web3=web3, address=Address(' 0xb7ae5ccabd002b5eebafe6a8fad5499394f67980'))\nsai = ERC20Token(web3=web3, address=tub.sai())\n\u0432\u0496\u04e2\nsai.transfer(address=Address(' 0x0000000000111111111100000000001111111111'),\n             value=Wad.from_number(10)).transact()\nUpdating a DSValue\nThis snippet demonstrates how to update a \nDSValue\n with the ETH/USD rate pulled from \nCryptoCompare\n:\nimport json\nimport urllib.request\n\u0432\u0496\u04e2\nfrom web3 import HTTPProvider, Web3\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.feed import DSValue\nfrom pymaker.numeric import Wad\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\ndef cryptocompare_rate() -> Wad:\n    with urllib.request.urlopen(\"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD\") as url:\n        data = json.loads(url.read().decode())\n        return Wad.from_number(data['USD'])\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"http://localhost:8545\"))\n\u0432\u0496\u04e2\ndsvalue = DSValue(web3=web3, address=Address(' 0x038b3d8288df582d57db9be2106a27be796b0daf'))\ndsvalue.poke_with_int(cryptocompare_rate().value).transact()\nSAI introspection\nThis snippet demonstrates how to fetch data from \nTub\n and \nTap\n contracts:\nfrom web3 import HTTPProvider, Web3\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.token import ERC20Token\nfrom pymaker.numeric import Ray\nfrom pymaker.sai import Tub, Tap\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"http://localhost:8545\"))\n\u0432\u0496\u04e2\ntub = Tub(web3=web3, address=Address(' 0x448a5065aebb8e423f0896e6c5d525c040f59af3'))\ntap = Tap(web3=web3, address=Address(' 0xbda109309f9fafa6dd6a9cb9f1df4085b27ee8ef'))\nsai = ERC20Token(web3=web3, address=tub.sai())\nskr = ERC20Token(web3=web3, address=tub.skr())\ngem = ERC20Token(web3=web3, address=tub.gem())\n\u0432\u0496\u04e2\nprint(f\"\")\nprint(f\"Token summary\")\nprint(f\"-------------\")\nprint(f\"SAI total supply       : {sai.total_supply()} SAI\")\nprint(f\"SKR total supply       : {skr.total_supply()} SKR\")\nprint(f\"GEM total supply       : {gem.total_supply()} GEM\")\nprint(f\"\")\nprint(f\"Collateral summary\")\nprint(f\"------------------\")\nprint(f\"GEM collateral         : {tub.pie()} GEM\")\nprint(f\"SKR collateral         : {tub.air()} SKR\")\nprint(f\"SKR pending liquidation: {tap.fog()} SKR\")\nprint(f\"\")\nprint(f\"Debt summary\")\nprint(f\"------------\")\nprint(f\"Debt ceiling           : {tub.cap()} SAI\")\nprint(f\"Good debt              : {tub.din()} SAI\")\nprint(f\"Bad debt               : {tap.woe()} SAI\")\nprint(f\"Surplus                : {tap.joy()} SAI\")\nprint(f\"\")\nprint(f\"Feed summary\")\nprint(f\"------------\")\nprint(f\"REF per GEM feed       : {tub.pip()}\")\nprint(f\"REF per SKR price      : {tub.tag()}\")\nprint(f\"GEM per SKR price      : {tub.per()}\")\nprint(f\"\")\nprint(f\"Tub parameters\")\nprint(f\"--------------\")\nprint(f\"Liquidation ratio      : {tub.mat()*100} %\")\nprint(f\"Liquidation penalty    : {tub.axe()*100 - Ray.from_number(100)} %\")\nprint(f\"Stability fee          : {tub.tax()} %\")\nprint(f\"\")\nprint(f\"All cups\")\nprint(f\"--------\")\nfor cup_id in range(1, tub.cupi()+1):\n    cup = tub.cups(cup_id)\n    print(f\"Cup #{cup_id}, lad={cup.lad}, ink={cup.ink} SKR, tab={tub.tab(cup_id)} SAI, safe={tub.safe(cup_id)}\")\nMulti-collateral Dai\nThis snippet demonstrates how to create a CDP and draw Dai.\nimport sys\nfrom web3 import Web3, HTTPProvider\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.deployment import DssDeployment\nfrom pymaker.keys import register_keys\nfrom pymaker.numeric import Wad\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"https://localhost:8545\",\n                         request_kwargs={\"timeout\": 10}))\nweb3.eth.defaultAccount = sys.argv[1]   # ex:  0x0000000000000000000000000000000aBcdef123\nregister_keys(web3, [sys.argv[2]])      # ex: key_file=~keys/default-account.json,pass_file=~keys/default-account.pass\n\u0432\u0496\u04e2\nmcd = DssDeployment.from_json(web3=web3, conf=open(\"tests/config/kovan-addresses.json\", \"r\").read())\nour_address = Address(web3.eth.defaultAccount)\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\n# Choose the desired collateral; in this case we'll wrap some Eth\ncollateral = mcd.collaterals['ETH-A']\nilk = collateral.ilk\ncollateral.gem.deposit(Wad.from_number(3)).transact()\n\u0432\u0496\u04e2\n# Add collateral and allocate the desired amount of Dai\ncollateral.approve(our_address)\ncollateral.adapter.join(our_address, Wad.from_number(3)).transact()\nmcd.vat.frob(ilk, our_address, dink=Wad.from_number(3), dart=Wad.from_number(153)).transact()\nprint(f\"CDP Dai balance before withdrawal: {mcd.vat.dai(our_address)}\")\n\u0432\u0496\u04e2\n# Mint and withdraw our Dai\nmcd.approve_dai(our_address)\nmcd.dai_adapter.exit(our_address, Wad.from_number(153)).transact()\nprint(f\"CDP Dai balance after withdrawal:  {mcd.vat.dai(our_address)}\")\n\u0432\u0496\u04e2\n# Repay (and burn) our Dai\nassert mcd.dai_adapter.join(our_address, Wad.from_number(153)).transact()\nprint(f\"CDP Dai balance after repayment:   {mcd.vat.dai(our_address)}\")\n\u0432\u0496\u04e2\n# Withdraw our collateral\nmcd.vat.frob(ilk, our_address, dink=Wad(0), dart=Wad.from_number(-153)).transact()\nmcd.vat.frob(ilk, our_address, dink=Wad.from_number(-3), dart=Wad(0)).transact()\ncollateral.adapter.exit(our_address, Wad.from_number(3)).transact()\nprint(f\"CDP Dai balance w/o collateral:    {mcd.vat.dai(our_address)}\")\nAsynchronous invocation of Ethereum transactions\nThis snippet demonstrates how multiple token transfers can be executed asynchronously:\nfrom web3 import HTTPProvider\nfrom web3 import Web3\n\u0432\u0496\u04e2\nfrom pymaker import Address, synchronize\nfrom pymaker.numeric import Wad\nfrom pymaker.sai import Tub\nfrom pymaker.token import ERC20Token\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"http://localhost:8545\"))\n\u0432\u0496\u04e2\ntub = Tub(web3=web3, address=Address(' 0x448a5065aebb8e423f0896e6c5d525c040f59af3'))\nsai = ERC20Token(web3=web3, address=tub.sai())\nskr = ERC20Token(web3=web3, address=tub.skr())\n\u0432\u0496\u04e2\nsynchronize([sai.transfer(Address(' 0x0101010101020202020203030303030404040404'), Wad.from_number(1.5)).transact_async(),\n             skr.transfer(Address(' 0x0303030303040404040405050505050606060606'), Wad.from_number(2.5)).transact_async()])\nMultiple invocations in one Ethereum transaction\nThis snippet demonstrates how multiple token transfers can be executed in one Ethereum transaction. A \nTxManager\n instance has to be deployed and owned by the caller.\nfrom web3 import HTTPProvider\nfrom web3 import Web3\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.approval import directly\nfrom pymaker.numeric import Wad\nfrom pymaker.sai import Tub\nfrom pymaker.token import ERC20Token\nfrom pymaker.transactional import TxManager\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=\"http://localhost:8545\"))\n\u0432\u0496\u04e2\ntub = Tub(web3=web3, address=Address(' 0x448a5065aebb8e423f0896e6c5d525c040f59af3'))\nsai = ERC20Token(web3=web3, address=tub.sai())\nskr = ERC20Token(web3=web3, address=tub.skr())\n\u0432\u0496\u04e2\ntx = TxManager(web3=web3, address=Address(' 0x57bFE16ae8fcDbD46eDa9786B2eC1067cd7A8f48'))\ntx.approve([sai, skr], directly())\n\u0432\u0496\u04e2\ntx.execute([sai.address, skr.address],\n           [sai.transfer(Address(' 0x0101010101020202020203030303030404040404'), Wad.from_number(1.5)).invocation(),\n            skr.transfer(Address(' 0x0303030303040404040405050505050606060606'), Wad.from_number(2.5)).invocation()]).transact()\nAd-hoc increasing of gas price for asynchronous transactions\nimport asyncio\nfrom random import randint\n\u0432\u0496\u04e2\nfrom web3 import Web3, HTTPProvider\n\u0432\u0496\u04e2\nfrom pymaker import Address\nfrom pymaker.gas import FixedGasPrice\nfrom pymaker.oasis import SimpleMarket\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nweb3 = Web3(HTTPProvider(endpoint_uri=f\"http://localhost:8545\"))\notc = SimpleMarket(web3=web3, address=Address(' 0x375d52588c3f39ee7710290237a95C691d8432E7'))\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nasync def bump_with_increasing_gas_price(order_id):\n    gas_price = FixedGasPrice(gas_price=1000000000)\n    task = asyncio.ensure_future(otc.bump(order_id).transact_async(gas_price=gas_price))\n\u0432\u0496\u04e2\n    while not task.done():\n        await asyncio.sleep(1)\n        gas_price.update_gas_price(gas_price.gas_price + randint(0, gas_price.gas_price))\n\u0432\u0496\u04e2\n    return task.result()\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nbump_task = asyncio.ensure_future(bump_with_increasing_gas_price(otc.get_orders()[-1].order_id))\nevent_loop = asyncio.get_event_loop()\nbump_result = event_loop.run_until_complete(bump_task)\n\u0432\u0496\u04e2\nprint(bump_result)\nprint(bump_result.transaction_hash)\nTesting\nPrerequisites:\n\u0432\u0496\u04e2\ndocker and docker-compose\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nganache-cli\n 6.2.5\n(using npm, \nsudo npm install -g \n[email\u00a0protected]\n)\nThis project uses \npytest\n for unit testing. Testing of Multi-collateral Dai is performed on a Dockerized local testchain included in \ntests\\config\n.\nIn order to be able to run tests, please install development dependencies first by executing:\npip3 install -r requirements-dev.txt\nYou can then run all tests with:\n./test.sh\nIf you have questions regarding Pymaker, please reach out to us on the \n#keeper\n channel on \nchat.makerdao.com\n.\nPrevious\nExchange Service\nNext\n - Keepers\nThe Auctions of the Maker Protocol\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/pymaker", "title": "Pymaker"}}
{"page_content": "Dai and Collateral Redemption during Emergency Shutdown\nLevel\n: Intermediate\nEstimated Time:\n 60minutes\nDescription\nThis guide describes how users can interact with the Maker protocol through proxy contracts to redeem Dai and any excess collateral if the Maker system has entered into emergency shutdown. We will define the setup process, including proxy contract setup, followed by seth calls to; redeem collateral as a Dai Holder, and free excess collateral as a Vault Owner.\nLearning Objectives\nTo redeem Dai and/or excess collateral in the event of Emergency Shutdown\nTable of Contents\nSetup Process\n1.\nInstallation\n2.\nContract Address Setup\nDai Holders to Redeem Collateral\n1.\nCheck user Dai holdings\n2.\nApprove a Proxy\n3.\nCreate Calldata\n4.\nExecute Calldata using the MYPROXY Contract\n5.\nCall cashETH or cashGEM functions\n6.\nUsing cashETH\n7.\nDefine calldata for our function\n8.\nExecute cashETHcalldata\n9.\nAlternative from step (6), Using cashGEM\n10.\nDefine calldata for our function\n11.\nCall execute in MYPROXY\nVault Owners to Redeem Excess Collateral\n1.\nVault Holder State\n2.\nRedeeming ETH using the freeETH function\n2.1. Set Call Data\n2.2 Execute this calldata\n3.\nRedeeming ETH using the freeGEM function\n3.1 Set Calldata\n3.2 Execute this calldata\nConclusion\nSetup process\n1. Installation\nIn order to interface with the Ethereum blockchain, the user needs to install seth, a command line tool as part of the \nDapp.Tools\n toolset. We also provide further \ninstallation information here\n. Once the user has installed and configured \n[seth](<https://dapp.tools/>)\n correctly to use the main Ethereum network and the address which holds their MKR, they can query contract balances, approvals and transfers.\n2. Contract Address Setup\nThe user will require the following contract addresses, shown below as mainnet addresses. Rest of mainnet or testnet addresses are accessible at \nchangelog.makerdao.com\n which can be verified on \nEtherscan\n. Similarly, additional information on the commands described below can be found in the \nEnd contract\n and the \nProxy_Actions_End contract\n. These should be setup in the following manner and pasted into the terminal line by line:\nexport DAI=0x6B175474E89094C44Da98b954EedeAC495271d0F\nexport PROXY_ACTIONS_END=0x069B2fb501b6F16D1F5fE245B16F6993808f1008\nexport MCD_END=0xaB14d3CE3F733CACB76eC2AbE7d2fcb00c99F3d5\nexport CDP_MANAGER=0x5ef30b9986345249bc32d8928B7ee64DE9435E39 \nexport PROXY_REGISTRY=0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4\nexport MCD_JOIN_ETH=0x2F0b23f53734252Bda2277357e97e1517d6B042A\nexport MCD_JOIN_BAT=0x3D0B1912B66114d4096F48A8CEe3A56C231772cA\nexport MCD_JOIN_DAI=0x9759A6Ac90977b93B58547b4A71c78317f391A28\n\u0432\u0496\u04e2\nexport MYPROXY=$(seth call $PROXY_REGISTRY 'proxies(address)(address)' $ETH_FROM) \n# This creates a unique proxy address by calling the proxy registry using the users Ethereum address.\n\u0432\u0496\u04e2\nexport ilk=$(seth --to-bytes32 $(seth --from-ascii ETH-A))\nexport ilkBAT=$(seth --to-bytes32 $(seth --from-ascii BAT-A))\n# Here we have defined two ilk (collateral types) ETH and BAT. \n# The number of ilk types needed will depend on the types of collateral vaults that the user had open.\n\u0432\u0496\u04e2\nexport ETH_GAS=4000000\nexport ETH_GAS_PRICE=2500000000\n# Typically gas costs are slightly increased when dealing with proxy contracts to prevent failed transactions.\n\u0432\u0496\u04e2\nexport cdpId=$(seth --to-dec $(seth call $CDP_MANAGER 'last(address)' $MYPROXY))\n# This is a call to the CDP Manager responsible for making the users CDP ID. \n# Note, if user created multiple vaults they will have multiple CDP IDs, all of which must be referenced to retrieve collateral.\nDai holders to Redeem Collateral\nThere are two functions to be called in order to retrieve the end collateral. The first step is \npack\n and the second step is \ncashETH\n or \ncashGem\n depending on the leftover amount of each collateral type in the system.\nDepositing Dai tokens into the system can be done using the \nPROXY_ACTIONS_END\n contract library and the \npack\n function. This function efficiently bundles together three parameters, including three parameters; the \nDai(join)\n adapter, the \nend\n contract and the amount of Dai tokens you wish to redeem for allowed collateral in one go.\nfunction pack(\n        address daiJoin,\n        address end,\n        uint wad\n    ) public {\n        daiJoin_join(daiJoin, address(this), wad);\n        VatLike vat = DaiJoinLike(daiJoin).vat();\n        // Approves the end to take out DAI from the proxy's balance in the vat\n        if (vat.can(address(this), address(end)) == 0) {\n            vat.hope(end);\n        }\n        EndLike(end).pack(wad);\n    }\n1. Check user Dai holdings\nThe user can check their Dai Token balance and subsequently save it in the \nwad\n variable so that it can be later used in the proxy function.\nexport balance=$(seth --from-wei $(seth --to-dec $(seth call $DAI 'balanceOf(address)' $ETH_FROM)))\nexport wad=$(seth --to-uint256 $(seth --to-wei 13400 eth))\n# in the above, 13400 is an example Dai balance\n2. Approve a Proxy\nThe user needs to approve \nMYPROXY\n in order to withdraw Dai from their wallet by using the following function.\nseth send $DAI 'approve(address,uint)' $MYPROXY $(seth --to-uint256 $(mcd --to-hex -1))\n3. Create Calldata\nNext it is necessary to bundle together the function definitions and parameters that the user needs to execute. This is done by preparing a function call to \nMYPROXY\n, defined as \ncalldata.\nexport calldata=$(seth calldata 'pack(address,address,uint)' $MCD_JOIN_DAI $MCD_END $wad)\n.\n.\n.\n# 0x33ef33d6000000000000000000000000fc0b3b61407cdf5f583b5b1e08514e68ecee4a73000000000000000000000000d9026db5ca822d64a6ba18623d0ff2bb07ad162c0000000000000000000000000000000000000000000002d66a5b4bc1da600000\n4. Execute calldata using the \nMYPROXY\n contract\nThe user is able to call the \nexecute\n function and utilize the \nPROXY_ACTIONS_END.pack()\n function within the environment of \nMYPROXY\n. This approves the proxy to take Dai tokens from the user's wallet into the proxy address and deposits it into the \nend\n contract, where a proportionate amount of collateral can later be claimed. Once the DAI is packed, it cannot be unpacked.\nseth send $MYPROXY 'execute(address,bytes memory)' $PROXY_ACTIONS_END $calldata\n# [example](<http://ethtx.info/kovan/0x8f4021e46b1a6889ee7045ba3f3fae69dee7ef130dbb447d4cc724771e04bcd6>) transaction showing actions involved in 'packing' the user's Dai.\n5. Call \ncashETH\n or \ncashGEM\n functions\nUsers will be able to withdraw collateral depending on the collateral that is in the VAT at the time of shutdown. For example 1 Dai will be able to claim a portion of ETH and BAT (and any other accepted collateral) which when combined will be approximately worth 1 USD. This process is completed by calling \ncashETH\n or \ncashGEM\n.\n6. \nUsing \ncashETH\nThe following function \ncashETH\n is referenced as part of the \ncalldata\n function and should be referenced \nhere\n.\nfunction cashETH(\n        address ethJoin,\n        address end,\n        bytes32 ilk,\n        uint wad\n    ) public {\n        EndLike(end).cash(ilk, wad);\n        uint wadC = mul(wad, EndLike(end).fix(ilk)) / RAY;\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n    }\n7. Define calldata for our function\nNext, we again define the calldata for our function by bundling together the \ncashETH\n parameters shown above.\nexport cashETHcalldata=$(seth calldata 'cashETH(address,address,bytes32,uint)' $MCD_JOIN_ETH $MCD_END $ilk $wad)\n8. Execute \ncashETHcalldata\nFinally, executing the \ncashETHcalldata\n in the \nexecute\n function of the user's \nMYPROXY\n contract will redeem ETH for DAI, and place this ETH into the user's ETH wallet.\nseth send $MYPROXY 'execute(address,bytes memory)' $PROXY_ACTIONS_END $cashETHcalldata\n# [example](<http://ethtx.info/kovan/0x323ab9cd9817695089aea31eab369fa9f3c9b1a64743ed4c5c1b3ec4d7218cf8>) successful transaction\n9. Alternative from step (6), Using \ncashGEM\nIt is also possible to use the \ncashGEM\n function in order to redeem different collateral types. In the below example we are referencing gemJoin as it relates to BAT.\nfunction cashGem(\n        address gemJoin,\n        address end,\n        bytes32 ilk,\n        uint wad\n    ) public {\n        EndLike(end).cash(ilk, wad);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, mul(wad, EndLike(end).fix(ilk)) / RAY);\n    }\n10. Define calldata for our function\nSimilarly, as done in step (7), the user needs to define the calldata to interact with \ncashGEM\nexport cashBATcalldata=$(seth calldata 'cashETH(address,address,bytes32,uint)' $MCD_JOIN_BAT $MCD_END $ilkBAT $wad)\n11. Call execute in \nMYPROXY\nFinally, executing the \ncashBATcalldata\n in the \nexecute\n function of the user's \nMYPROXY\n contract will redeem BAT for DAI, and place this BAT into the user's ETH wallet.\nseth send $MYPROXY 'execute(address,bytes memory)' $PROXY_ACTIONS_END $cashBATcalldata\nVault Owners to Redeem Excess Collateral\nLikewise, a vault owner can use the \nfreeETH\n or \nfreeGEM\n proxy actions function to retrieve any excess collateral they may have locked in the system.\n1. Vault Holder State\nThere are some constraints for vault holders to be aware of. For example, if a user\u0432\u0496\u04b7s Vault is under-collateralised then they will not have any excess collateral to claim. Likewise, if the user\u0432\u0496\u04b7s Vault is currently in a flip auction at the time of emergency shutdown, it will be necessary for the Vault holder to cancel the auction by calling \nskip(ilk, id)\n before calling \nfree__()\n.\nSimilarly, these functions have been completed using Maker proxy contract calls. There may be other scenarios in which 3rd party front ends such as InstaDApp have their own proxies, which will require users to exit from their proxy in order to use the below.\n2. Redeeming ETH using the \nfreeETH\n function\nfunction freeETH(\n        address manager,\n        address ethJoin,\n        address end,\n        uint cdp\n    ) public {\n        uint wad = _free(manager, end, cdp);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n2.1. Set calldata\nDepending on how many vaults the user has, it will be necessary to repeat this process for each vault ID.\nexport freeETHcalldata=$(seth calldata 'freeETH(address,address,address,uint)' $CDP_MANAGER $MCD_JOIN_ETH $MCD_END $cdpId )\n2.2. Execute this calldata\nExecuting the \nMYPROXY\n contract will redeem ETH and place it into the users address.\nseth send $MYPROXY 'execute(address,bytes memory)' $PROXY_ACTIONS_END $freeETHcalldata\n3. Redeeming ETH using the \nfreeGEM\n function\nfunction freeGem(\n        address manager,\n        address gemJoin,\n        address end,\n        uint cdp\n    ) public {\n        uint wad = _free(manager, end, cdp);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wad);\n    }\n3.1. Set calldata\nDepending on how many vaults the user has, it will be necessary to repeat this process for each vault ID.\nexport freeBATcalldata=$(seth calldata 'freeETH(address,address,address,uint)' $CDP_MANAGER $MCD_JOIN_BAT $MCD_END $cdpId )\n3.2. Execute this calldata\nExecuting the \nMYPROXY\n contract will redeem BAT (or other collateral types) and place them into the users address.\nseth send $MYPROXY 'execute(address,bytes memory)' $PROXY_ACTIONS_END $freeBATcalldata\nConclusion\nThe above outlines how to redeem Dai and excess Vault collateral using the command line.\nIn summary, we showed how to check your Dai holdings, how to approve a proxy to withdraw Dai from your wallet and then to use \ncashETH/GEM\n functions to withdraw collateral into the user\u0432\u0496\u04b7s ETH wallet using the \nMYPROXY\n contract . For Vault owners, we showed how to redeem collateral by using the \nMYPROXY\n contract and the \nfreeGEM\n function.\nIn the event of emergency shutdown we envision that it will still be possible to sell Dai on the open market as well as by making use of economically incentivized redemption keepers to meet market needs for both Dai owners and Vaults holders.\nCommand-line Interfaces - \nPrevious\nMulti Collateral Dai (MCD) CLI\nNext\n - Command-line Interfaces\nEmergency Shutdown (ES) CLI\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/clis/dai-and-collateral-redemption-during-emergency-shutdown", "title": "Dai and Collateral Redemption during Emergency Shutdown"}}
{"page_content": "Emergency Shutdown (ES) CLI\nLevel\n: Intermediate\nEstimated-Time\n: 30 minutes\nDescription\nEmergency Shutdown (ES) is the last resort to protect the Maker Protocol against a serious threat, such as but not limited to governance attacks, long-term market irrationality, hacks and security breaches. The Emergency Shutdown Module (ESM) is responsible for coordinating emergency shutdown, the process used to gracefully shutdown the Maker Protocol and properly allocate collateral to both Vault users and Dai holders. This guide outlines the steps and procedures necessary to check, interact with and trigger the ESM.\nLearning Objectives:\n To be able to Check, Deposit and Trigger Emergency Shutdown.\nTable of Contents\n1.\nInstallation\n2.\nContract Address Setup\n3.\nCommands and Explanations\nChecking your MKR balance\nChecking and setting your MKR approval\nChecking the live() flag\nChecking the ESM threshold\nDeposit a trial amount of MKR into the ESM\nDepositing MKR into the ESM\nChecking how much MKR is in the ESM\nChecking whether the ESM has been triggered\nTriggering the ESM\n1. Installation\nIn order to interface with the Ethereum blockchain, the user needs to install seth, a command line tool as part of the \nDapp.Tools\n toolset. We also provide further \ninstallation information here\n. Once the user has installed and configured \nseth\n correctly to use the main Ethereum network and the address which holds their MKR they can query contract balances, approvals and transfers.\n2. Contract Address Setup\n* The user will require the following contract addresses; MCD_END and MCD_ESM accessible at [Changelog.makerdao.com](https://changelog.makerdao.com) as well as the Maker contract address, to be added in place of MKR_ADR below, which can be verified on [Etherscan](https://etherscan.io/token/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2).\n* These should be setup in the following manner:\nexport MCD_END= 0xab14d3ce3f733cacb76ec2abe7d2fcb00c99f3d5\nexport MCD_ESM= 0x0581a0abe32aae9b5f0f68defab77c6759100085\nexport MKR_ADR= <MKR ADDRESS from Etherscan.io>\nexport MY_ADR= <USER ADDRESS>\n \n#example values for depositing into the ESM\nexport TRIAL_AMOUNT=$(seth --to-uint256 $(seth --to-wei 0.1 eth))\nexport REMAINING_AMOUNT=$(seth --to-uint256 $(seth --to-wei 50000 eth))\n3. Commands and Explanations\nChecking your MKR balance\nBefore depositing your MKR into the ESM contract, first check your address MKR balance:\nseth --from-wei $(seth call $MKR_ADR \"balanceOf(address)\" $MY_ADR | seth --to-dec)\n# 100000.000000000000000000 \nChecking and setting your MKR approval\nIn order to execute the contract functions of the MKR token it is required that approvals be set on the token. The first step is to check if the ESM contract is allowed to withdraw from your address:\nseth call $MKR_ADR \"allowance(address,address)\" $MY_ADR $MCD_ESM\n# 0x0000000000000000000000000000000000000000000000000000000000000000 -> not allowed\nIf the ESM contract is not allowed to withdraw from your address, the following can be used to set the allowance on the MKR token. This will approve the ESM to withdraw from the user's wallet:\nseth send $MKR_ADR \"approve(address)\" $MCD_ESM\nFollowing which we again check to confirm that the ESM is allowed to withdraw from the user's account. This action will return uint256 to confirm the allowance to withdraw.\nseth call $MKR_ADR \"allowance(address,address)\" $MY_ADR $MCD_ESM\n# 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> allowed\n\u0432\u0496\u04e2\nReference contract information\n.\nChecking the live flag\nLive contracts have \nlive\n = 1, indicating that the system is running normally. Thus when \ncage()\n is invoked, it sets the flag to 0.\nseth call $MCD_END \"live()\" | seth --to-dec\n# 1 -> system is running normally\nChecking the ESM threshold\nIn order to check the \nmin\n value, you can call:\nseth --from-wei $(seth call $MCD_ESM \"min()\" | seth --to-dec)\n# 50000.000000000000000000\nDeposit a small amount (0.1 MKR) into the ESM\nTo deposit a small amount of MKR into the esm contract to test correct deposit function, we use the \njoin\n function and specify a small amount.\nseth send $MCD_ESM \"join(uint256)\" $TRIAL_AMOUNT \nChecking how much MKR is in the ESM\nTo check for the total amount of MKR that has been added to the ESM we call the \nSum()\n function\nseth --from-wei $(seth call $MCD_ESM \"Sum()\" | seth --to-dec)\n# 50050.000000000000000000\nChecking how much MKR you have included in the ESM\nTo check how much MKR you have included in the ESM we can call lowercase \nsum()\n with the user address as an argument:\nseth --from-wei $(seth call $MCD_ESM \"sum(address)\" $MY_ADR | seth --to-dec)\n# 50.000000000000000000\nDepositing e.g. 50,000 MKR into the ESM\nTo deposit MKR into the esm contract we use the \njoin\n function and specify the amount.\nseth send $MCD_ESM \"join(uint256)\" $REMAINING_AMOUNT \nPlease specify the amount of MKR that you intend to deposit into the ESM.\nChecking whether the ESM has been triggered\nTo validate that the Emergency Shutdown has been triggered, the \nfired()\n function can be called which will return a boolean.\nseth call $MCD_ESM \"fired()\" | seth --to-dec\n# 0 -> ES has not been triggered\nTriggering the ESM\nIn order for the emergency shutdown to trigger, it is required that the \nSum()\n is greater than the \nmin()\n . Only then can the \nfire()\n function be executed successfully.\nseth send $MCD_ESM \"fire()\"\nNote:\n If triggering the ESM is not successful, ensure gas is set at an appropriate level\nNote:\n The triggering of the ESM is \nnot\n to be taken lightly; for a full explanation of the implications please review the below documentation.\nLinks\n\u0432\u0496\u04e2\nESM.sol\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFurther Documentation\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEnd Documentation\n\u0432\u0496\u04e2\nCommand-line Interfaces - \nPrevious\nDai and Collateral Redemption during Emergency Shutdown\nNext\n - Miscellaneous\nLiquidations 1.2 System (Deprecated)\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/clis/emergency-shutdown-es-cli", "title": "Emergency Shutdown (ES) CLI"}}
{"page_content": "Multi Collateral Dai (MCD) CLI\nWelcome to the MCD CLI\nInstallation\nFirst install \ndapp tools\n:\n$ curl https://dapp.tools/install | sh\nThen install the \nmcd\n package:\n$ dapp pkg install mcd\n\nThe following list details all of the commands available when interacting with the command-line interface: \nMCD - Multi-collateral Dai\n\u0432\u0496\u04e2\nUsage: mcd [<options>] <command> [<args>]\n   or: mcd help [<command>]\n\u0432\u0496\u04e2\nCommands:\n\u0432\u0496\u04e2\n   bite            Trigger liquidation of an unsafe Urn\n   bites           Recent bites\n   cdp             CDP managerment\n   dai             Dai management\n   debt            Total dai issuance\n   drip            Trigger stability fee accumulation\n   flap            Trigger a flap auction\n   flips           View flips and kick-off auctions\n   flog            Release queued bad-debt for auction\n   flop            Trigger a flop auction\n   frob            Urn management\n   frobs           Recent frobs\n   gem             Collateral management\n   help            Print help about mcd or one of its subcommands\n   ilk             Ilk (collateral type) parameters\n   line            Total debt ceiling\n   live            Liveness flag\n   poke            Update the spot price for a given Ilk\n   unwrap          Unwrap WETH to ETH\n   urn             CDP state\n   vice            Total bad debt\n   vow             Liquidator balances\n   wrap            Wrap ETH to WETH\nConfiguration\nMcd is built on \nSeth\n and uses the same network configuration options, which just like Seth, can be defined in the \n~/sethrc\n initialisation file.\nSimilar to Seth, \nmcd\n also supports transaction signing with Ledger hardware wallets and can run against both local and remote nodes.\nSince \nmcd\n will always be used against a known deployment of the system, defaults can be loaded wherever possible. In most cases the only required configuration parameter is the \n-C, --chain=<chain>\n (\nMCD_CHAIN\n) option and \n-F, --from=<address>\n (\nETH_FROM\n) sender account when not using a testnet.\nExample \n~/.sethrc\n:\n#!/usr/bin/env bash\nexport ETH_FROM=0x4Ffa8667Fe2db498DCb95A322b448eA688Ce430c\nexport MCD_CHAIN=kovan\nKovan\nRun against the latest Kovan deployment by setting the \n-C, --chain\n option to \nkovan\n. Specify a sender account when sending transactions using the \n-F, --from\n option, or via the \nETH_FROM\n env variable.\n$ export ETH_FROM=0x4Ffa8667Fe2db498DCb95A322b448eA688Ce430c\n$ mcd --chain=kovan dai join 100\nRemote testchain\nRun agaist remote testchain deployments by setting the \n-C, --chain\n option to the remote testchain Id. Mcd will auto-configure account settings via the testchain api so that no further configuration is required. To view a list of available testchains run:\n$ mcd testnet chains`\nThen set the chain option, or the chain env variable to the appropriate testchain Id.\n$ export MCD_CHAIN=12899149080555595289\n$ mcd dai join 100\nLocal testnet\nRun against a locally running instance of \nDapp testnet\n where the system has been deployed by setting the \nC, --chain\n option to \ntestnet\n. Mcd will auto-configure account testings for \ndapp testnet\n so that no further configuration is required.\nBy default, Mcd assumes that the output of the testchain deployment script is available at \n~/.dapp/testnet/8545/config/addresses.json\n. Configuration addresses can be loaded from a different location by setting the \n--config\n (\nMCD_CONFIG\n) option.\n$ export MCD_CONFIG=~/testchain-deployment-scripts/out/addresses.json\n$ mcd -C testnet dai join 100\nIlk\nIlks are collateral types with corresponding risk parameters which have been approved by system governance. Use the \nilks\n command to view the list off available Ilks.\n$ mcd ilks\nILK      GEM    DESC\n\u0432\u0496\u04e2\nETH-A    WETH   Ethereum\nETH-B    WETH   Ethereum\nREP-A    REP    Augur\nEach Ilk has its own set of configuration parameters which can be viewed via the \nilk\n command. The \nI, --ilk=<id>\n option is used to scope commands to a particular Ilk:\n$ mcd --ilk=ETH-A ilk\nArt  40.000000000000000000                      Total debt (DAI)\nrate 1.000080370887129123082627939              WETH DAI exchange rate\nspot 99.333333333333333333333333333             WETH price with safety mat (USD)\nline 1000.0000000000000000000000000000000000000 Debt ceiling (DAI)\ndust 0.0000000000000000000000000000000000000000 Debt floor (DAI)\nflip 0x9d905effff127a01da3b38124f8da88e766eb8dd Flip auction contract\nchop 1.000000000000000000000000000              Liquidation penalty\nlump 10000.000000000000000000                   Flip auction lot size\ntax  1.000000000782997609082909351              Stability fee\nrho  1552802862                                 Last drip timestamp\npip  0x98312e16f5b2c0def872a1f7484a8456e5a67a3b Price feed contract\nmat  1.500000000000000000000000000              Liquidation ratio\nIndividial ilk values can be retrieved by adding the parameter name as an argument to the \nilk\n command:\n$ mcd --ilk=ETH-A ilk spot\n99.333333333333333333333333333\nGem\nGems are collateral tokens. Collateral is added and removed from the via adapters, which abstract away the differences between various token behaviours. Use \ngem [<subcommand>]\n to manage collateral balances for any given Ilk.\ngem --ilk=<id> symbol             Gem symbol e.g. WETH\ngem --ilk=<id> balance            Print balances for a given urn (default: ETH_FROM)\ngem --ilk=<id> join <wad>         Add collateral to a given Urn (default: ETH_FROM)\ngem --ilk=<id> exit <wad> [<guy>] Remove collateral from an Urn (default: ETH_FROM)\nThe \njoin\n command can add collateral from the sender account to any specified Urn. The \nexit\n command can remove collateral from a specified Urn, provided that the sender controls the private key associated with that Urn.\nBy default, \nETH_FROM\n is used to determine which Urn should be credited with collateral. Use \nU, --urn=<address>\n to optionally credit an Urn other than the default.\n$ mcd --ilk=ETH-A --urn=0x123456789abcdef0123456789abcdef012345678 join 100\nThe \nexit\n command can remove collateral from a specified Urn, provided that the sender controls the private key associated with that Urn. The \nexit\n command can also withdraw collateral to an account other than \nETH_FROM\n buy passing the destination address as an additional argument:\n$ mcd --ilk=ETH-A exit 100 0xDecaf00000000000000000000000000000000000\nUrn\nUrns represent Cdp state for any given Urn address.\nUse the \nurn\n command to view Urn state for any given Ilk:\nilk  ETH-A                                      Collateral type\nurn  0xC93C178EC17B06bddBa0CC798546161aF9D25e8A Urn handler\nink  45.000000000000000000                      Locked collateral (WETH)\nart  120.000000000000000000                     Issued debt (Dai)\ntab  120.000244107582797248312544980            Outstanding debt (Dai)\nrap  0.000244107582797248312544980              Accumulated stability fee (Dai)\n-->  37.24                                      Collateralization ratio\n\u0432\u0496\u04e2\nspot 99.333333333333333333333333333             WETH price with safety mat (USD)\nrate 1.000002034229856643749638820              WETH DAI exchange rate\nBy default, \nETH_FROM\n is used to determine which Urn to query. Use the \nU, --urn=<address>\n option to query Urns at other indexes.\nUrn management\nUrn state (\nurn.ink\n and \nurn.art\n) is managed via the \nfrob <dink> <dart>\n command, where \ndink\n and \ndart\n are delta amounts by which \nink\n (Locked collateral) and \nart\n (Outstanding debt) should be changed. For example, to lock 100 WETH and draw 400 Dai on the ETH-A Ilk:\n$ mcd --ilk=ETH-A frob 100 400\nTo reduce outstanding debt by 200 Dai whilst keeping the amount of locked collateral constant:\n$ mcd --ilk=ETH-A frob -- 0 -200\nDai\nSimilar to Gem adapters, a Dai adapter is used to exchange Vat Dai for ERC20 token Dai which can then be used outside the system. Use \ndai [<subcommand>]\n to manage dai balances.\ndai balance    Print balances for a given urn (default: ETH_FROM)\ndai join <wad> Exchange DSToken Dai for Vat Dai\ndai exit <wad> Exchange Vat Dai for DSToken Dai\nOnce Dai has been drawn on an Urn, it can be withdrawn for use outside the system using \ndai exit\n. Dai can be returned to repay Urn debt via \ndai join\n.\nThe \ndai balance\n command displays the internal system (vat) balance and the external (ext) token balance:\n$ mcd dai balance\nvat 1030.003120998308631176024235912000000000000000000 Vat balance\next 0.000000000000000000 ERC20 balance\nIndividial balance values can be retrieved by adding \nvat\n or \next\n as an argument to the \nbalance\n command:\n$ mcd dai balance vat\n1030.003120998308631176024235912000000000000000000\nCdp\nThe \ncdp\n command provides compatability with CDPs managed via the CDP Portal and uses the same proxy contract and \nCdp Manager\n font-end. This allows CDPs to be managed via a unique integer identifier rather than the \nI, --ilk\n and \nU, --urn\n options.\nUsage: mcd cdp [<id>] [<command>]\n\u0432\u0496\u04e2\nCommands: ls [<owner>]     List Cdps\n          count [<owner>]  Cdp count\n          open             Open a new Cdp\n          <id> urn         Cdp state\n          <id> lock <wad>  Join & lock collateral\n          <id> free <wad>  Free & exit collateral\n          <id> draw <wad>  Draw & exit dai\n          <id> wipe <wad>  Join & wipe dai\nExamples\nNote: examples assume that \nETH_FROM\n is set to an address controlled by the user, and that the \nMCD_CHAIN\n env variable has been set to a vaild chain identifier.\n1. Native Urn - lock 100 ETH & draw 500 Dai\nNote: The system doesn't handle ETH directly but instead uses WETH to represent ETH collateral. For convenience, the \nwrap\n and \nunwrap\n commands are provided for exchanging ETH to WETH and visa versa.\n# i) Wrap\n$ mcd wrap 100\neth  900.000000000000000000\nweth 100.000000000000000000\n\u0432\u0496\u04e2\n# ii) Gem join\n$ mcd --ilk=ETH-A gem join 100\n$ Grant approval to move WETH to the Vat? [Y/n]: Y\nvat 100.000000000000000000 Free collateral (WETH)\nink   0.000000000000000000 Locked collateral (WETH)\next   0.000000000000000000 External account balance (WETH)\next 900.000000000000000000 External account balance (ETH)\n\u0432\u0496\u04e2\n# iii) Lock & Draw\n$ mcd --ilk=ETH-A frob 100 500\nilk  ETH-A                                      Collateral type\nurn  0xC93C178EC17B06bddBa0CC798546161aF9D25e8A Urn handler\nink  100.000000000000000000                     Locked collateral (WETH)\nart  500.000000000000000000                     Issued debt (Dai)\ntab  500.000244107582797248312544980            Outstanding debt (Dai)\nrap  0.000244107582797248312544980              Accumulated stability fee (Dai)\n-->  19.86                                      Collateralization ratio\n\u0432\u0496\u04e2\n# iv) Withdraw Dai\n$ mcd dai exit 500\nvat 0.000060682318362511884962000000000000000000000 Vat balance\next 500.000000000000000000 ERC20 balance\n2. Managed Cdp - lock 100 REP & draw 50 Dai\n# i) Open\n$ mcd --ilk=REP-A cdp open\nmcd-cdp-open: Waiting for transaction receipt...\n0x800e5578d3ac4b77b7ada1aba48cf80d0d238d4392d2676d79159eac2c2cdd73\nOpened: cdp 19\n\u0432\u0496\u04e2\n# ii) Lock\n$ mcd --ilk=REP-A cdp 19 lock 100\nseth-send: Published transaction with 260 bytes of calldata.\nseth-send: 0x4d30cb4863ca997d24ff2346c9a92e86648369ce7b4a86ed004c73b8d4ef299a\nseth-send: Waiting for transaction receipt...\nseth-send: Transaction included in block 333.\nilk  REP-A                                      Collateral type\nurn  0x4518c4709a50C915b7996A0e6Dfb38c67248BBcF Urn handler\nink  100.000000000000000000                     Locked collateral (REP)\nart  0.000000000000000000                       Issued debt (Dai)\ntab  0                                          Outstanding debt (Dai)\nrap  0                                          Accumulated stability fee (Dai)\n-->  0                                          Collateralization ratio\n\u0432\u0496\u04e2\n# iii) Draw\n$ mcd --ilk=REP-A cdp 19 draw 500\nseth-send: Published transaction with 260 bytes of calldata.\nseth-send: 0xd5fb7ddf94bb910fbba2af118ecde88a03a13129b2e1979238236afe672781c3\nseth-send: Waiting for transaction receipt...\nseth-send: Transaction included in block 335.\nilk  REP-A                                      Collateral type\nurn  0x4518c4709a50C915b7996A0e6Dfb38c67248BBcF Urn handler\nink  100.000000000000000000                     Locked collateral (REP)\nart  49.999505439113270178                      Issued debt (Dai)\ntab  50.000000000000000000000000000             Outstanding debt (Dai)\nrap  0.000494560886729822000020743              Accumulated stability fee (Dai)\n-->  16.66                                      Collateralization ratio\nCommand-line Interfaces - \nPrevious\nSeth\nNext\n - Command-line Interfaces\nDai and Collateral Redemption during Emergency Shutdown\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/clis/mcd-cli", "title": "Multi Collateral Dai (MCD) CLI"}}
{"page_content": "Seth\nA powerful command line tool created to interface with the Ethereum blockchain\nIntroduction to Seth\nSeth is a simple, but powerful command line tool created to interface with the Ethereum blockchain. It is part of the \nDapp.Tools\n toolset along with other tools for Ethereum. Its two main functionalities among others are performing calls (queries of the Ethereum blockchain - a \u0432\u0496\u04a3read\u0432\u0496\u049b operation) and sending transactions (writing into the blockchain, changing its state). It also provides conversion between data of Ethereum\u0432\u0496\u04b7s own specific formats and the more widespread, usual data formats.\nGetting started\nIn the following section we will go through the installation and setup of Seth. These steps only work on Unix-based systems (i.e. Linux and macOS), however on Windows, you can try with an emulator, like \ncmder\n or \ncygwin\n, the \nlinux subsystem\n in Windows 10, a virtual machine or a container.\nInstallation\nSeth can be installed as a part of the Dapp Tools suite, which is a collection of blockchain tools created with the Unix philosophy in mind. The most convenient way to do this, is to install Dapp Tools with the one line script provided on the \nwebpage\n. Here is how to do it:\nFrom the Dapp Tools page:\nIf you are running GNU/Linux or macOS you can take advantage of our all in one installer.\n$ curl https://dapp.tools/install | sh\nThis script downloads the Nix package manager, setups binary cache with Cachix and installs our most used tools.\nManual install\nIf you have issues using the script above, you can try the manual installation on the aforementioned website. A this point in time you can do a manual installation by running the following scripts:\n$ curl https://nixos.org/nix/install | sh\n$ . \"$HOME/.nix-profile/etc/profile.d/nix.sh\"\n$ nix-env -if https://github.com/cachix/cachix/tarball/master --substituters https://cachix.cachix.org --trusted-public-keys cachix.cachix.org-1:eWNHQldwUO7G2VkjpnjDbWwy4KQ/HNxht7H4SSoMckM=  \n$ cachix use dapp  \n$ git clone --recursive [https://github.com/dapphub/dapptools](https://github.com/dapphub/dapptools) $HOME/.dapp/dapptools  \n$ nix-env -f $HOME/.dapp/dapptools -iA dapp seth solc hevm ethsign\nIn order to test if the tools have been installed correctly, check the current version of Seth with the following command:\n$ seth --version\nIf Seth has been installed correctly, the command should produce the following output:\nseth 0.7.0\nAt the time of writing, seth 0.7.0 is thus the latest version, however in the future the output might have a different versioning number.\nErrors and a note on macOSX Mojave\nIf the above command does not work, or you had trouble installing it may be due to Mac OSX Mojave, as we have experienced various issues with the tools nix and cachix not working correctly on this OS, specifically due to a multi-user bug. If you happen to have more user accounts on your Mac, and experience errors running this guide, \nthis document\n might help you resolve the issue. If this does not resolve the issue, you are more than welcome to ask for help on \nchat.makerdao.com\n in the #help channel.\nSet up and configuring variables\nConfiguring Seth can be done with environment variables or command line options. Environment variables can be generally used in two ways: you can save them in a configuration file named .sethrc in specific locations, like your home folder, or just set them only for the current terminal session. In this guide we will use environment variables with the latter approach for simplicity\u0432\u0496\u04b7s sake, however for ease-of-use in the future, we strongly encourage to save the variables in your project folder. Follow \nthis example\n to do so.\nUsing a local private network\nYou can quickly set up a local private network with the Dapp tool, which will also create accounts and their keystore files with empty strings for passwords by default. Setting up a local network can be handy when developing dapps for a quick an easy and way to deploy and test functionality without the need of acquiring test-net Ether for contract deployment.\nOpen a new terminal and execute the following command, and keep it running in the background during the tutorial:\n$ dapp testnet\nCopy your account address from the output.\nThen in a separate terminal let\u0432\u0496\u04b7s create an empty password file:\n$ touch pass\nAnd let\u0432\u0496\u04b7s create our environment variables:\n$ export ETH_PASSWORD=$PWD/pass   \n$ export ETH_KEYSTORE=~/.dapp/testnet/8545/keystore   \n$ export ETH_FROM=<your ethereum account address>\nUsing Kovan\nSeth can connect to the Kovan Ethereum testnet through a default remote node provided by Infura. This is the most convenient way to do so. You can either create a new account or use the existing one created by the testnet. If you decide to use the existing one, you only need to change the chain parameter:\n$ export SETH_CHAIN=kovan\nIf you decide to create a new account, an easy method is using the \"create new wallet\" option in MEW: \nhttps://www.myetherwallet.com/\n. It is also possible to use Parity or Geth to create a new account or you can use an existing keystore file for a Parity or Geth account. You are also going to need to save the password of your keystore file in a plain text file (Never use this keystore file for real ETH - saving the password for your keystore file in plain text would be very unsafe for a real account! This also goes for the testnet account!).\nThen you have to set up the same variables:\n$ export ETH_KEYSTORE=<path to your keystore folder>\n$ export ETH_PASSWORD=<path and filename to the text file containing the password for your account e.g: /home/one1up/MakerDAO/415pass >\n$ export ETH_FROM=<your ethereum account address> \n$ export SETH_CHAIN=kovan\nYou will need Kovan ETH for gas, you can get some by following the guide here: \nhttps://github.com/kovan-testnet/faucet\n\u0432\u0496\u04e2\nSeth operations\nFor the first two operations you can use either your own testnet or the Kovan testnet - try both if you want to!\nseth balance - Checking ETH balance\nChecking ETH balances is pretty straight forward. It can be done with the balance subcommand, then specifying the address as a parameter:\n$ seth balance $ETH_FROM\nseth send - Sending ETH\nLet\u0432\u0496\u04b7s send Kovan or private net ETH to an address. You can choose any valid address - in this example I am going to use \nEthereum Foundation's donation address\n:\n$ seth send --value 0.1 \n 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359\n\u0432\u0496\u04e2\nUpon execution you should see something like the following:\nseth-send: warning: `ETH_GAS' not set; using default gas amount\nseth-send: Published transaction with 0 bytes of calldata.\nseth-send: 0x000000\u0432\u0496\u04b0\nseth-send: Waiting for transaction receipt.......\nseth-send: Transaction included in block xxxxxx.\nThis indicates that the transaction was successful.\nseth call - Reading contract storage\nSince we don't have any contracts deployed to our private network, \nlet's use Kovan from now on\n. Let\u0432\u0496\u04b7s use one of the simplest contracts possible: an ERC-20 token contract. In this example, we are going to use a test collateral token (COL1). You can save its address in a variable with the following command:\n$ export COL1=0x911eb92e02477a4e0698790f4d858e09dc39468a\nYou can read the output of a public function of a contract using the call subcommand, the contract\u0432\u0496\u04b7s address, and the name of the function.\nLet's check out the number of decimals of this token:\nseth call $COL1 'decimals()'\nThe output is:\n0x0000000000000000000000000000000000000000000000000000000000000012\nNow don't let this fool you. Seth queries contract data in a low level manner, and returns the value in hexadecimal, as it is represented in the contract, but you can convert it using:\n$ seth --to-dec $(seth call $COL1 'decimals()')\nThe output is:\n18\nSending contract transaction with seth send\nYou can send a transaction to a contract with the same send command, by adding a couple of extra parameters. Just like with call, you need to specify the contract address and the function we are calling. Let\u0432\u0496\u04b7s get some COL1 tokens from a previously set up faucet:\n$ export FAUCET=0xe8121d250973229e7988ffa1e9330b420666113a\n$ seth send $FAUCET \u0432\u0496\u04b3gulp(address)\u0432\u0496\u04b7 $COL1\nUsing function parameters\nNow you can check your COL1 balance. This time you will need to present a parameter for the \u0432\u0496\u04b3balanceOf\u0432\u0496\u04b7 method of the ERC-20 contract. You can do this by first defining the type, the function takes in its parentheses, and then putting the input parameter after the method:\n$ seth --to-dec $(seth call $COL1 'balanceOf(address)' $ETH_FROM)\nThe output is:\n500000000000000000000\nNow, that's a rather large value we got. The reason for this is that the contract stores the balances in wei unit (10^-18), which is why we have to convert it to get the actual number of COL1 we own:\n$ seth --from-wei $(seth --to-dec $(seth call $COL1 'balanceOf(address)' $ETH_FROM)) eth\nThe output is:\n50.000000000000000000\nseth block - Retrieving block information\nWith seth block, we are capable of querying any information about an Ethereum block. Here is the usage from the help option \n$ seth block --help\n:\nUsage: seth block [-j|--json] <block> [<field>] \nPrint a table of information about <block>.\nIf <field> is given, print only the value of that field.\nLike any other Seth command, this command depends on Ethereum JSON RPC calls, which are part of the interface of any Ethereum client. You can dive into the corresponding documentation (\nhttps://github.com/ethereum/wiki/wiki/JSON-RPC\n) to learn more about it.\nWhat can come in handy is the fact that in place of a block number, we can also use earliest, latest or pending. So if we would like to query the current block gas limit (I have tried this with seth configured for the kovan testnet) we can do the following:\n$ seth block latest gasLimit\nOutput:\n8000000\nseth estimate - Estimating gas cost of a transaction\nseth estimate\n can give an estimation for the gas usage of a transaction. The syntax is pretty much the same as for \nseth send\n, but \nseth estimate\n will not actually send the transaction.\nWhen you want to send a transaction to a contract function with Seth, you have to provide the function signature and the parameters in order after the signature. The ERC-20 transfer function signature looks like the following in Solidity:\ntransfer(address _to, uint256 _value) public returns (bool success)\nThe signature part that Seth needs from this is 'transfer(address, uint)' and the parameters are the recipient address and the amount. The contract needs to receive the amount in hexadecimal representation of the number in wei unit, which is why we need those conversions.\nNow, to estimate the gas usage of an ERC-20 token transfer let\u0432\u0496\u04b7s execute the following:\n$ seth estimate $COL1 'transfer(address, uint)' \n 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359\n $(seth --to-uint256 $(seth --to-wei 0.1 ether))\nOutput:\n37240\nseth receipt and seth tx\nWith seth receipt and seth tx, we can query every single detail imaginable about a transaction. They both take a transaction (tx) hash as an input parameter. The main difference between the two, is that the receipt, which contains the results of the transaction, is only constructed after the transaction gets mined, while the output of seth tx only contains the basic parameters of the transaction before it takes effect.\nYou can try them for example by first executing a transaction to have a transaction hash:\n$ seth send $COL1 'transfer(address, uint)' \n 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359\n $(seth --to-uint256 $(seth --to-wei 0.1 ether))\nOutput:\nseth-send: Published transaction with 68 bytes of calldata.\nseth-send: 0x58ba3980775741aecaf8435646a003bff3395d7d4e00c8f7a32ad1fa0ce64e01\nseth-send: Waiting for transaction receipt....\nseth-send: Transaction included in block 9704345.\nNow you can try the discussed commands (use your own tx hash from the previous tx):\n$ seth receipt 0x58ba3980775741aecaf8435646a003bff3395d7d4e00c8f7a32ad1fa0ce64e01\n$ seth tx 0x58ba3980775741aecaf8435646a003bff3395d7d4e00c8f7a32ad1fa0ce64e01\nThese both generate a pretty long output, but we can filter each query with an optional extra parameter. For example let's see, how accurate was our previous estimation for the gas consumption (it was perfectly accurate):\n$ seth receipt 0x58ba3980775741aecaf8435646a003bff3395d7d4e00c8f7a32ad1fa0ce64e01 gasUsed\nOutput:\n\n37240\nAdditional Resources\nThis guide was written based on the official documentation in the Github repository of Seth. You can find additional information over there: \nhttps://github.com/dapphub/dapptools/tree/master/src/seth\n\u0432\u0496\u04e2\nKnown Issues\nIssues with MacOS Mojave\nKeepers - \nPrevious\nChief Keeper\nNext\n - Command-line Interfaces\nMulti Collateral Dai (MCD) CLI\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/clis/seth", "title": "Seth"}}
{"page_content": "Maker Protocol Deployments\nFind all Maker Protocol contract addresses and ABIs at \nchainlog.makerdao.com\n\u0420\u0452\u0406\nThe \nChainlog\n provides valuable information for developers interacting with Maker Protocol deployments. This includes deployments on the following networks: \nEthereum Mainnet (\nlatest release\n)\nEthereum Goerli Testnet (\nlatest release\n)\nEach release includes the following information: \nContract addresses with link to Etherscan\nABIs\nOnchain Contract Address Directory\nThe Chainlog is also available as an onchain smart contract directory (\ndss-chain-log\n) that allows developers to programatically fetch Maker Protocol contract addresses directly in a smart contract. This is useful for integrators that want to future-proof implementations in case a Maker module is updated. You can \nread more about how to utilize the dss-chain-log here.\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nGlossary - \nPrevious\nSmart Contract Annotations\nNext\n - Security\nSecurity for the Maker Protocol\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/deployment-addresses/multi-collateral-dai-public-releases", "title": "Maker Protocol Deployments"}}
{"page_content": "Maker Protocol 101\nGetting Started with Maker Protocol\nFor a fully comprehensive overview of the smart contracts within the Maker Protocol, please download the Maker Protocol 101 Slide Deck (PDF) below or visit the view-only link \nhere\n.  \nMaker Protocol 101_20.12.08.pdf\n4MB\nPDF\nMaker Protocol 101 Deck\nPrevious\nMakerDAO Technical Docs\nNext\n - Smart Contract Modules\nDai Module\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/getting-started/maker-protocol-101", "title": "Maker Protocol 101"}}
{"page_content": "Auction Keepers\nIntroduction \nThe Maker Protocol, which powers Multi Collateral Dai (MCD), is a smart contract based system that backs and stabilizes the value of Dai through a dynamic combination of Vaults (formerly known as CDPs), autonomous feedback mechanisms, and incentivized external actors. To keep the system in a stable financial state, it is important to prevent both debt and surplus from building up beyond certain limits. This is where Auctions and Auction Keepers come in. The system has been designed so that there are three types of Auctions in the system: Surplus Auctions, Debt Auctions, and Collateral Auctions. Each auction is triggered as a result of specific circumstances.\nAuction Keepers are external actors that are incentivized by profit opportunities to contribute to decentralized systems. In the context of the Maker Protocol, these external agents are incentivized to automate certain operations around the Ethereum blockchain. This includes:\nSeeking out opportunities and starting new auctions\nDetect auctions started by other participants\nBid on auctions by converting token prices into bids\nMore specifically, Keepers participate as bidders in the Debt and Collateral Auctions when Vaults are liquidated and auction-keeper enables the automatic interaction with these MCD auctions. This process is automated by specifying bidding models that define the decision making process, such as what situations to bid in, how often to bid, how high to bid etc. Note that bidding models are created based on individually determined strategies.\nFor all interested in setting up their own Auction Keeper Bot, please visit the guide below. \nKeepers - \nPrevious\nThe Auctions of the Maker Protocol\nNext\nAuction Keeper Bot Setup Guide\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/auction-keepers", "title": "Auction Keepers"}}
{"page_content": "Cage Keeper\nA Keeper to facilitate Emergency Shutdown\nIntroduction\nThe \ncage-keeper\n is used to help facilitate \nEmergency Shutdown\n of the \nMaker Protocol\n. Emergency shutdown is an involved, deterministic process, requiring interaction from all user types: Vault owners, Dai holders, Redemption keepers, MKR governors, and other Maker Protocol Stakeholders. A high level overview is as follows:\n1.\nSystem Caged\n - The Emergency Security Module \n(ESM)\n calls \nEnd.cage()\n function, which freezes the USD price for each collateral type as well as many parts of the system.\n2.\nProcessing Period\n - Next, Vault owners interact with End to settle their Vault and withdraw excess collateral. Auctions are left to conclude or are yanked before Dai redemption.\n3.\nDai Redemption\n - After the processing period duration \nEnd.wait\n has elapsed, Vault settlement and all Dai generating processes (auctions) are assumed to have concluded. At this point, Dai holders can begin to claim a proportional amount of each collateral type at a fixed rate.\nTo prevent a race-condition for Dai holders during Step 3, it's imperative that any Vaults having a collateralization ratio of less than 100% at Step 1 must be processed during Step 2. The owner of an underwater Vault would not receive excess collateral, so they lack an incentive to \nskim\n their position in the \nEnd\n contract. Thus, it is the responsibility of a MakerDAO Stakeholder (MKR holders, large Dai holders, etc) to ensure the system facilitates a Dai redemption phase without a time variable. The \ncage-keeper\n is a tool to help stakeholders carry out this responsibility.\nPrerequisites\nThe following section assumes familiarity with Emergency Shutdown. Good places to start is the Emergency Shutdown Module in Section 3 and Section 4 of the \nMaker Protocol 101\n as well as a more thorough, \ntechnical description\n. Functions mentioned are from the implementation contained by the \nEnd\n contract, which is \nlocated here\n.\nTo be consistent with the Protocol's technical terminology for the rest of this description:\nurn\n = Vault\nilk\n = Collateral Type\nArchitecture\nThe \ncage-keeper\n directly interacts with the \nEnd\n, \nFlopper\n and \nFlapper\n contracts.\nThe central goal of the \ncage-keeper\n is to process all under-collateralized \nurns\n. This accounting step is performed within \nEnd.skim()\n, and since it is surrounded by other required/important steps in the Emergency Shutdown, a first iteration of this keeper will help to call most of the other public function calls within the \nEnd\n contract.\nAs can be seen in the above flowchart, the keeper checks if the system has been caged before attempting to \nskim\n all underwater urns and \nskip\n all flip auctions. After the processing period has been facilitated and the \nEnd.wait\n wait time has been reached, it will transition the system into the Dai redemption phase of Emergency Shutdown by calling \nEnd.thaw()\n and \nEnd.flow()\n. This first iteration of this keeper is naive, as it assumes it's the only keeper and attempts to account for all urns, ilks, and auctions. Because of this, it's important that the keeper's address has enough ETH to cover the gas costs involved with sending numerous transactions. Any transaction that attempts to call a function that's already been invoked by another Keeper/user would simply fail.\nOperation\nThis keeper can either run continuously on a local/virtual machine or be run when the operator becomes aware of Emergency Shutdown. A sample startup script is shown below. The keeper's Ethereum address should have enough ETH to cover gas costs and is a function of the protocol's state at the time of shutdown (i.e. more urns to \nskim\n means more required ETH to cover gas costs). When new collateral types are added to the protocol, the operator should pull the latest version of the keeper, which would include contracts associated with the aforementioned collateral types.\nAfter the \ncage-keeper\n facilitates the processing period, it can be turned off until \nEnd.wait\n is nearly reached. Then, at that point, the operator would pass in the \n--previous-cage\n argument during keeper start in order to bypass the feature that supports the processing period.\nInstallation\nThis project uses \nPython 3.6.2\n.\nIn order to clone the project and install required third-party packages please execute:\ngit clone https://github.com/makerdao/cage-keeper.git\ncd cage-keeper\ngit submodule update --init --recursive\n./install.sh\nFor some known Ubuntu and macOS issues see the \npymaker\n README.\nSample Startup Script\nMake a run-cage-keeper.sh to easily spin up the cage-keeper.\n#!/bin/bash\n/full/path/to/cage-keeper/bin/cage-keeper \\\n\t--rpc-host 'sample.ParityNode.com' \\\n\t--network 'kovan' \\\n\t--eth-from '0xABCAddress' \\\n\t--eth-key 'key_file=/full/path/to/keystoreFile.json,pass_file=/full/path/to/passphrase/file.txt' \\\n\t--vat-deployment-block 14374534\nTesting\nPrerequisites:\nDownload \ndocker and docker-compose\n\u0432\u0496\u04e2\nThis project uses \npytest\n for unit testing. Testing of Multi-collateral Dai is performed on a Dockerized local testchain included in \ntests\\config\n.\nIn order to be able to run tests, please install development dependencies first by executing:\npip3 install -r requirements-dev.txt\nYou can then run all tests with\n:\n./test.sh\nLicense\nSee \nCOPYING\n file\nSupport\nIf you have questions regarding Cage Keepers, please reach out to us on the \n#keeper\n channel on \nchat.makerdao.com\n.\nPrevious\nMarket Maker Keeper Bot Setup Guide\nNext\n - Keepers\nSimple Arbitrage Keeper\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/cage-keeper", "title": "Cage Keeper"}}
{"page_content": "Chief Keeper\nKeeper that lifts the hat and streamlines executive actions\nIntroduction \nThe \nchief-keeper\n monitors and interacts with \nDSChief\n and DSSSpells, which is the executive voting contract and a type of proposal object of the \nMaker Protocol\n.\nIts purpose is to lift the \nhat\n in DSChief as well as streamline executive actions.\nTo \nlift\n a spell, that spell must have more approvals than the current \nhat\n. The approvals of this spell can fluctuate and be surpassed by other spells, some of which could be malicious. This keeper \"guards\" the \nhat\n by ensuring the spell with the most approval is always the \nhat\n. The \nchief-keeper\n does this in order to maximize the barrier of entry (approval) to \nlift\n a spell to the hat, thus acting as a \"guard\" against malicious governance actions.\nWhile in operation, the \nchief-keeper\n:\nMonitors each new block for a change in the state of executive votes\nlift\ns the hat for the spell (\nyay\n) most favored (\napprovals[yay]\n)\nSchedules spells in the GSM by calling \nDSSSpell.schedule()\nExecutes spells after their \neta\n has elapsed in the GSM by calling \nDSSSpell.cast()\nReview\nThe following section assumes familiarity with the \nDSChief\n, DSSSpells, and \nDSPause\n (Governance Security Module), as well as the processes within \nMakerDAO Governance\n.\nArchitecture\nalt text\nchief-keeper\n interacts directly with the \nDS-Chief\n and \nDSSSpell\ns.\nOperation\nThis keeper is run continuously, and saves a local database of \nyays\n (spell addresses) and an \nyay:eta\n dictionary to reduce chain state reads. If you'd like to create your own database from scratch, first delete \nsrc/database/db_mainnet.json\n before running \nbin/chief-keeper\n; the initial query could take up to 15 minutes.\nInstallation\nPrerequisites:\n\u0432\u0496\u04e2\nPython v3.6.6\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nvirtualenv\n\u0432\u0496\u04e2\nThis project requires \nvirtualenv\n to be installed if you want to use Maker's python tools. This helps with making sure that you are running the right version of python and checks that all of the pip packages that are installed in the \ninstall.sh\n are in the right place and have the right versions.\nIn order to clone the project and install required third-party packages please execute:\ngit clone https://github.com/makerdao/chief-keeper.git\ncd chief-keeper\ngit submodule update --init --recursive\n./install.sh\nIf \ntinydb\n isn't visible/installed through \n./install.sh\n, simply run \npip3 install tinydb\n after the commands above.\nFor some known Ubuntu and macOS issues see the \npymaker\n README.\nSample Startup Script\nMake a run-chief-keeper.sh to easily spin up the chief-keeper.\n#!/bin/bash\n/full/path/to/chief-keeper/bin/chief-keeper \\\n\t--rpc-host 'sample.ParityNode.com' \\\n\t--network 'kovan' \\\n\t--eth-from '0xABCAddress' \\\n\t--eth-key 'key_file=/full/path/to/keystoreFile.json,pass_file=/full/path/to/passphrase/file.txt' \\\n\t--chief-deployment-block 14374534\nTesting\nDownload \ndocker and docker-compose\n\u0432\u0496\u04e2\nThis project uses \npytest\n for unit testing. Testing of Multi-collateral Dai is performed on a Dockerized local testchain included in \ntests\\config\n.\nIn order to be able to run tests, please install development dependencies first by executing:\npip3 install -r requirements-dev.txt\nYou can then run all tests with:\n./test.sh\nRoadmap\n \nDynamic gas pricing strategy\n\u0432\u0496\u04e2\nLicense\nSee \nCOPYING\n file.\nSupport\nIf you have questions regarding Cage Keepers, please reach out to us on the \n#keeper\n channel on \nchat.makerdao.com\n.\nKeepers - \nPrevious\nSimple Arbitrage Keeper\nNext\n - Command-line Interfaces\nSeth\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/chief-keeper", "title": "Chief Keeper"}}
{"page_content": "Market Maker Keepers\nIntroduction \nA big part of the Maker Protocol is the incentivization of external agents, called \nKeepers\n (which can be human but are typically automated bots). Market Maker Keepers work by creating a series of orders in so-called \nbands\n (defined later), which are configured with a JSON file containing parameters like spreads, maximum engagement, etc. In short, the \nmarket-maker-keeper\n repository is a set of Keepers that facilitate market making on exchanges. For example, trading Dai motivated by the expected long-term convergence toward the indicated \nTarget Price\n. This guide is dedicated to showing you how to create your very own Market Maker Keeper Bot as well as educate the community and help both users and developers understand the value of this incredible software. We are proud to say that all of the code needed to get a Market Maker Keeper bot up and running is open-sourced.\nVisit the guide below if you are interested in getting a Market Maker Keeper Bot Set up up and running!\nPrevious\nAuction Keeper Bot Setup Guide\nNext\nMarket Maker Keeper Bot Setup Guide\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/market-maker-keepers", "title": "Market Maker Keepers"}}
{"page_content": "Simple Arbitrage Keeper\nOverview\nTypically in the form of an automated bot, Keepers are external actors that participate in \nmarket making\n, \nauctions\n, \nmarket arbitrage\n, and system upkeep within the Maker protocol and the greater Ethereum ecosystem. Under a pure economic assumption, they are solely incentivized by profits or a vested interest. However, their activity provides indirect services such as increased liquidity and price consistency across various financial markets. This guide presents a simple arbitrage keeper, and structure thereof, that can be used out of the box to participate in wildly volatile markets. The purpose of the guide is to motivate the user in improving its functionality to participate in less volatile markets, leading to a more efficient financial ecosystem.\nLearning objectives\nBy reading this guide, you\u0432\u0496\u04b7ll gain:\nBetter understanding of Arbitrage, how it is achieved and the role it plays in financial markets\nAn overview of the simple arbitrage keeper and common structure across the Maker Keeper framework\nInsight into the operation of the simple arbitrage keeper and ways to improve its code\nPre-requisites\nAt least Python 3.6.2 and some python experience\nLinux, macOS, or Cygwin (on Windows)\nSome general experience with Ethereum Development (account management, contract interaction, node hosting)\nGuide\nIntroduction to Arbitrage\nArbitrage is the process of simultaneously purchasing an asset on one exchange and selling a similar, if not identical, asset on another exchange at a higher price. Conceptually, this trading strategy can be broken down into two legs, the first buying leg and the second selling leg. As the timestamp of these legs converge, the risk of asset exposure approaches zero. For example, if both trades are not executed in perfect synchrony, there is a chance that the second trade is completed by another actor, forcing the arbitrageur to hold an asset until another opportunity arises.\nWith advancement in technology, this trading strategy is typically automated and can detect, as well as, profit from price deviations in a matter or seconds. Arbitrage opportunities exist because of \nmarket inefficiencies\n, such as a temporary shortage of liquidity. As a result, arbitrage provides a mechanism to ensure prices on one exchange/market do not deviate far from the \nfair value\n. \n1\n\u0432\u0496\u04e2\nSystem Process Structure\nOperation of the Simple Arbitrage Keeper\nThe \nsimple-arbitrage-keeper\n is an arbitrage keeper for OasisDex and Uniswap. Given a minimum profit per trade and maximum trade size, as defined by the user and in units of \nentry_token\n, the Keeper will scan for arbitrage opportunities. When running, it monitors the \narb_token/entry_token\n price on both exchanges, and when a discrepancy is detected, it executes an atomic multi-step trade in a single Ethereum transaction. The multi-step trade is made up of two legs: the first leg is the purchasing of \narb_token\n with the \nentry_token\n on the \nstart_exchange\n, while the second leg is the selling of the \narb_token\n with the \nentry_token\n on the \nend_exchange\n. The type of \nentry_token\n and \narb_token\n is typically of a stable and volatile type, respectively; since arbitrage opportunities can be scarce, the Keeper sometimes rests in a default state, holding the \nentry_token\n for extended periods of time as it looks for new opportunities. Exposure only to a stable token is especially important in this default state. If any leg of the trade fails, the entire trade reverts, thereby upholding the \"risk-free\" attribute of true arbitrage.\nIt inherits a system structure that is consistent with other keepers in the Maker Keeper Framework. Apart from libraries typical to python projects, it relies on \npymaker\n and \npyexchange\n, both of which are highly applicable Python APIs for the Maker Protocol Contracts and cryptocurrency exchanges, respectively. As can be seen in the flowchart, the \u0432\u0496\u04b3Lifecycle box\u0432\u0496\u04b7 is a \npymaker utility class\n that helps define the proper life cycle of a keeper; it consists of keeper startup, timers and/or subscriptions to Web3 events, and a keeper shutdown phase. The \u0432\u0496\u04b3Process block\u0432\u0496\u04b7 box is executed when the Keeper's node receives a new block. It generally contains the logic to query the blockchain state, evaluate any profit opportunities, and when applicable, publish a transaction.\nThe step for each process in simple-arbitrage-keeper is as follows:\n1.\nKeeper Entry -> enter into SimpleArbitrageKeeper class\n2.\nStartup -> make all necessary approvals between tokens, exchanges, and tx-manager\n3.\nEvaluate Market -> pull price data from Oasis REST API and Uniswap exchange contracts\n4.\nProfitable Opportunity Found? ->check if profit opportunity exists with a given max engagement and min profit\n5.\nExecute multi-step trade -> with use of TxManager, buy asset on exchange A and sell on exchange B within one Ethereum transaction\nDocumentation\nGeneral high level information and comments for each class/method are in the \nsimple-arbitrage-keeper github repository\n.\nStartup on Kovan\nThe usage of the bot can be found in the \nUsage section\n of the README. Here are some preparation steps in running on Kovan:\nTo operate the keeper, call the \n/bin/simple-arbitrage-keeper\n script with the required arguments. This adds the pyexchange and pymaker modules to the python path and initializes the SimpleArbitrageKeeper class. It's convenient to write a shell script that can be easily rerun after argument changes, but before we begin, let's prepare our Keeper ethereum address, deploy our TxManager, find the Uniswap exchange addresses and MatchingMarket address.\nKeeper Installation\nThis project uses Python 3.6.2. In order to clone the project and install required third-party packages please execute:\n$ git clone https://github.com/makerdao/simple-arbitrage-keeper.git\n$ cd simple-arbitrage-keeper\n$ git submodule update --init --recursive\n$ pip3 install -r requirements.txt\nFor some known Ubuntu and macOS issues see the \npymaker README\n.\nInstall the DappHub Toolkit\nIf you are running Linux or macOS you can take advantage of our all in one installer.\n$ curl https://dapp.tools/install | sh\nIf you're having issues with installation, head over to the \n'Manual Installation' section\n\u0432\u0496\u04e2\nKeeper Ethereum Address\nYour Keeper will publish transactions through this address. Your ethereum address needs to be accessible by \nseth\n, in order to deploy TxManager through \ndapp.tools\n. Furthermore, when the Keeper is deployed and in operation, this address must contain some ETH for transaction costs as well as an amount of entry-tokens equal to the max-engagement set by the User. Follow \nthese instructions\n to ensure seth can see your keystore and passphrase files.\nIf you'd like to start from scratch, \ninstall geth\n and use \ngeth account new\n, to create a new account, set a passphrase, and place the passphrase into a \n<address>.txt\n file in the \n~/Library/Ethereum/passphrase/\n directory; the corresponding keystore file can be found in the \n~/Library/Ethereum/keystore/\n directory. Both the keystore and passphrase files will later be passed into the Keeper as an argument. Make a note of your Keeper Ethereum Address, its keystore file location and passphrase file location.\nDeploy TxManager\nA \nTxManager\n must be deployed and linked with the Keeper ethereum address in order to bundle multiple contract calls in a single ethereum transaction; this is what we call an atomic transaction, where the entire call set is successful, or the state remains unaffected. Once the DappHub Toolkit is installed, execute the following commands to deploy TxManager:\n$ git clone https://github.com/makerdao/tx-manager.git\n$ cd tx-manager\n$ dapp update\n$ dapp --use solc:0.4.25 build --extract\n\u0432\u0496\u04e2\n$ export SETH_CHAIN=kovan\n$ export ETH_FROM=<your Keeper Ethereum Address e.g. 0xABC>\n$ export ETH_GAS=2000000\n$ dapp create TxManager --password /path/to/passphraseOfAddress.txt\n\u0432\u0496\u04e2\nThe output of \ndapp create\n is the address to your TxManager\nDeploy/Find a parity node\nYou need access to a JSON-RPC host that\u0432\u0496\u04b7s connected to a parity node. Unfortunately, Infura APIs are not connected to parity nodes, so you will need to find access to a remote endpoint (one example is \nhttps://rivet.cloud/\n) or run a node on your local machine. An example of a remote node could be \nhttps://kovan.sampleparitynode.com:8545\n\u0432\u0496\u04e2\nUniswap Exchange Addresses\nYou'll need to find the address to the Uniswap exchange corresponding to the entry-token as well as arb-token. To do that, call the \ngetExchange(TokenAddress)\n at the Uniswap Factory contract to query the exchange addresses. \nYou can do that here\n. For example, you can use the Kovan WETH token address and call \ngetExchange(0xd0A1E359811322d97991E03f863a0C30C2cF029C)\nShell Script\nAs was mentioned before, let's make a shell script so that it's easy to run this Bot. For example, we're using \nKovan Sai\n for the entry-token since we won't be exposed to the arb token's price exposure in between trades. Moreover, for kovan testing, we will be using the WETH/DAI pair, since liquidity is thin across the Kovan versions of MatchingMarket and Uniswap exchanges. Any \nNoneType\n errors are likely due to a lack of liquidity on either exchange and can be resolved once liquidity is added. As mentioned earlier, the min-profit and max-engagement arguments define how the keeper will operate. Maximum engagement refers to the amount of entry-tokens you would like to sell within the first leg of the trade, whereas minimum profit refers to the amount of profit gained from executing the arbitrage; both arguments are denominated in entry-tokens and in \nunits of ether\n (in the below script, 1 SAI of min-profit would be 1 SAI). For example, the below script will trade with a max-engagement of 10 SAI, but only if the returned value from the trade results in at least 11 SAI.\nCreate a file called like below, insert the arguments relevant to your environment, make it executable, then run it!\n$ vim run-simple-keeper-kovan.sh\nIn your run-simple-keeper-kovan.sh file:\n#!/bin/bash\n/full/path/to/githubClone/simple-arbitrage-keeper/bin/simple-arbitrage-keeper \\\n\t--rpc-host 'kovan.sampleparitynode.com' \\\n\t--eth-from '0xABC' \\\n\t--eth-key 'key_file=/path/to/keystore.file,pass_file=/path/to/passphrase.txt' \\\n\t--uniswap-entry-exchange '0x47D4Af3BBaEC0dE4dba5F44ae8Ed2761977D32d6' \\\n\t--uniswap-arb-exchange '0x1D79BcC198281C5F9B52bf24F671437BaDd3a688' \\\n\t--oasis-address '0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F' \\\n\t--oasis-api-endpoint 'https://kovan-api.oasisdex.com' \\\n\t--tx-manager '0xABC' \\\n\t--entry-token '0xC4375B7De8af5a38a93548eb8453a498222C4fF2' \\\n\t--arb-token '0xd0A1E359811322d97991E03f863a0C30C2cF029C' \\\n\t--arb-token-name 'WETH' \\\n\t--min-profit 1 \\\n\t--max-engagement 10 \\\nMake your Keeper executable, and run it!\n$ chmod +x run-simple-keeper-kovan.sh\n$ ./run-simple-keeper-kovan.sh\n\u0432\u0496\u04e2\nInitial Startup\nDuring the initial startup, several approval transactions will be sent to the tx-manager, and relevant exchanges. When complete, you'll see a \u0432\u0496\u04a3Watching for new blocks\u0432\u0496\u049b message that indicates that the bot is now looping through the \nlifecycle.process_block()\n method; following that message and with every new block is a \"Best Trade regardless of profit\" message that acts as a \"heartbeat\" to the Keeper.\nKentons-Macbook:scripts kentonprescott$ ./run-simple-arbitrage-keeper-mainnet-XYZ-XYZ.sh\n2019-10-19 17:21:57,463 INFO     Keeper connected to RPC connection https://...\n2019-10-19 17:21:57,463 INFO     Keeper operating as 0xABCD\n2019-10-19 17:21:58,523 INFO     Executing keeper startup logic\n2019-10-19 17:22:04,820 INFO     Watching for new blocks\n2019-10-19 17:22:13,983 INFO     Best trade regardless of profit/min-profit: -1.243077085275947008 DAI from Uniswap to Oasis\nNominal Operation\nAfter the initial approval phase the Keeper's startup will look something like the below output and will continue to print \"Best Trade ... \" messages with every new block witnessed. When the keeper publishes a transaction, all relevant info will be logged and printed to the console. Finally, when you\u0432\u0496\u04b7d like to shut down the keeper, simply click CTRL-C, and it will gracefully shutdown.\n\n\nTroubleshooting\nDuring keeper operation, if the following error is shown, just CTRL-C and rerun:\nValueError: {'code': -32010, 'message': 'Transaction with the same hash was already imported.'}\nNext steps\nImprovements\nHere are some suggestions to improve the usability, versatility, and profitability of this keeper. We hope that everyone tinkers with the parameters, runs the keeper for their own benefit, and eventually upgrades the bot to meet their risk tolerance and profit appetite.\nDevelop unit tests for each method\nUse the Uniswap Factory contract to query the \nuniswap-entry-exchange\n and \nuniswap-arb-exchange\n addresses rather than requiring it as an argument\nRather than the default gas price implement a \ndynamic gas price strategy\n\u0432\u0496\u04e2\nIncrease scope\nMonitor more than one pair\nMonitor more than two decentralized exchanges\nImplement support for centralized exchanges\nIncrease number of intermediary arb tokens\n(e.x. DAI \u0432\u04b6\u2019 WETH \u0432\u04b6\u2019 BAT \u0432\u04b6\u2019 DAI)\n\u0432\u0496\u04e2\nhttps://math.stackexchange.com/a/94420\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nhttps://www.dailycodingproblem.com/blog/how-to-find-arbitrage-opportunities-in-python/\n\u0432\u0496\u04e2\nImprove efficiency of TxManager\nDo we really need to send all of our token balance to the contract during every atomic transaction?\nRead the state of the MatchingMarket (OasisDex) contract rather than using the Oasis REST API\nTo save gas, \nget all active orders\n and \ntake specific orders\n by ID rather than use \nMatchingMarket.offer(...)\n and the on-chain matching engine\nSend trade updates through a text/email Python API\nResources\n\u0432\u0496\u04e2\nhttps://github.com/makerdao/market-maker-keeper\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nhttps://github.com/makerdao/arbitrage-keeper\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nhttps://github.com/makerdao/tx-manager\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nhttps://github.com/makerdao/pymaker\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nhttps://github.com/makerdao/pyexchange\n\u0432\u0496\u04e2\nKeepers - \nPrevious\nCage Keeper\nNext\n - Keepers\nChief Keeper\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/simple-arbitrage-keeper", "title": "Simple Arbitrage Keeper"}}
{"page_content": "The Auctions of the Maker Protocol\nIntroduction \nThe Multi-Collateral Dai (MCD) system within the MakerDAO Protocol is a smart contract platform on Ethereum that backs and stabilizes the value of our stablecoin, Dai. It does this through a dynamic system of Vaults, autonomous feedback mechanisms, and appropriately incentivized external actors.\nIn this document, we explain the auction mechanisms within the system, as well as particular types of external actors, called Keepers, that bid on the Auctions.\nAuctions\nWhen everything in the system is going well, Dai accrues through \nstability fees\n collected from Vaults. Whenever the net surplus from stability fees reaches a certain limit, that surplus in Dai is auctioned off to external actors for MKR which subsequently is burnt, thereby reducing the amount of MKR in circulation. This is done through a \nSurplus Auction\n.\nThe system protects against debt creation by overcollateralization. Under ideal circumstances and with the right risk parameters, the debt for an individual Vault can be covered by the collateral deposited in that Vault. If the price of that collateral drops to the point where a Vault no longer sustains the required collateralization ratio, then the system automatically liquidates the Vault and sells off the collateral until the outstanding debt in the Vault (and a liquidation penalty), is covered. This is done through a \nCollateral Auction\n.\nFurther, if, for example, the collateral price drops sharply or no one wants to buy the collateral, there may be debt in the liquidated Vault that cannot be repaid through a collateral auction and must be addressed by the system. The first course of action is to cover this debt using surplus from stability fees, if there is any surplus to cover it. If there is not, then the system initiates a \nDebt Auction\n, whereby the winning bidder pays Dai to cover the outstanding debt and in return receives an amount of newly minted MKR, increasing the amount of MKR in circulation.\nTo \nsummarize\n, we have three types of Auctions:\nSurplus Auction\n: The winning bidder pays MKR for surplus Dai from stability fees. The MKR received is burnt, thereby reducing the amount of MKR in circulation.\nCollateral Auction\n: The winning bidder pays Dai for collateral from a liquidated Vault. The Dai received is used to cover the outstanding debt in the liquidated Vault\nDebt Auction\n: The winning bidder pays Dai for MKR to cover outstanding debt that Collateral Auctions haven\u0432\u0496\u04b7t been able to cover. MKR is minted by the system, thereby increasing the amount of MKR in circulation.\nThe actors that bid on these Auctions are called \nKeepers\n.\nKeepers\nWith all information published on the Ethereum blockchain, anyone can access or monitor price feeds and data on individual Vaults, thereby determining whether certain Vaults are in breach of the Liquidation Ratio. The system incentivizes these market participants (which can be human or automated bot), known as \u0432\u0496\u04a3keepers,\u0432\u0496\u049b to monitor the MCD System and trigger liquidation when the Liquidation Ratio is breached.\nIn the context of Multi-Collateral Dai, Keepers may participate in auctions as a result of liquidation events and thereby acquire collateral at attractive prices. Keepers can also perform other functions, including trading Dai motivated by the expected long-term convergence toward the Target Price.\nWe will now go into more detail about how the \nAuctions\n work.\nThe Auction Parameters and Mechanisms\nVarious considerations were taken into account when designing the auction mechanisms. For example, from a systems point of view, it\u0432\u0496\u04b7s best to complete the auction as soon as possible to keep the system in a steady state, so the auction mechanism incentivizes early bidders. Another consideration is that the Auctions are executed on-chain, minimizing the number of required transactions and reducing associated fees.\nAuctions Glossary\nRisk parameters\n. In general, the following parameters are used across all of the auction types:\nbeg\n: Minimum bid increase (for example, 3%).\nttl\n: Bid duration (for example, 6 hours). The auction ends if no new bid is placed during this time.\ntau\n: Auction duration (for example, 24 hours). The auction ends after this period under all circumstances.\nThe values of the risk parameters are determined by Maker Governance voters (MKR holders) per auction type. Note that there are different Collateral Auction risk parameters for each type of collateral used in the system.\nAuction and bid information\n. The following information is always available during an active auction:\nlot\n : Amount of asset that is up for auction/sale.\nbid\n: Current highest bid.\nguy\n: Highest bidder.\ntic\n: Bid expiry date/time (empty if zero bids).\nend\n: Auction expiry date/time.\nBid Increments During an Auction\nDuring an auction, bid amounts will increase by a percentage with each new bid. This is the \nbeg\n at work. For example, the \nbeg\n could be set to 3%, meaning if the current bidder has placed a bid of 100 Dai, then the next bid must be at least 103 Dai. Overall, the purpose of the bid increment system is to incentivize early bidding and make the auction process move quickly.\nHow Bids are Placed During an Auction\nBidders send DAI or MKR tokens from their addresses to the system/specific auction. If one bid is beat by another, the losing bid is refunded back to that bidder\u0432\u0496\u04b7s address. It\u0432\u0496\u04b7s important to note, however, that once a bid is submitted, there is no way to cancel it. The only possible way to have that bid returned is if it is outbid.\nNow, let\u0432\u0496\u04b7s review the mechanisms of the three different auction types.\nSurplus Auction\nSummary\n: A Surplus Auction is used to auction off a fixed amount of surplus Dai in the system in exchange for MKR. This surplus Dai will generally come from accumulated stability fees. In this auction, bidders compete with increasing bids of MKR. Once the auction has ended, the auctioned Dai is sent to the winning bidder, and the system burns the MKR received from the winning bidder.\nHigh-level Mechanism Process\n:\nMaker Governance voters determine the amount of surplus allowed in the system at any one time. A Surplus auction is triggered when the system has a Dai surplus over the pre-determined amount as set by MKR governance.\nTo determine whether the system has a net surplus, accrued stability fees and debt in the system must be added together. Any user can do this by sending the \nheal\n transaction to the system contract called Vow.\nProvided there is a net surplus, the Surplus Auction is triggered when any user sends the \nflap\n transaction to the Vow contract.\nWhen the auction begins, a fixed amount (\nlot\n) of Dai is put up for sale. Bidders then bid with MKR in increments greater than the minimum bid increase amount. The auction officially ends when the bid duration ends (\nttl\n) without another bid OR when the auction duration (\ntau\n) has been reached. Once the auction ends, the MKR received for the surplus Dai is then sent to be burnt, thereby contracting the system\u0432\u0496\u04b7s MKR supply.\nCollateral Auction (Collateral Sale)\nSummary\n: Collateral Auctions serve as a means to recover debt in liquidated Vaults. Those Vaults are being liquidated because the value of the Vault collateral has fallen below a certain limit determined by the Maker Governance voters.\nHigh-level Mechanism Process\n:\nFor each type of collateral, MKR holders approve a specific risk parameter called the liquidation ratio. This ratio determines the amount of overcollaterization a Vault requires to avoid liquidation. For example, if the liquidation ratio is 150%, then the value of the collateral must always be one and a half times the value of the Dai generated. If the value of the collateral falls below the liquidation ratio, then the Vault becomes unsafe and is liquidated by the system. The system then takes over the collateral and auctions it off to cover both the debt in the Vault and an applied liquidation penalty.\nThe Collateral Auction is triggered when a Vault is liquidated.\nAny user can liquidate a Vault that is unsafe by sending the bite transaction identifying the Vault. This will launch a collateral auction.\nIf the amount of collateral in the Vault being \u0432\u0496\u04a3bitten\u0432\u0496\u049b is less than the lot size for the auction, then there will be one auction for all collateral in the Vault.\nIf the amount of collateral in the Vault being \u0432\u0496\u04a3bitten\u0432\u0496\u049b is larger than the lot size for the auction, then an auction will launch with the full lot size of collateral, and the Vault can be \u0432\u0496\u04a3bitten\u0432\u0496\u049b again to launch another auction until all collateral in the Vault is up for bidding in Collateral Auctions.\nAn important aspect of a Collateral Auction is that the auction expiration and bid expiration parameters are dependent on the specific type of collateral, where more liquid collateral types have shorter expiration times and vice-versa.\nOnce the auction begins, the first bidder can bid any amount of Dai to aquire the collateral amount (\nlot\n). Other bidders can raise that bid offering more Dai for the same collateral amount (\nlot\n) until there is a bid that covers the outstanding debt. If and when there is a bid that covers the outstanding debt, the auction will turn into a reverse auction, where a bidder bids on accepting smaller parts of the collateral for the fixed amount of Dai that covers the outstanding debt. The auction ends when the bid duration (\nttl\n) has passed OR when the auction duration (\ntau\n) has been reached. Again, this process is designed to encourage early bidding. Once the auction is over, the system sends the collateral to the winning bidder\u0432\u0496\u04b7s address.\nDebt Auction\nSummary\n: Debt Auctions are used to recapitalize the system by auctioning off MKR for a fixed amount of Dai. In this process, bidders compete with their willingness to accept decreasing amounts of MKR for the fixed Dai they will have to pay.\nHigh-level Mechanism Process\n:\nDebt Auctions are triggered when the system has Dai debt that has passed the specified debt limit.\nMaker Governance voters determine the debt limit. The Debt auction is triggered when the system has a debt in Dai below that limit.\nIn order to determine whether the system has a net debt, the accrued stability fees and debt in the system must be added together. Any user can do this by sending the \nheal\n transaction to the system contract named Vow.\nProvided there is a sufficiently sized net debt, the debt auction is triggered when any user sends the \nflop\n transaction to the Vow contract\nThis is a reverse auction, where Keepers bid on how little MKR they are willing to accept for the fixed Dai amount (\nlot\n) they have to pay at auction settlement. The auction ends when the bid duration (\nttl\n) has passed OR when the auction duration (\ntau\n) has been reached. Once the auction is over, the Dai, paid into the system by bidders in exchange for newly minted MKR, reduces the original debt balance in the system.\nTo participate as a Keeper in MCD, please visit thee Auction Keeper Bot Setup Guide \nhere\n. \nBuilding on top of the Maker Protocol - \nPrevious\nPymaker\nNext\n - Keepers\nAuction Keepers\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/the-auctions-of-the-maker-protocol", "title": "The Auctions of the Maker Protocol"}}
{"page_content": "Liquidations 1.2 System (Deprecated)\nHere are the articles in this section:\nCat - Detailed Documentation\nFlipper - Detailed Documentation\nCommand-line Interfaces - \nPrevious\nEmergency Shutdown (ES) CLI\nNext\nCat - Detailed Documentation\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/miscellaneous/liquidations-1.2-system-deprecated", "title": "Liquidations 1.2 System (Deprecated)"}}
{"page_content": "SCD <> MCD Migration\nThe Maker Protocol Upgrade Contract\nContract Name:\n scd-mcd-migration.sol\nType/Category:\n  Migration\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe Migration contract's purpose is to allow moving SAI and CDPs from the SCD system to the MCD system, thus becoming DAI and Vaults. It also allows users to move SAI/DAI in both directions should they want to exit MCD and go back to SCD.\n\u0432\u0496\u04e2\n2. Contract Details\nKey Functionalities\nswapSaiToDai\n - Takes Sai (ERC-20 DAI from Single Collateral System) returns DAI (ERC-20 DAI from MultiCollateral System).\nswapDaiToSai\n - Takes DAI (ERC-20 DAI from MultiCollateral System) returns Sai (ERC-20 DAI from Single Collateral System)\nmigrate\n - Moves a Vault from SCD to MCD by closing the SCD one and opening a corresponding MCD one.\nStorage\ntub\n: SCD Tub contract address\nvat\n: MCD Vat Contract address\ncdpManager\n: MCD CDP manager\nsaiJoin\n: SAI collateral adapter for MCD\nwethJoin\n: WETH collateral adapter for MCD\ndaiJoin\n: DAI join adapter for MCD\n3. Key Mechanisms & Concepts\nOverall this contract has two primary purposes:\n1.\nTwo-way exchange for SAI and DAI\n2.\nOne-way transfer of Vaults\n1. \nconstructor\n (setup)\n2. \nswapSaiToDai\nUsers of the current DAI system will want to move to the new MCD system. This function allows DAI holders to seamlessly convert their DAI. They will need to \napprove\n the migration contract on the SAI ERC-20 contract so that it can perform the \ntransferFrom\n. The migration contract holds a Vault in MCD that takes SAI as collateral and allows it to exit MCD-DAI, which it does and returns to the \nmsg.sender\n.\n3. \nswapDaiToSai\nIn case a user wants to go back to SAI, this function allows them to turn in their DAI in exchange for SAI. This requires the user \napprove\ns the migration contract on the DAI ERC-20 contract so that it can \ntransferFrom\n then \njoin\n the DAI back into MCD. This pays back the \"debt\" in its SAI-MCD Vault and allows it to retrieve the SAI \"collateral\" and return it to the \nmsg.sender\n.\n4. \nmigrate\nThis function is meant to be used in combination with the \nMigrationProxyActions\n as it requires the migration contract owns the SCD-Vault (\ncup\n) already and that the migration contract has enough MKR to pay the stability fees. The \nMigrationProxyActions\n \nmigrate\n function \ntransferFrom\ns the \nmsg.sender\n to the migration contract so that the migration contract has enough MKR to pay the stability fee and close the \ncup\n.\nThe migration contract first draws its own SAI out of its MCD contract and uses that to pay back the debt for the \ncup\n (along with the MKR it has from the proxy action to pay the fee). Then it withdraws the PETH as WETH.\nNext the migration contract opens a Vault using the MCD CDP manager and \njoin\ns its WETH into its new Vault and withdraws enough DAI from the new Vault (and pays back its Vault) to compensate for the SAI it drew earlier in this step.\nLastly, the migration contract gives the MCD-Vault to the \nmsg.sender\n.\n4. Gotchas (Potential source of user error)\nAny special/unique information about the specific contract\nAnything that it may rely on, especially if it is not obvious\nSources of user error if not explicitly defined\nswapSaiToDai\nThe \nwad\n amount has to be below the debt ceiling for both the overall MCD system and the SAI collateral type, otherwise the \nfrob\n will fail. This means that these governance parameters can impact the speed of the transition from SAI to DAI.\nswapDaiToSai\nThe \nwad\n amount has to be below the amount of SAI collateral in the migration contract's Vault. If a user with DAI wants to move to SAI but no SAI users have already moved to DAI, then this will fail.\nmigrate\nBecause the migration contract will have to first draw SAI from its MCD collateral, the system will have to be seeded with SAI in the migration contract's Vault in an amount that exceeds the SAI debt for the \ncup\n being migrated.\nIf a user holds both a \ncup\n and SAI, they should decide whether it makes sense to:\n1.\nPay back the \ncup\n in SCD, then \nmigrate\n their \ncup\n to MCD (essentially just transfer the collateral to a new MCD Vault).\n2.\nmigrate\n their \ncup\n with the debt in place, then use \nswapSaiToDai\n to get DAI which they can then use as an ERC-20 or payback their MCD debt.\nOne additional consideration, to close or migrate a \ncup\n, a user will have to purchase MKR in order to pay the stability fee and be able to \nexit\n the SCD system. However, once in MCD, new fees will be accrued (and have to be paid) in DAI. If a user's converted SAI does not cover their MCD debt + stability fee, they may have to purchase DAI on the open market.\nBefore SCD shutdown: Users who took out a Vault in SCD and then used the DAI to purchase something will either have to buy SAI on the open market to pay back their SCD debt or they will have to migrate their collateral to MCD.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nPotential for error:\n Governance parameters around SAI collateral\nCollateralization ratio has to be set to a very low number\nBoth \nilks[\"sai\"].duty\n and \nJug.base\n have to be set to \n0\n during the migration period\nAuth errors on Sai Join\nExcess Sai in MCD (i.e. more \ncup\ns are lost/not migrated than lost/not migrated Sai): results in an auction and possibly MKR auction to cover bad debt.\nMigration\nSai debt ceiling to 0\nMCD.ilks[sai] debt ceiling to SCD.totalDai\nDSR value competitive with Compound to encourage migration\nPrevious\nFlipper - Detailed Documentation\nNext\n - Miscellaneous\nUpgrading to Multi-Collateral Dai Guide\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/miscellaneous/scd-mcd-migration-detailed-documentation", "title": "SCD <> MCD Migration"}}
{"page_content": "Upgrading to Multi-Collateral Dai Guide\nSummary \nLevel:\n Intermediate\nEstimated Time: \n30 minutes\nAudience:\n Technical and commercial teams with partners and Dai holders\nIntroduction\nThe upcoming version of the Maker system, Multi-Collateral Dai, brings a lot of new and exciting features, such as support for new Vault collateral types and Dai Savings Rate. In order to support the new functionality, the whole Maker core of smart contracts has been rewritten. The new smart contracts addresses and ABIs can be found here: \nhttps://changelog.makerdao.com/releases/mainnet/1.0.0/\n\u0432\u0496\u04e2\nTherefore, users and partners interacting with Single-Collateral Dai (SCD) must migrate their existing Single Collateral Dai tokens (Sai) to Multi Collateral Dai tokens (Dai) and CDPs to the new system. Additionally, companies or projects integrated with Sai and CDPs must update their codebases to point to the new smart contracts, and refactor their code to support the updated functions.\nThis guide will focus on the Dai and CDP migration with a high level overview of the upgrade process for different actors in the Maker ecosystem.\nThe steps necessary to migrate from Single-Collateral Dai (SCD) to Multi-Collateral Dai (MCD) differ depending on your platform and use case for Dai, so the guide is split into sections for different user and partner types.\nImportant note on naming conventions\nIn this guide we refer to the Single Collateral Dai system as \nSCD\n, and the Multi-Collateral Dai system as \nMCD\n. We refer to the Single Collateral Dai token (the old, currently existing Dai) as \nSai\n, and the new Multi-Collateral Dai token as \nDai\n.\nLearning Objective\nKnowledge on how migration to MCD will work\nBest practices for migration for different users and partners\nWhere to find guides on specific migration scenarios\nPre-requisites\nBasic knowledge of the MakerDAO: Dai and/or Vault system. \nSee the MCD 101 guide, especially sections 1 and 2.\n\u0432\u0496\u04e2\nSections\n\u0432\u0496\u04e2\nUser and Partner Migration Scenarios\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Sai Holder\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a SCD CDP Owner\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Centralized Exchange or Custodial Wallet\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Decentralized Exchange\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Non-Custodial Wallet\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Keeper\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Market Maker\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a CDP Integrator\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Lending Protocol\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs a Dapp\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAs another partner type not mentioned above\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nMigration App\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nMigration Contract\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFunctionality\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nUpgrading Sai to Dai\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nSwapping Dai for Sai\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nMigrating CDPs\n\u0432\u0496\u04e2\nUser and Partner Migration Scenarios\nThe following section will outline a recommended migration process for different actors in the Maker ecosystem.\nAs a Sai Holder\nYou control your private key\nIf you hold your Sai in a wallet where you control your private keys, then head to \nmigrate.makerdao.com\n (available at MCD launch) and follow the instructions to upgrade your Sai to Dai and optionally activate the Dai Savings Rate smart contract, which allows you to earn savings.\nThe following figure outlines the migration flow:\nYou don\u0432\u0496\u04b7t control your private key\nIf your Sai is deposited in an exchange or centralized wallet or locked in a dApp smart contract, you can follow the instructions these platforms are providing or withdraw the Sai and complete the upgrade yourself at \nmigrate.makerdao.com\n\u0432\u0496\u04e2\nWith MCD you can deposit your Dai into the Dai Savings Rate smart contract which will earn you accrued annual savings. Find more info at makerdao.com at launch.\nAs a SCD CDP Owner\nAs a SCD CDP owner you can move your CDP to the MCD CDP core through the Migration App at \nmigrate.makerdao.com\n at launch. The following diagram shows the flow for CDP migration.\nYou can also choose to manually close your CDP by paying back your debt and redeeming your Ether, and use your redeemed collateral to open a new MCD CDP.\nIf you have a large SCD CDP, the migration contract might not have enough Sai liquidity to carry out the migration. In that case, feel free to contact \n[email\u00a0protected]\n for assistance. You can read more about migration in the \nMigration Contract\n section later in this guide.\nNotes on Instadapp\nIf you have created your CDP through the Instadapp service, you need to withdraw ownership of the CDP from the service back to you. To do this, you need to navigate to the \nexit page\n and click \u0432\u0496\u04a3Withdraw\u0432\u0496\u049b on your CDP in the tab \u0432\u0496\u04a3Debt Positions\u0432\u0496\u049b. This will give you custody of the CDP, which will make it visible at \nmigrate.makerdao.com\n where you will be able to carry out CDP migration.\nNotes on MyEtherWallet\nIf you have created your CDP on MyEtherWallet then you can migrate your CDP using the Migration App at \nmigrate.makerdao.com\n. (However, if the private key used with MyEtherWallet is stored in a local file or another unsupported format, you must first import your key to a wallet with Web3 support.)\nOnce upgraded, you can start using Dai Savings Rate by locking your Dai into the Dai Savings Rate smart contract and receive accrued savings. Find more info on makerdao.com at launch.\nAs a Centralized Exchange or Custodial Wallet\nWe recommend you take the following steps for upgrading to MCD:\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b. This is being coordinated with all Maker partners and serves to avoid users depositing the wrong token into your system.\nOn December 2: Perform upgrade of user balances.\nInform your users as soon as possible about the dates. For users wanting to delay their upgrade, this allows them to opt-out by withdrawing Sai from your exchange before the date.\nProposed process for the December 2 upgrade:\nFreeze Sai deposits/withdrawals\nUse the Migration App/contract to upgrade all user holdings of Sai to Dai. (See more details in the \nMigration App\n/\ncontract\n sections below.)\nPoint codebase to new Dai token contract address. The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token.\nRename listing/token to \"Dai\"\nUnfreeze Dai deposits/withdrawals.\nInform users about \nDai Savings Rate\n, which allows Dai holders to earn savings.\nOptional: Choose one of the following:\nIntegrate Dai Savings Rate and distribute revenue to your users.\nIntegrate Dai Savings Rate in your exchange and keep accrued savings in your own balance sheet.\nThis approach will result in the following user journey for the exchange/wallet user:\nAs a Decentralized Exchange\nWe recommend you take the following steps for upgrading to MCD:\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b and ticker \"SAI\". This is being coordinated with all Maker partners and serves to avoid users attempting to deposit the wrong token into your system.\nSelect a date between November 18-25 to list Multi-Collateral Dai. The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token. Logo for Sai should remain the yellow diamond.\nOn the date of your own Dai listing: Add support for the new Dai token on your platform. The new Dai token should be named Dai and have the ticker \"DAI\". Deactivate Sai trading in your frontend UI, but allow users to cancel orders and withdraw balances.\nInform users that they can redeem Sai for Dai at migrate.makerdao.com\nOptional: Provide a UI in your own interface for token migration through the migration contract.\nInform users about Dai Savings Rate, which allows Dai holders to earn savings.\nOptional: Build a UI that facilitates the usage of the Dai Savings Rate service for your users in your exchange, where users will keep the accrued savings themselves.\nOptional: Link users to \noasis.app\n to activate Dai Savings Rate.\nAs a Non-Custodial Wallet\nIf you are a creator of a wallet that allows users to be in control of their private keys we recommend you do the following:\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to support Multi-Collateral Dai, which should be listed as \"Dai\". The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token. Logo for Sai should remain the yellow diamond.\nInform your users as soon as possible about the timeline for your own upgrade to MCD.\nSupport balances of both Sai and Dai for a period until Sai demand diminishes.\nInform your users that they will be able to swap Sai for Dai at \nmigrate.makerdao.com\n.\nOptional: Provide a UI in your own interface for token migration through the migration contract.\nInform users about Dai Savings Rate, which allows Dai holders to earn savings.\nOptional: Create a UI where users can activate Dai Savings Rate.\nOptional: Link users to \noasis.app\n to activate Dai Savings Rate.\nOptional: Implement paying the gas cost of Dai transactions on behalf of your users.\nAs a Keeper\nGet acquainted with the updates to Keepers and Auctions in MCD with \nthis guide\n.\nUpgrading\nWe expect to release a Python library for working with Auctions before MCD launch. This will be the recommended way to bid in Auctions.\nAlternatively, if you\u0432\u0496\u04b7re willing to do some additional work and work with a lower level interface, you can interact with Auction contracts directly (\nflip\n, \nflap\n, \nflop\n). Note that future collateral types may come with custom auction formats. More documentation will be available before launch.\nAs a Market Maker\nWe encourage you to market make on Multi-Collateral Dai as soon as your exchange partners add support for it.\nIf your exchange partners keep their Sai listing concurrently with their Dai listing, we encourage you to market make on both tokens for the remaining lifetime of Sai.\nIf your exchange partners will use a different ticker for Dai than Sai, you should update your tools accordingly.\nAs a CDP Integrator\nCustodial CDP service\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to MCD.\nInform your users as soon as possible about the date.\nOn the chosen date:\nFreeze access to CDP service for your users\nLaunch upgrade to your service that supports the new CDP core. \nThe smart contract addresses and ABIs can be found here.\n\u0432\u0496\u04e2\nIf you are using Dai.js for your CDP integration, see \u0432\u0496\u04a3\nUsing Dai.js\n\u0432\u0496\u049b below for how to upgrade your implementation to MCD.\nIf you have integrated directly with the CDP smart contracts, see \u0432\u0496\u04a3\nDirect integration with smart contracts\n\u0432\u0496\u049b below for how to upgrade your implementation to MCD.\nMigrate all CDPs to MCD. See \u0432\u0496\u04a3Migration App\u0432\u0496\u049b section below.\nList the Multi-Collateral Dai token as \"Dai\"\nUnfreeze access to CDP service\nOptional: Implement support for added collateral types in MCD\nIf it is relevant to your service, inform users about Dai Savings Rate\nOptional: Implement UI for locking Dai in the Dai Savings Rate smart contract.\nNon-Custodial CDP service\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to MCD.\nInform your users as soon as possible about the timeline for your own upgrade to MCD.\nInform your users about MCD and the migration process of CDPs.\nOn the selected launch date:\nLaunch upgrade to your service that supports the new CDP core.\nIf you are using Dai.js for your CDP integration, see \u0432\u0496\u04a3\nUsing Dai.js\n\u0432\u0496\u049b below for how to upgrade your implementation to MCD.\nIf you have integrated directly with the CDP smart contracts, see \u0432\u0496\u04a3\nDirect integration with smart contracts\n\u0432\u0496\u049b below for how to upgrade your implementation to MCD.\nList the Multi-Collateral Dai token as \"Dai\"\nChoose one of the following:\nOption A: Point your users to \nmigrate.makerdao.com\n at MCD launch date for CDP migration on their CDP dashboard. See also the Migration App section below.\nOption B: Create your own UI for migration, by creating a frontend to interact with the migration contract (see section below on Migration Contract).\nUpgrading your CDP integration implementation\nUsing Dai.js\nIf you have integrated CDPs using the \nDai.js library\n, ensure you have updated the library to the latest version.\nUpdate your codebase to support the functionality of the \nMCD plugin\n. At launch this plugin will be bundled into the Dai.js library as default.\nOptional: Help your users migrate their CDP to MCD\nOption A: Point users to \nmigrate.makerdao.com\n if your app is Web3 compatible.\nOption B: Implement your own migration UI in your app, connecting to the migration contract described in a section below.\nOption C: If your app is not compatible with migrate.makerdao.com, you can guide your users in how to export their CDP from your app to a compatible wallet.\nOptional: Implement support for new MCD functionality\nAdd support for new collateral types.\nAdd support for Dai Savings Rate.\nDirect integration with smart contracts\nIf you have integrated directly with the smart contracts, you must add support for the new Maker core smart contracts. Since the smart contracts have been completely rewritten, most function calls have been changed.\nGet acquainted with the \nnew implementation of MCD\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nYou can find an introduction to the system here\n\u0432\u0496\u04e2\nImplement support for the MCD smart contracts\n\u0432\u0496\u04e2\nCheckout this guide on how to interact with the CDP manager.\n\u0432\u0496\u04e2\nPoint codebase to the new \nMCD smart contracts\n\u0432\u0496\u04e2\nAs a Lending Protocol\nCustodial Service\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to MCD.\nInform your users as soon as possible about the date.\nOn the chosen date:\nStop lending (deposits) and borrowing (withdrawals) of Sai\nList the Multi-Collateral Dai token as \"Dai\". The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token.\nOpen for lending (deposits) and borrowing (withdrawals) of Dai\nFor outstanding loans in Sai, choose one of the following:\nAccept payback of loans in Sai.\nContinuously migrate paybacks of old positions of Sai to Dai yourself.\nInform your users that you can no longer pay back Sai, but that they should migrate their Sai to Dai through migrate.makerdao.com before paying back a loan.\nNon-Custodial Service\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to MCD.\nInform your users as soon as possible about the timeline for your own upgrade to MCD.\nInform users about potential cutoff dates for shutdown of SCD.\nAt launch:\nList the Multi-Collateral Dai token as \"Dai\". The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token.\nLaunch support for Dai loans.\nStop creation of loans in Sai\nPoint users to \nmigrate.makerdao.com\n for Sai migration\nLet existing loans in Sai run until they expire or are paid back\nOptional:\nCreate a UI for users to migrate their balances from Sai to Dai.\nAs a Dapp\nOn November 18: Rename Single-Collateral Dai to \u0432\u0496\u04a3Sai\u0432\u0496\u049b\nSelect a future date between November 18-25 to execute the upgrade to MCD.\nInform your users as soon as possible about the timeline for your own upgrade to MCD.\nOn the chosen date:\nList the Multi-Collateral Dai token as \"Dai\". The new token is deployed at \n0x6b175474e89094c44da98b954eedeac495271d0f\n - use the \nupdated logos found here\n for the new Dai token.\nUpdate code base to support the use of the new Dai token at launch.\nOptional: Implement paying gas cost of Dai transactions in Dai.\nIf you have a product using Sai:\nShutdown functionality of Sai at a cut-off date, communicated well in advance to your users.\nInform your users about potential confusion regarding Sai and Dai.\nInform your users that they can migrate Sai to Dai at \nmigrate.makerdao.com\n\u0432\u0496\u04e2\nOptional: Create a UI for carrying out the migration from Sai to Dai.\nAs another partner type not mentioned above\nPlease reach out to \n[email\u00a0protected]\n and we are happy to discuss your migration scenario.\nMigration App\nUpon release of MCD, the Migration App at \nmigrate.makerdao.com\n will allow you to carry out Dai and CDP migration through an intuitive web UI in just a few clicks. By logging in with your favourite wallet solution, the app will scan your wallet for any recommended migrations and showcase them in the UI (seen in picture below). This migration scan feature is planned to be continually supported going forward, ensuring that users are always using an up-to-date version of the Maker platform.\nLanding Page that will show you possible migrations for the connected wallet.\nWizard for migrating Sai to Dai.\nWizard for migrating an SCD CDP to MCD CDP.\nThe Migration App uses a proxy contract to carry out the CDP migration. Consequently, the app can also only be used for CDPs that have been created through a Maker proxy contract. This happens automatically if you have opened your CDP at \ncdp.makerdao.com\n.\nIf you have created CDPs using third party services that do not use Maker proxies to interact with the CDP core, the migration contract might not work. Instead, you can perform your own manual migration by simply closing down your SCD CDP and moving the ETH to an MCD CDP.\nMigration Contract\nThe functionality of the Migration App outlined in the above section is handled by a Migration Contract that will be deployed at MCD launch in order to support a smooth transition from Single Collateral Dai to Multi Collateral Dai. The contract will make the redemption of Single Collateral Dai tokens (\nSai\n) for Multi Collateral Dai tokens (\nDai\n), and the migration of CDPs to the new CDP engine of MCD, an easy task. This section will outline how the migration contract works in order to help super users and partners prepare for MCD migration.\nFunctionality\nThe migration smart contracts are open source and can be found here: \nhttps://github.com/makerdao/scd-mcd-migration\n\u0432\u0496\u04e2\nIn the \nsrc\n folder, the smart contract source code can be found. The main contract is the \nScdMcdMigration.sol\n which contains the migration functionality that you will interact with.\nIt contains three main functions:\nswapSaiToDai\n - a function that upgrades Sai to Dai\nswapDaiToSai\n - a function that allows you to exchange your Dai back to Sai\nmigrate\n - a function that allows you to migrate your SCD CDP to MCD.\nThe following sections will go deeper into these function calls. The Migration App will present this functionality in an easy to use UI, so a regular user will not have to deal with these function calls directly. We will however dive into them in the following sections to dissect how migration works, and outline the process for power users or partners, who want to carry out migration themselves.\nUpgrading Dai\nIn order to upgrade your Dai to MCD, you must use the \nswapSaiToDai\n function in the migration contract. First you must approve that the migration contract can transfer Sai tokens from your account. Then you are ready to invoke the swap by calling the function specifying the amount of Sai you want to upgrade to Dai. After the function call is mined, the upgraded Dai is sent to the Ethereum address initiating the upgrade. A detailed walk-through using CLI tools to carry out these functions can \nbe found here\n.\nFrom the user perspective, this function simply upgrades a specified amount of Sai to Dai.\nBehind the scenes, deposited Sai tokens are used to create a collective CDP in MCD for all migrating users which Dai is minted from. The migration contract will thus take the Sai tokens from your account, and deposit them into the Sai token adapter, which allows the CDP engine Vat to utilize the tokens for CDP actions. The migration contract will then invoke Vat to lock Sai and issue Dai to the Dai adapter. The migration contract will then exit the Dai tokens from the Dai adapter, which is carried out by invoking a mint function on the Dai token contract which will generate new Dai for the originator\u0432\u0496\u04b7s Ethereum address. The reason Sai to Dai migration is carried out using the CDP core (vat) of the new system, is that this is the only component that has the authority to mint new Dai. The process and function calls are outlined in the diagram below.\nThe following diagram outlines what happens when migrating 10 Sai to 10 Dai.\nSwapping back to Sai\nThe migration contract also allows users to \u0432\u0496\u04a3go back\u0432\u0496\u049b by swapping Dai for Sai, using the function \nswapDaiToSai\n. In this case, the CDP operation is reversed, as Dai is paid back to the system and Sai is released, just like the repayment of a normal CDP, except with no stability fee cost.\nHowever, this operation requires a surplus of Sai already deposited in the migration contract. Therefore there must be at least an equivalent amount of Sai deposited in the contract, to the amount of Dai you want to redeem.\nThis function call is very similar to the former, except this time Dai is deposited to the CDP, and Sai collateral released. This requires you to approve that the migration contract can transfer Dai from your wallet, and then you invoke the swapDaiToSai function with the specified amount of Dai you want to redeem. You can check out \nthis guide\n for a more detailed look into how you call the functions.\nMigration of CDP\nThe migration contract also allows users to migrate their CDPs from the SCD core to the MCD core. This is done through the function \nmigrate\n. The function essentially tries to close your CDP, using excess Sai deposited in the migration contract (by other users who have been upgrading Sai to Dai) to pay your outstanding CDP debt. In order to do so, you need to transfer the control of the CDP to the migration contract. The migration contract will then pay back the debt using Sai deposited in the contract, redeem the ETH collateral, create a new CDP in the MCD system, lock in the ETH collateral, and payback the debt using the generated Dai, resulting in an equivalent CDP debt in MCD.\nHowever, in order to close down the CDP, a stability fee in MKR must be paid, so you need to grant the migration contract approval to spend MKR from you account to carry out the migration.\nThe migration contract uses a proxy contract to carry out all the above steps in one go. Consequently, the contract can also only be used for CDPs that have been created through a Maker proxy contract. This happens automatically if you have opened your CDP at \ncdp.makerdao.com\n. Therefore, you must utilize the \nMigrationProxyActions.sol\n contract to carry out the \nmigrate function call\n.\nIf you have created CDPs using third party services that do not use Maker proxies to interact with the CDP core, the migration contract might not work. Instead, you can perform your own manual migration by simply closing down your SCD CDP and moving the ETH to an MCD CDP.\nTo migrate your CDP, your are also dependant on excess liquidity of Sai in the migration contract to be used to close your CDP. If you have a 10,000 Sai debt CDP you want to migrate, there must be at least 10,000 Sai deposited in the Sai MCD CDP owned by the migration contract (from users upgrading Sai to Dai), to carry out the CDP migration. The migration cannot be carried out partially, why the whole debt of the CDP must be covered by Sai liquidity in the contract to carry out the migration. If you have a large CDP and are concerned about migration, feel free to reach out to the Integrations Team at \n[email\u00a0protected]\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nRead more about the function calls for migrating a CDP here\n\u0432\u0496\u04e2\nIn Summary\nIn this guide, we introduced you to the steps of how to upgrade to Multi-Collateral Dai. We have provided you with guidelines for different types of platforms using Dai and for regular Dai holders. As we approach the launch of Multi-Collateral Dai, more details will be made available.\nTroubleshooting\nIf you encounter any issues with your upgrade process, don\u0432\u0496\u04b7t hesitate to contact us.\nContact integrations team - \n[email\u00a0protected]\n\u0432\u0496\u04e2\nRocket chat - #dev channel\nNext Steps\nAfter finishing this guide we think you\u0432\u0496\u04b7ll enjoy these next guides:\nLearn about our progress towards the launch of \nMCD\n.\nResources\nInformation:\n\u0432\u0496\u04e2\nBlog post: The Road To Mainnet Release\n\u0432\u0496\u04e2\nOther Guides:\n\u0432\u0496\u04e2\nIntroduction and Overview of Multi-Collateral Dai: MCD101\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nUsing MCD-CLI to create and close a MCD CDP on Kovan\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nUsing Seth to create and close an MCD CDP on Kovan\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nUsing Seth for MCD migration\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAdd a new collateral type to DCS - Kovan\n\u0432\u0496\u04e2\nSource code/wiki:\n\u0432\u0496\u04e2\nMulti Collateral Dai code + wiki\n\n\nMiscellaneous - \nPrevious\nSCD <> MCD Migration\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/miscellaneous/upgrading-to-multi-collateral-dai-guide", "title": "Upgrading to Multi-Collateral Dai Guide"}}
{"page_content": "Smart Contract Annotations\nIn-line comments on the Maker Protocol's Core Smart Contracts\nIntroduction\nUnderstanding the various terms used in our smart contracts can involve a significant time investment for developers looking at the codebase for the first time. Due to this fact, we need resources in various formats to ensure they can get up and running quickly. We believe, in order to complement the technical documentation on docs.makerdao.com, that highlighting sections of the codebase and annotating it with comments can surface relevant information developers need while reading the raw contracts in order to understand the contracts better.\nExamples of how annotations may be useful for developers:\nHighlight terms to display their definitions \nEx:\n \nink\n, \nart\nExplain various input parameters in-depth \nEx:\n Explain the precise role of users defined as \ngal\n or \nguy\n within input parameters.\nLink to sections of other smart contracts from where function calls typically originate from\nEx:\n \nheal\n in \nVat\n is called from \nVow\nAdditional context to Maker specific design practices that other smart contract developers might not be accustomed to\nEx: \nShow the event log signature produced by the \nnote\n modifier on a function.\nHelp developers navigate through scenarios that result in calls across multiple smart contracts\nEx: \nKeepers participating in collateral auctions kick the process with \nbite\n on \nCat\n, bad debt is settled in \nVat\n, accounted for in \nVow\n, and a series of transactions on \nflip\n until they receive collateral they purchased for a discount.\nSuperimposing the operational view of the system on all functions will help developers build richer mental models of the Maker Protocol. \nEx: \nAnnotating a function's \nauth\n modifier and mentioning the smart contracts authorized to call it.\nAnnotations will also serve as an open and collaborative discussion layer that helps developers discuss and evolve their understanding of the smart contracts over time.\nUsing Hypothesis\n\u0432\u0496\u04e2\nHypothesis\n is a web-based tool that we use to annotate the codebase hosted on our Github org.\nExample\nCheck out the annotations of the \nVat \nsmart contract \nhere. \n\u0432\u0496\u04e2\nUsage\nHypothesis annotations can be viewed by expanding a sidebar on the top right corner of your browser window.\nThere are three options to view annotations on a webpage: \nInstall the \nchrome extension\n from the web store.\nFollow instructions to setup a \nbookmarklet\n\u0432\u0496\u04e2\nAppend \nhttps://via.hypothes.is\n to a URL.\nOur Hypothesis Groups:\nMakerDAO\n restricted group- everyone is allowed to read annotations but only approved members can contribute \nhere\n.\nPublic MakerDAO group that is open for everyone to both read and contribute.\nCreate a Hypothesis account \nhere\n to get started!\nGlossary - \nPrevious\nMCD Glossaries\nNext\n - Deployment Addresses\nMaker Protocol Deployments\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/other-documentation/smart-contract-annotations", "title": "Smart Contract Annotations"}}
{"page_content": "MCD Glossaries\nA list of words, terms, variables, functions and more relating to the Maker Protocol\n1. \nMCD General Glossary of Terms\n\u0420\u0452\u0406\n\u0420\u0452\u04062. MCD Core Smart Contracts Glossary:\nGeneral\nguy\n, \nusr\n: some address\nwad\n: some quantity of tokens, usually as a fixed point integer with 18 decimal places.\nray\n: a fixed point integer, with 27 decimal places.\nrad\n: a fixed point integer, with 45 decimal places.\nfile\n: administer some configuration value\nAuth\nauth\n: check whether an address can call this method\nward\n: an address that is allowed to call auth'ed methods\nrely\n: allow an address to call auth'ed methods\ndeny\n: disallow an address from calling auth'ed methods\nAuthority\n - checks whether an address can call this method\nKiss\n - cancels out surplus and on-auction debt\nVat (Vault Engine)\ngem\n: collateral tokens.\ndai\n: stablecoin tokens.\nsin\n: unbacked stablecoin (system debt, not belonging to any \nurn\n).\nilk\n: a collateral type.\nrate\n: stablecoin debt multiplier (accumulated stability fees).\ntake\n: collateral balance multiplier.\nInk\n: total collateral balance.\nArt\n: total normalized stablecoin debt.\ninit\n: create a new collateral type.\nurn\n: a specific Vault.\nink\n: collateral balance.\nart\n: normalized outstanding stablecoin debt.\nslip\n: modify a user's collateral balance.\nflux\n: transfer collateral between users.\nmove\n: transfer stablecoin between users.\ngrab\n: liquidate a Vault.\nheal\n: create / destroy equal quantities of stablecoin and system debt (\nvice\n).\nfold\n: modify the debt multiplier, creating / destroying corresponding debt.\ntoll\n: modify the collateral multiplier, creating / destroying corresponding collateral.\nsuck\n: mint unbacked stablecoin (accounted for with \nvice\n).\nspot\n: collateral price with safety margin, i.e. the maximum stablecoin allowed per unit of collateral.\nline\n: the debt ceiling for a specific collateral type.\nLine\n: the total debt ceiling for all collateral types.\ndust\n: the minimum possible debt of a Vault.\nfrob\n: modify a Vault.\nlock\n: transfer collateral into a Vault.\nfree\n: transfer collateral from a Vault.\ndraw\n: increase Vault debt, creating Dai.\nwipe\n: decrease Vault debt, destroying Dai.\ndink\n: change in collateral.\ndart\n: change in debt.\ncalm\n: true when the Vault remains under both collateral and total debt ceilings.\ncool\n: true when the stablecoin debt does not increase.\nfirm\n: true when the collateral balance does not decrease.\nsafe\n: true when the Vault's ratio of collateral to debt is above the collateral's liquidation ratio.\nfork\n: to split a Vault - binary approval or splitting/merging Vaults.\ndink\n: amount of collateral to exchange.\ndart\n: amount of stablecoin debt to exchange.\nwish\n: check whether an address is allowed to modify another address's gem or dai balance.\nhope\n: enable \nwish\n for a pair of addresses.\nnope\n: disable \nwish\n for a pair of addresses.\nNote:\n \nart\n and \nArt\n represent normalized debt, i.e. a value that when multiplied by the correct rate gives the up-to-date, current stablecoin debt.\nAccounting\ndebt\n: the sum of all \ndai\n (the total quantity of dai issued).\nvice\n: the sum of all \nsin\n (the total quantity of system debt).\nilk.Art\n: the sum of all \nart\n in the \nurn\ns for that \nilk\n.\ndebt\n: is \nvice\n plus the sum of \nilk.Art * ilk.rate\n across all \nilk\n's.\nCollateral\ngem\n: can always be transferred to any address by it's owner.\nDai\ndai\n: can only move with the consent of it's owner / can always be transferred to any address by it's owner.\nOther\nLogNote\n: a general purpose log that can be added to any function from a contract.\nJug (Stability Fees)\nStructs\nIlk\n: contains two \nuint256\n values\u0420\u0452\u045b\nduty\n, the collateral-specific risk premium, and \nrho\n, the timestamp of the last fee update\nVatLike\n: mock contract to make Vat interfaces callable from code without an explicit dependency on the Vat contract itself\nStorage\nwards\n: \nmapping(address => uint)\n that indicates which addresses may call administrative functions\nilks\n: \nmapping (bytes32 => Ilk)\n that stores an \nIlk\n struct for each collateral type\nvat\n: a \nVatLike\n that points the the system's \nVat\n contract\nvow\n: the \naddress\n of the Vow contract\nbase\n: a \nuint256\n that specifies a fee applying to all collateral types\nAdministrative\nThese methods require \nwards[msg.sender] == 1\n (i.e. only authorized users may call them).\nrely\n/\ndeny\n: add or remove authorized users (via modifications to the \nwards\n mapping)\ninit(bytes32)\n: start stability fee collection for a particular collateral type\nfile(bytes32, bytes32, uint)\n: set \nduty\n for a particular collateral type\nfile(bytes32, data)\n: set the \nbase\n value\nfile(bytes32, address)\n: set the \nvow\n value\nFee Collection Methods\ndrip(bytes32)\n: collect stability fees for a given collateral type\nCat (Liquidations)\nmat\n: the liquidation ratio\nchop\n: the liquidation penalty\nlump\n: the liquidation quantity, i.e. the fixed debt quantity to be covered by any one liquidation event\nbite\n: initiate liquidation of a Vault \nflip\n: liquidate collateral from a Vault to cover a fixed quantity of debt\nVow (Settlement)\nsin\n: the system debt queue.\nSin\n: the total amount of debt in the queue.\nAsh\n: the total amount of on-auction debt.\nwait\n: length of the debt queue\nsump\n: debt auction bid size, i.e. the fixed debt quantity to be covered by any one debt auction\ndump\n: debt auction lot size, i.e. the starting amount of MKR offered to cover the \nlot\n/\nsump\nbump\n: surplus auction lot size, i.e. the fixed surplus quantity to be sold by any one surplus auction\nhump\n: surplus buffer, must be exceeded before surplus auctions are possible\nOther terms included in Vow documentation:\nmove\n: transfers stablecoin between users.\nkick\n: starts an auction.\nwoe\n: indicates specifically bad debt, or be used as a variable name for any amount of debt.\nFlipper (Collateral Auctions)\nwards [usr: address]\n, \nrely\n/\ndeny\n/\nauth\n: Auth mechanisms\nBid\n: State of a specific Auction {\nbid\n, \nlot\n, \nguy\n, \ntic\n, \nend\n, \nusr\n, \ngal\n, \ntab\n}\nbid\n: Bid amount (DAI)/ DAI paid\nlot\n: quantity up for auction / collateral gems for sale\nguy\n: high bidder (address)\ntic\n: Bid expiry\nend\n: when the auction will finish / max auction duration\nusr\n: address of the Vault being auctioned. Receives gems during the \ndent\n phase\ngal\n: recipient of auction income / receives dai income (this is the Vow contract)\ntab\n: total dai wanted from the auction / total dai to be raised (in flip auction)\nbids[id: uint]\n: storage of all bids\nvat\n: storage of the Vat's address\nilk\n: id of the Ilk for which the Flipper is responsible\nbeg\n: minimum bid increase (default: 5%)\nttl\n: bid duration (default: 3 hours)\ntau\n: auction length (default: 2 days)\nkicks\n: Total auction count, used to track auction \nid\ns\nkick\n: function used by \nCat\n to start an auction / Put collateral up for auction\ntick\n: restart an auction if there have been 0 bids and the \nend\n has passed\ntend\n: first phase of an auction. Increasing Dai \nbid\ns for a set \nlot\n of Gems\ndent\n: second phase of an auction. Set Dai \nbid\n for a decreasing \nlot\n of Gems\nfile\n: function used by governance to set \nbeg\n, \nttl\n, and \ntau\ndeal\n: claim a winning bid / settles a completed auction\nyank\n: used during Global Settlement to move \ntend\n phase auctions to the \nEnd\n by retrieving the collateral and repaying dai to the highest bidder.\nFlapper (Surplus Auctions)\nFlap\n: surplus auction (selling stablecoins for MKR) [contract]\nwards [usr: address]\n: \nrely\n/\ndeny\n/\nauth\n Auth Mechanisms [uint]\nBid\n: State of a specific Auction[Bid]\nbid\n: quantity being offered for the \nlot\n (MKR) [uint]\nlot\n: lot amount (DAI) [uint]\nguy\n: high bidder [address]\ntic\n: Bid expiry [uint48]\nend\n: when the auction will finish [uint48]\nbids (id: uint)\n: storage of all \nBid\ns by \nid\n [mapping]\nvat\n: storage of the Vat's address [address]\nttl\n: bid lifetime / max bid duration (default: 3 hours) [uint48]\nlot\n: lot amount (DAI) [uint]\nbeg\n: minimum bid increase (default: 5%) [uint]\ntau\n: maximum auction duration (default: 2 days) [uint48]\nkick\n: start an auction / put up a new DAI \nlot\n for auction [function]\ntend\n: make a bid, thus increasing the bid size / submit an MKR bid (increasing \nbid\n) [function]\ndeal\n: claim a winning bid / settling a completed auction [function]\ngem\n: MKR Token [address]\nkicks\n: total auction count [uint]\nlive\n: cage flag [uint]\nfile\n: used by governance to set \nbeg\n, \nttl\n, and \ntau\n [function]\nyank\n: is used during Global Settlement to move \ntend\n phase auctions to the \nEnd\n by retrieving the collateral and repaying DAI to the highest bidder. [function]\ntick()\n: resets the \nend\n value if there has been 0 bids and the original \nend\n has passed.\nFlopper (Debt Auctions)\nflop\n: debt auction (covering debt by inflating MKR and selling for stablecoins)\nlot\n: quantity up for auction / gems for sale (MKR)\nguy\n: high bidder (address)\ngal\n: recipient of auction income / receives dai income (this is the Vow contract)\nttl\n: bid lifetime (Max bid duration / single bid lifetime)\nbeg\n: minimum bid decrease\npad\n: Increase for \nlot\n size during \ntick\n (default to 50%)\ntau\n: maximum auction duration\nend\n: when the auction will finish / max auction duration\nkick\n: start an auction / Put up a new MKR \nbid\n for auction\ndent\n: make a bid, decreasing the lot size (Submit a fixed DAI \nbid\n with decreasing \nlot\n size)\ndeal\n: claim a winning bid / settles a completed auction\nvat\n: the Vat's address\ngem\n: MKR Token (address)\nkicks\n: Total auction count, used to track auction \nid\ns\nlive\n: Cage flag\nwards [usr: address]\n, \nrely\n/\ndeny\n/\nauth\n: Auth mechanisms\nBid\n: State of a specific Auction {\nbid\n, \nlot\n, \nguy\n, \ntic\n, \nend\n}\nbid\n: Bid amount inDAI / DAI paid\ntic\n: Bid expiry\ntick\n: restarts an auction\nEnd (Global Settlement / Shutdown)\ncage\n: Locks the system and initiates shutdown. This is done by freezing the user-facing actions, canceling \nflap\n and \nflop\n auctions, locking the rest of the system's contracts, disabling certain governance actions that could interfere with the settlement process, and starting the cool-down period.\ncage(ilk)\n: Tags the Ilk prices / Sets the final price for an ilk (\ntag\n).\nskim\n: Settles a Vault at the tagged price / Cancels owed Dai from the Vault\nfree\n: Remove (remaining) collateral from a settled Vault. This occurs only after there is no debt in the Vault.\nthaw\n: Fixes the Dai supply after all Skims / Fixes the total outstanding supply of stablecoin.\nflow\n: Calculates the fixed price for an ilk, possibly adjusting the \ncage\n price with surplus/deficit.\npack\n: Locks Dai ahead of Cash / Puts some stablecoin into a \nbag\n in preparation for \ncash\n.\ncash\n: Exchange \npack\ned Dai for collateral / Exchange some Dai from \nbag\n for a given \ngem\n, share proportional to \nbag\n size.\nfile\n: The Governance configuration\u0420\u0452\u045bsets various parameter values.\nskip\n: optionally cancel live auctions.\nOther\nwards(usr: address)\n: Auth Mechanism\nvat\n: Vat contract\ncat\n: Cat contract\nvow\n: Vow contract\nspot\n: Spotter contract\nlive\n: Cage flag\n\"Live\" contracts have \nlive\n = 1, indicating the system is running normally. Thus, when \ncage()\n is invoked, it sets the flag to 0. This includes the \nEnd\n contract, which means that \ncage()\n can only be invoked once and the subsequent functions cannot be invoked until we are \"dead\" and in the End process\nilk\n: A collateral type\nwhen\n: Time of cage / the time of settlement.\nwait\n: Processing cooldown duration / the length of processing cooldown.\ndebt\n: Outstanding Dai after processing / outstanding stablecoin supply, after system surplus/deficit has been absorbed.\ntag\n: Cage price / price per collateral type at time of settlement.\ngap\n: Collateral shortfall / shortfall per collateral considering undercollateralised Vaults.\nArt\n: Total debt per Ilk/outstanding stablecoin debt.\nfix\n: Final cash price / the cash price for an ilk (amount per stablecoin).\nbag(usr: address)\n: Dai packed for \ncash\n / nontransferable stablecoins ready to exchange for collateral.\nout\n: Cash out / the amount of already exchanged stablecoin for a given address.\nskip\n: Optionally cancel live auctions.\nwad\n: Some quantity of tokens, usually as a fixed point integer with 10^18 decimal places.\nurn\n: A specific Vault.\ntend\n: To make a bid, increasing the bid size.\nbid\n: The quantity being offered for the \nlot\n.\nlot\n: The quantity up for auction.\ndent\n: To make a bid, decreasing the lot size.\nJoin (Token Adapters)\nvat\n: storage of the \nVat\n\u0420\u0452\u040es address.\nilk\n: id of the Ilk for which a \nGemJoin\n is created for.\ngem\n: the address of the \nilk\n for transferring.\ndai\n: the address of the \ndai\n token.\none\n: a 10^27 uint used for math in \nDaiJoin\n.\nlive\n: an access flag for the \njoin\n adapter.\ndec\n: decimals for the Gem.\nCat (Liquidations)\nmul(uint, uint)\n/\nrmul(uint, uint)\n: will revert on overflow or underflow\nbite(bytes32, address)\n: will revert if \nlot\n or \nart\n are larger than or equal to 2^255.\nbite\n:  will not leave a Vault with debt and no collateral.\nwards\n:  are allowed to call protected functions (Administration and \ncage()\n)\nilks\n:  stores \nIlk\n structs\nIlk\n is the struct with the address of the collateral auction contract (\nflip\n), the penalty for that collateral to be liquidated (\nchop\n) and the maximum size of collateral that can be auctioned at once (\nlump\n).\nlive\n:  must be \n1\n for the \nCat\n to \nbite\n (see \ncage\n in mechanisms)\nvat\n:  address that conforms to a \nVatLike\n interface (see \nvat\n documentation [TODO - Link] for more info). It is set during the constructor and \ncannot be changed\n.\nvow\n:  address that conforms to a \nVowLike\n interface (see \nvow\n documentation [TODO - Link] for more info).\nEvents\nBite\n: emitted when a \nbite(bytes32, address)\n is successfully executed. Contains:\nilk\n: Collateral\nurn\n: Vault address\nink\n: see \nlot\n in \nbite\nart\n: see \nart\n in \nbite\ntab\n: see \ntab\n in \nbite\nflip\n: address of the auction contract\nid\n: ID of the auction in the \nFlipper\nSpot (Oracles and Contracts Liaison)\nilk\n: a given collateral type\nilk.pip\n: the contract which holds the current price of a given \nilk\nilk.mat\n: the liquidation ratio for a given \nilk\nvat\n: the core of the mcd system\npar\n: the relationship between DAI and 1 unit of value in the price. (Similar to TRFM)\nCollateral\nOnly authorized users can update any variables in contract\nPot (Savings Dai)\nMath\nmul(uint, uint)\n, \nrmul(uint, uint)\n, \nadd(uint, uint)\n& \nsub(uint, uint)\n: will revert on overflow or underflow\nrpow(uint x, uint n, uint base)\n: used for exponentiation in \ndrip\n, is a fixed-point arithmetic function that raises \nx\n to the power \nn\n.\nAuth\nwards\n: are allowed to call protected functions (Administration)\nStorage\npie\n: stores the address' \nPot\n balance.\nPie\n: stores the total balance in the \nPot\n.\ndsr\n: the \ndai savings rate\n. It starts as \n1\n (\nONE = 10^27\n), but can be updated by governance.\nchi\n: the rate accumulator. This is the always increasing value which decides how much \ndai\n: given when \ndrip()\n is called.\nvat\n: an address that conforms to a \nVatLike\n interface. It is set during the constructor and \ncannot be changed\n.\nvow\n: an address that conforms to a \nVowLike\n interface. Not set in constructor. Must be set by governance.\nrho\n: the last time that drip is called.\nDai (Stablecoin)\nname\n: Dai Stablecoin\nsymbol\n: DAI\nversion\n: 1\ndecimals\n: 18\nwad\n: fixed point decimal with 18 decimals (for basic quantities, e.g. balances).\ntotalSupply\n: Total DAI Supply\nbalanceOf(usr: address)\n: User balance\nallowance(src: address, dst: address)\n: Approvals\nnonces(usr: address)\n: Permit nonce\n\n\nPrevious\nESM - Detailed Documentation\nNext\n - Glossary\nSmart Contract Annotations\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/other-documentation/system-glossary", "title": "MCD Glossaries"}}
{"page_content": "Security for the Maker Protocol\nEnsuring the Security of the Maker Protocol and Multi Collateral Dai\nIntroduction\n\u200b\nSecurity.makerdao.com\n \nis dedicated to providing transparency to our community with respect to the results of our MCD Audits, our Bug Bounty Program, and Formal Verification. It is important to note that this release is the first version and we will continue to add information as it becomes available.\n1. Updates On MCD Security Roadmap\n\u200b\nMCD Bug Bounty Announcement and Security Roadmap Update\n \nJuly 24, 2019\n\u200b\nMCD Security Roadmap Update\n \nOctober 23, 2019\n\u200b\nPublication of the Runtime Verification Audit\n \nDecember 19, 2019\n\u200b\n2. \nAudit Reports\n\u200b\n3. \nBug Bounty Program\n\u200b\n4. \nFormal Verification\n\u200b\nDeployment Addresses - \nPrevious\nMaker Protocol Deployments\nNext\n - Building on top of the Maker Protocol\nDeveloper Guides and Tutorials\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/security/security.makerdao.com", "title": "Security for the Maker Protocol"}}
{"page_content": "Collateral Module\nAdapters and Auction contracts for each specific collateral type\nModule Name:\n Collateral Module\nType/Category:\n DSS \u0432\u0496\u201d> join.sol, clip.sol\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\nContract Sources:\n \n\u0432\u0496\u04e2\nJoin\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nClip\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe collateral module is deployed for every new \nilk\n (collateral type) added to \nVat\n. It contains all the adapters and auction contracts for one specific collateral type.\nFor other information related to the collateral module, read the following resources:\n\u0432\u0496\u04e2\nAuctions & Keepers within MCD 101\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nHow to Run Your Own Auction Keeper Bot in MCD Blog Post\n\u0432\u0496\u04e2\n2. Module Details\nThe Collateral Module has 3 core components consisting of the \njoin\n, and \nflip\n contracts.\nThe Collateral Module is built up of the following components:\n1.\n\u0432\u0496\u04e2\nJoin Documentation\n\u0432\u0496\u04e2\n2.\nClipper Contract - see\n \nLiquidation 2.0 Documentation\n\u0432\u0496\u04e2\n3. Key Mechanism and Concepts\nSummary of the \nCollateral Module Components\nJoin\n - adapters that are used to deposit/withdraw unlocked collateral into the \nVat\n. Join contains three smart contracts:\n1.\nGemJoin\n2.\nETHJoin\n3.\nDaiJoin\n.\nEach of the \njoin\n contracts are specifically used for the given token type to be \njoin\n'ed to the \nvat\n. Due to this fact, each \njoin\n contract has slightly different logic to account for the different types of tokens within the system.\nHow exactly do the \nJoin\n contracts help the MCD system operate?\nJoin\n - the purpose of join adapters is to retain the security of the system, allowing only trusted smart contracts to add/remove value to/from the \nVat\n. The location of collateral deposited/locked in Vaults is in the respective Join adapter.\n4. Gotchas (Potential sources of user error)\nWhen a user desires to enter the system and interact with the \ndss\n contracts, they must use one of the \njoin\n contracts.\nIf there was a contract bug in a \njoin\n contract and a user was to call \njoin\n by accident, they can still retrieve their tokens back through the corresponding \nexit\n call on the given \njoin\n contract.\n5. Failure Modes\nThere could potentially be a \nvat\n upgrade that would require new \njoin\n contracts to be created\nIf a \ngem\n contract were to go through a token upgrade or have the tokens frozen while a user's collateral was in the system, there could potentially be a scenario in which the users were unable to redeem their collateral after the freeze or upgrade was finished. This seems to be a small risk though because it would seem likely that the token going through this upgrade would want to work alongside the maker community to be sure this was not an issue.\nPotential Phishing Attacks\nAs the MCD system evolves, we will see many more \njoin\n contracts, user interfaces, etc. This surfaces the potential for a user to have their funds stolen by a malicious \njoin\n contract which would send tokens to an external contract or wallet, instead of the \nvat\n.\nPrevious\nSpot - Detailed Documentation\nNext\nJoin - Detailed Documentation\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/collateral-module", "title": "Collateral Module"}}
{"page_content": "Core Module\nThe State of the Maker Protocol\nModule Name:\n Vault Core Module\nType/Category:\n Vault Core Module \u2014> ( Vat.sol, Spot.sol )\n\u200b\nAssociated MCD System Diagram\n\u200b\nContract Sources:\n\u200b\nVat\n\u200b\n\u200b\nSpot\n\u200b\n1. Introduction (Summary)\nThe \nCore Module\n is crucial to the system as it contains the entire state of the Maker Protocol and controls the central mechanisms of the system while it is in the expected normal state of operation.\n2. Module Details\nCore Module Components Documentation\n1.\n\u200b\nVat - Detailed Documentation\n\u200b\n2.\n\u200b\nSpot - Detailed Documentation\n\u200b\n3. Key Mechanism and Concepts\nVat\n - The core Vault, Dai, and collateral state is kept in the \nVat\n. The \nVat\n contract has no external dependencies and maintains the central \"Accounting Invariants\" of Dai.\nSpot\n - \npoke\n is the only non-authenticated function in \nspot\n. The function takes in a \nbytes32\n of the \nilk\n to be \"poked\". \npoke\n calls two \nexternal\n functions, \npeek\n and \nfile\n.\n4. Gotchas (Potential sources of user error)\nThe methods in the \nVat\n are written to be as generic as possible and as such have interfaces that can be quite verbose. Care should be taken that you have not mixed the order of parameters. Any module that is \nauth\ned against the \nVat\n has full root access, and can, therefore, steal all collateral in the system. This means that the addition of a new collateral type (and associated adapter) carries considerable risk.\nWhen the \nCat\n is upgraded, there are multiple references to it that must be updated at the same time (\nEnd\n, \nVat.rely\n, \nVow.rely\n). It must also rely on the \nEnd\n, the system's \npause.proxy()\n. Read more \nhere\n.\nThe methods in the \nspotter\n are relatively basic compared to most other portions of \ndss\n. There is not much room for user error in the single unauthed method \npoke\n. If an incorrect \nbytes32\n is supplied the call will fail. Any module that is authed against the \nspot\n has full root access, and can, therefore, add and remove which \nilks\n can be \"poked\". While not completely breaking the system, this could cause considerable risk.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nCoding Errors\nVat\n - A bug in the \nVat\n could be catastrophic and could lead to the loss (or locking) of all Dai and Collateral in the system. It could become impossible to modify Vault's or to transfer Dai. Auctions could cease to function. Shutdown could fail.\nSpot\n - A bug in \nspot\n would most likely result in the prices for collaterals not being updated anymore. In this case, the system would need to authorize a new \nspot\n which would then be able to update the prices. Overall this is not a catastrophic failure as this would only pause all price fluctuation for some period.\nFeeds\nVat\n - relies upon a set of trusted oracles to provide price data. Should these price feeds fail, it would become possible for unbacked Dai to be minted, or safe Vaults could be unfairly liquidated.\nSpot\n - relies upon a set of trusted oracles to provide price data. Should these price feeds fail, it would become possible for unbacked Dai to be minted, or safe Vaults could be unfairly liquidated.\nGovernance\nVat\n - Governance can authorize new modules against the \nVat\n. This allows them to steal collateral (\nslip\n) or mint unbacked Dai (\nsuck\n/addition of worthless collateral types). Should the crypto economic protections that make doing so prohibitively expensive fail, the system may be vulnerable and left open for bad actors to drain collateral.\nPrevious\nDai - Detailed Documentation\nNext\nVat - Detailed Documentation\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/core-module", "title": "Core Module"}}
{"page_content": "Dai Module\nThe DAI token contract and all of the adapters DaiJoin adapters.\nModule Name:\n DAI Module\nType/Category: Proxy \u2014>\n Dai.sol and DaiJoin.sol\n\u200b\nAssociated MCD System Diagram\n\u200b\nContract Sources:\n\u200b\ndai\n\u200b\n\u200b\ndaiJoin\n\u200b\n1. Introduction (Summary)\nThe origin of DAI was designed to represent any token that the core system considers equal in value to its internal debt unit. Thus, the \nDAI Module\n contains the DAI token contract and all of the adapters DaiJoin adapters.\n2. Module Details\nGlossary (DAI)\nKey Functionalities (as defined in the smart contract)\nMint\n - Mint to an address\nBurn\n - Burn at an address\nPush\n - Transfer\nPull\n - Transfer From\nMove\n - Transfer From\nApprove\n - Allow pulls and moves\nPermit\n - Approve by signature\nOther\nname\n - Dai Stablecoin\nsymbol\n - DAI\nversion\n - 1\ndecimals\n - 18\ntotalSupply\n - Total DAI Supply\nbalanceOf(usr: address)\n - User balance\nallowance(src: address, dst: address)\n - Approvals\nnonces(usr: address)\n - Permit nonce\nGlossary (Join)\nvat\n - storage of the Vat\u2019s address\nilk\n - id of the Ilk for which a \nGemJoin\n is created for\ngem\n - the address of the \nilk\n for transferring\ndai\n - the address of the \ndai\n token\none\n - a 10^27 uint used for math in \nDaiJoin\nCore Module Components Documentation\n1.\n\u200b\nDai - Detailed Documentation\n\u200b\n2.\n\u200b\nDaiJoin Documentation \n(referenced in Join - Detailed Documentation)\n3. Key Mechanism and Concepts\nWhy are these components important to the Multi-Collateral Dai (MCD) System?\nThe \nDai\n contract is the user facing ERC20 contract maintaining the accounting for external Dai balances. Most functions are standard for a token with changing supply, but it also notably features the ability to issue approvals for transfers based on signed messages.\nJoin\n consists of three smart contracts, one of which is the DaiJoin contract. Each join contract is created specifically to allow the given token type to be joined to the vat. Because of this, each join contract has slightly different logic to account for the different types of tokens within the system. The DaiJoin contract allows users to withdraw their Dai from the system into a standard ERC20 token.\n4. Gotchas (Potential sources of user error)\nDAI\n is also susceptible to the known \nERC20 race condition\n, but should not normally be an issue with unlimited approval. We recommend any users using the \napproval\n for a specific amount be aware of this particular issue and use caution when authorizing other contracts to perform transfers on their behalf.\nThere are limited sources of user error in the \njoin\n contracts system due to the limited functionality of the system. Barring a contract bug, should a user call join by accident they could always get their tokens back through the corresponding exit call on the given join contract. The main issue to be aware of here would be a well-executed phishing attack. As the system evolves and potentially more join contracts are created, or more user interfaces are made, there is the potential for a user to have their funds stolen by a malicious join contract which does not actually send tokens to the vat, but instead to some other contract or wallet.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nThere could potentially be a \nvat\n upgrade that would require new \njoin\n contracts to be created.\nIf a \ngem\n contract were to go through a token upgrade or have the tokens frozen while a user's collateral was in the system, there could potentially be a scenario in which the users were unable to redeem their collateral after the freeze or upgrade was finished. This seems to be a small risk though because it would seem likely that the token going through this upgrade would want to work alongside the maker community to be sure this was not an issue.\nGetting Started - \nPrevious\nMaker Protocol 101\nNext\nDai - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/dai-module", "title": "Dai Module"}}
{"page_content": "Liquidation 2.0 Module\nThe Maker Protocol's Collateral Auction House (Liquidation System 2.0)\nContract Source(s):\n \nclip.sol\n, \ndog.sol\n, \nabacus.sol\n\u200b\nType/Category:\n DSS \u2014> Liquidation 2.0 Module\u200b\u200b\u200b\nEtherscan\n\u200b\nDog\n\u200b\n\u200b\nClip (ETH-A)\n\u200b\n\u200b\nAbacus (ETH-A)\n\u200b\n1. Introduction\nSummary:\n In the context of the Maker protocol, a \nliquidation\n is the automatic transfer of collateral from an insufficiently collateralized Vault, along with the transfer of that Vault\u2019s debt to the protocol. In the liquidation contract (the \nDog\n), an auction is started promptly to sell the transferred collateral for DAI in an attempt to cancel out the debt now assigned to the protocol.\n2. Features\nInstant Settlement\nUnlike the old Liquidation 1.2 system which utilized English auctions, in which DAI bids are placed, with a participant's capital remaining locked until they are outbid or until the auction terminates, Liquidation 2.0 uses Dutch auctions which settle instantly. They do so according to a price calculated from the initial price and the time elapsed since the auction began. Price versus time curves are discussed more later. The lack of a lock-up period mitigates much of the price volatility risk for auction participants and allows for faster capital recycling.\nFlash Lending of Collateral\nThis feature, enabled by instant settlement, eliminates any capital requirement for bidders (excepting gas)\u2014in the sense that even a participant with zero DAI (and nothing to trade for DAI) could still purchase from an auction by directing the sale of the auction's collateral into other protocols in exchange for DAI. Thus, all DAI liquidity available across DeFi can be used by any participant to purchase collateral, subject only to gas requirements. The exact mechanics are discussed above, but essentially a participant needs to specify a contract \nwho\n (which conforms to a particular interface), and \ncalldata\n to supply to it, and the auction contract will automatically invoke whatever logic is in the external contract.\nPrice as a Function of Time\nPrice-versus-time curves are specified through an interface that treats price at the current time as a function of the initial price of an auction and the time at which that price was set. How to determine the most effective price curve for a given collateral is still an active area of research; some initial options (linear, step-wise exponential, and continuous exponential) have been implemented for research purposes and initial deployment. Other candidates besides these include a piecewise linear curve and a piecewise exponential curve. This module is configurable and can be replaced in the course of innovation.\nIt is important for bidders to take into account that while the price almost always decreases with time, there are infrequent occasions on which the price of an active auction may increase, and this could potentially result in collateral being purchased at a higher price than intended. The most obvious event that would increase the price in a running auction is if that auction is reset (via \nredo\n), but changes to the configurable parameters of a price decrease calculator (or even the switching out of one calculator for another) by governance can also increase the price. It is recommended that bidders (or bidding UIs that abstract this detail away from the user) choose the maximum acceptable price (\nmax\n) argument to \ntake\n carefully to ensure a desirable outcome if the price should unexpectedly increase.\nResetting an Auction\nAs mentioned above, auctions can reach a defunct state that requires resetting for two reasons:\ntoo much time has elapsed since the auction started (controlled by the \ntail\n governance parameter)\nthe ratio of the current price to the initial price has fallen below a certain level (specified by the \ncusp\n governance parameter).\nThe reset function, when called, first ensures that at least one of these conditions holds. Then it adjusts the starting time of the auction to the current time, and sets the starting price in exactly the same way as is done in the initialization function (i.e. the current OSM price increased percentage-wise by the \nbuf\n parameter). This process will repeat until all collateral has been sold or the whole debt has been collected (unless the auction is canceled via \nyank\n, e.g. during Emergency Shutdown); contrast this behavior with the current auctions, which reset until at least one bid is received.\nImproved Keeper Wallet Security\nIf keepers decide to use the \nclipperCallee\n pattern, then they need not store DAI or collateral on that account. This means a keeper need only hold enough ETH to execute transactions that can orchestrate the \nClipper.take\n call, sending collateral to a contract that returns DAI to the \nmsg.sender\n to pay for the collateral all in one transaction. The contract implementing the \nclipperCallee\n interface can send any remaining collateral or DAI beyond \nowe\n to a cold wallet address inaccessible to the keeper. \nNOTE: If the keeper chooses to behave as an EOA address, then the DAI and collateral would be exposed just as in \nLIQ-1.2\n unless special care is taken to create a proxy contract.\n3. Contract Details\nParameters Set By Governance (through \nfile\n)\nAbacus/LinearDecrease\n -- \ntau\n [seconds]\nSeconds after auction start when the price reaches zero.\nAbacus/StairstepExponentialDecrease\n -- \ncut\n [ray]\nPer-\nstep\n multiplicative factor. \ncut = 0.99 * RAY\n specifies a 1% drop every \nstep\n seconds.\nAbacus/StairstepExponentialDecrease\n -- \nstep\n [seconds]\nLength of time between price drops.\nAbacus/ExponentialDecrease\n -- \ncut\n [ray]\nPer-second multiplicative factor. \ncut = 0.99 * RAY\n specifies a 1% drop every second.\nClipper\n -- \nbuf\n [ray]\nThe multiplicative factor to increase the starting price of an auction. E.g. if the current OSM price of an asset is 1,000 and \nbuf = 1.2 * RAY\n (20% above), then the initial price of that auction will be 1,200.\nClipper\n -- \ncalc\n [address]\nThe contract address of the price calculator function. Adheres to \nAbacus\n interface. Some examples of price functions are found in \nabaci.sol\n file.\nClipper\n -- \nchip\n [wad]\nPercentage of \ntab\n to \nsuck\n from \nvow\n to incentivize keepers when liquidating a vault or resetting an already existing auction. \nchip = 0.02 * WAD\n is 2%.\nClipper\n -- \ncusp\n [ray]\nPercentage price drop that can occur before an auction must be reset. Together with \ntail\n, this parameter determines when an auction needs to be reset. E.g. if the initial price of an auction (\ntop\n) is set to 1,200 and \ncusp = 0.6 * RAY\n (60% of the starting price), then the auction will need to be reset when reaching just below the price of 720.\nClipper\n -- \ndog\n [address]\nThe address of the liquidation module contract.\nClipper\n -- \nspotter\n [address]\nThe Collateral price module contract address.\nClipper\n -- \ntail\n [seconds]\nSeconds that can elapse before an auction must be reset. Together with \ncusp\n, this parameter determines when an auction needs to be reset. E.g. if \ntail\n is 1800 seconds, then if an auction is not complete after 30 minutes have elapsed, it will need to be reset.\nClipper\n -- \ntip\n [rad]\nFlat fee to \nsuck\n from \nvow\n to incentivize keepers when liquidating a vault or resetting an already existing auction. \ntip = 100 * RAD\n is 100 DAI.\nClipper\n -- \nvow\n [address]\nThe address of the accounting system contract. The recipient of DAI raised in auctions.\nDog\n -- \nHole\n [rad]\nMax DAI needed to cover debt + liquidation penalty of active auctions. \nHole = 10,000,000 * RAD\n is 10M DAI.\nDog\n -- \nilk.chop\n [wad]\nLiquidation Penalty per collateral (\nilk\n). E.g. if there is a vault ready to be liquidated that has a debt of 1,000 DAI and \nchop = 1.13 * WAD\n (13% above), then the max amount to be raised by the auction will be 1,130 DAI.\nDog\n -- \nilk.clip\n [address]\nThe address of the auction module contract. One \nclip\n per collateral (\nilk\n).\nDog\n -- \nilk.hole\n [rad]\nMax DAI needed to cover debt + liquidation penalty of active auctions per collateral (\nilk\n). \nhole = 10,000,000 * RAD\n is 10M DAI.\nDog\n -- \nvow\n [address]\nThe address of the accounting system contract. The recipient of the bad debt coming from a vault when it's liquidated.\nVault Liquidation\n\u200b\nhttps://github.com/makerdao/dss/blob/liq-2.0/src/dog.sol\n\u200b\nThe Vault liquidation function (\nDog.bark\n) takes three caller supplied arguments:\nilk\n: the collateral ilk\nurn\n: the Vault to be liquidated\nkpr\n: the address where DAI incentives will be sent\nDog.bark\n performs several actions:\nconfiscates the given Vault \nurn\n if it's undercollateralized and\nsends the collateral to the \nilk\n's \nClipper\nincrements the \nvow\n's bad debt accumulator\npushes the bad debt into the debt queue\nadds the bad debt plus the liquidation penalty to the \nHole\n with the \nDirt\n accumulator\nadds the bad debt plus the liquidation penalty to the \nilk.hole\n with the \nilk.dirt\n accumulator\ninitiates the auction by calling \nClipper.kick()\nfires the \nBark()\n event\nIn the context of the Maker protocol, a \"liquidation\" is the automatic transfer of collateral from an insufficiently collateralized Vault, along with the transfer of that Vault's debt to the protocol. In both the Liquidation 1.2 version (the \nCat\n) and the Liquidation 2.0 version (the \nDog\n), an auction is started promptly to sell the transferred collateral for DAI in an attempt to cancel out the debt now assigned to the protocol. This makes the behavior of the new contract very similar to that of the old one, but there are some important differences, explained below.\nPartial vs. Total Liquidations\nIn the current system, in each call to the liquidation function (\nCat.bite\n) transfers a fixed amount of debt (the \ndunk\n) from the affected Vault, along with a proportional amount of the Vault's collateral to the protocol. For example, if 50% of a Vault's debt is taken by the protocol, then half of its collateral is taken as well. If the Vault's debt is less than the \ndunk\n, then all debt and collateral is taken. In 2.0, all debt is taken when the liquidation function (\nDog.bark\n) is called, and no analogue of the \ndunk\n parameter exists. The reasoning behind this change is that because the new auctions allow partial purchases of collateral, the liquidity available to a participant no longer limits their ability to participate in auctions, so instead the total number of auctions should be minimized. Just to emphasize, there is no longer a minimum DAI liquidity requirement for the sale of collateral on a per-participant basis.\nLimits on DAI Needed to Cover Debt and Fees of Active Auctions\nIn situations involving large amounts of collateral at auction, the current and new designs modify the behavior described in the previous section. Both liquidations 1.2 and 2.0 implement a limit on the total amount of DAI needed to cover the summed debt and liquidation penalty associated with all active auctions. In \nLIQ-1.2\n this is called the \nbox\n, and in \nLIQ-2.0\n we call this the \nHole\n. Whenever the maximum possible addition to this value is less than the amount of debt+fees that would otherwise be sent to auction, a partial liquidation is performed so as not to exceed this amount. In the current system there is only a global limit; in 2.0, in addition to the global limit, there is also a per-collateral limit. Similar to how there is an \nilk.line\n for a collateral's debt ceiling and a \nLine\n for the overall system debt ceiling, there is now an \nilk.hole\n to correspond with the \nHole\n. This ensures that typical market depth against DAI can be taken into account on a per-collateral basis by those determining risk parameters. The \nDirt\n accumulator tracks the total DAI needed to cover the debt and penalty fees of all active auctions, and must be less than \nHole\n for a call to \nbark\n to succeed. For each collateral type, \nilk.dirt\n tracks the total DAI needed to cover the debt and penalty fees of a all active auctions for that \nilk\n, and must be less than \nilk.hole\n for a call to \nbark\n (on a Vault of that \nilk\n) to succeed.\nAuction Initiation\n\u200b\nhttps://github.com/makerdao/dss/blob/liq-2.0/src/clip.sol\n\u200b\nThe auction initiation function (\nClipper.kick\n) takes four caller supplied arguments:\ntab\n: the target DAI to raise from the auction (\ndebt\n + \nstability fees\n + \nliquidation penalty\n) [rad]\nlot\n: the amount of collateral available for purchase [wad]\nusr\n: the address to return any excess collateral to\nkpr\n: the address where DAI incentives will be sent\nClipper.kick\n performs several checks and actions:\nchecks that the caller is authorized (only the \nDog\n or governance may call \nClipper.kick\n)\nchecks that liquidations are enabled in the four-stage circuit breaker\nincrements a counter and assigns a unique numerical \nid\n to the new auction\ninserts the \nid\n into a list tracking active auctions\ncreates a structure to record the parameters of the auction; this includes:\nit's position in the active auctions list\nthe target amount of DAI to raise from bidders (\ntab\n)\nthe amount of collateral available for purchase (\nlot\n)\nthe Vault that was liquidated to create this auction\nallows return of collateral if not all of it is sold\nallows the return of collateral and \ntab\n when \nClipper.yank\n is called by \nEnd.snip\nthe timestamp of the auctions creation (as a Unix epoch)\nthe initial price of collateral in the auction (\ntop\n)\nsends an incentive denominated in DAI to the \nkpr\nfires the \nKick()\n event\nThe initial price is set by reading the current price in the corresponding \nOracle Security Module\n (OSM) and multiplying by a configurable percentage (the \nbuf\n parameter). Note that the \ncurrent\n OSM price is between one and two hours delayed relative to the actual market price. A keeper doesn't make a call to \nClipper.kick\n directly, but rather makes a call to \nDog.bark\n which in turn calls \nClipper.kick\n.\nLiquidation Incentive Mechanism\nIn this design, there is less incentive to quickly liquidate Vaults than in the current system, because there is no inherent advantage obtained by doing so. In contrast, the current auction system grants the account triggering a liquidation the privilege of making the first bid in the resulting auction. It is unclear whether this matters significantly in practice, or whether some stronger incentive should be added (for example, a small DAI reward paid to liquidators).\nTo ensure there was a remedy for this potential issue, an incentive mechanism was added for liquidators. The form of the incentive is, on a per-collateral type basis, a constant amount of DAI plus an amount of DAI that scales linearly with the amount of debt associated with the liquidation. Either contribution can be set to zero. Such a structure is justified by the following:\nThe reward is set per-collateral to give maximum flexibility to include not just per-collateral risk parameters like \nmat\n (collateralization ratio) and \nchop\n (liquidation penalty) in its setting, but also to allow for unique market conditions that might only apply to one or a few collateral types.\nThe component of the reward that increases linearly with the total Vault debt is intended to be used to reward liquidators for reducing risk to the system, as risk itself scales with the size of undercollateralized Vaults\u2014a Vault that is twice as big as another represents twice the risk of bad debt accrual. Or viewed another way, liquidating two vaults of size X represents the same risk reduction as liquidating one Vault of size 2X\u2014thus the reward to a liquidator ought to be similar. Further, the system can \nafford\n to pay more for larger liquidations, because the liquidation penalty is also proportional to the amount of debt outstanding for a given Vault.\nThe constant component of the reward can be used to cover gas costs (which are per-Vault for liquidators) or to allow MKR holders to effectively pay Keepers to clear small Vaults that would otherwise not be attractive for liquidation.\nThese parameters must be set extremely carefully, lest it be possible to exploit the system by \"farming\" liquidation rewards (e.g. creating Vaults with the intention of liquidating them and profiting from the too-high rewards). Generally, the liquidation reward should remain less than the minimum liquidation penalty by some margin of safety so that the system is unlikely to accrue a deficit. This doesn't necessarily prevent farming, it just helps ensure the system remains solvent. For example, incentives can be farmed in a capital-efficient way when \nDirt\n is close to \nHole\n or when \nilk.dirt\n is close to \nilk.hole\n for some collateral type. An attacker would purchase a small amount of collateral from a running auction, freeing up a small amount of room relative to either \nHole\n or \nilk.hole\n, then liquidate a small portion of an existing Vault to collect the reward, and repeat the process. This can be done over and over in the same transaction, and the activation of EIP 2929 (scheduled for the Berlin hard fork at the time of writing) will significantly reduce the associated gas costs (due to warm storage reads and writes). Note that since the attacker does not need to create their own Vaults, the size of the liquidation penalty in relation to the incentive value is not a deterrent; only gas costs matter to the attacker. The fact that the Dog prevents partial liquidations that remove less than \nilk.dust\n debt from a Vault helps to mitigate this scenario--so long as the liquidation penalty exceeds the total reward for this minimal liquidation size, \nand the liquidation penalty is reliably collected by the resulting auction\n (which may not hold under conditions of market or network perturbation), the system should not on balance accrue bad debt.\nFour-Stage Liquidation Circuit Breaker\nIn this section, we'll cover the four stages of the liquidation circuit breaker. In contrast to \nLIQ-1.2\n, Liquidations 2.0 comes with a four-stage circuit breaker built into the \nClipper\n contract. The stages are:\nliquidations enabled\n(\n0\n): This means the breaker is not tripped and the protocol can liquidate new Vaults as well as service old liquidations.\nnew liquidations disabled\n(\n1\n): This means no new liquidations (\nClipper.kick\n).\nnew liquidations and resets disabled\n(\n2\n): This means no new liquidations (\nClipper.kick\n), and auctions that have reached either a price or time endpoint cannot be reset (\nClipper.redo\n).\nliquidations disabled\n(\n3\n): This means no new liquidations (\nClipper.kick\n), no takes (\nClipper.take\n), and no resets (\nClipper.redo\n).\nJust like in \nLIQ-1.2\n, the circuit breaker will be available through a \nClipperMom\n contract giving governance the ability to bypass the \nGSM\n delay for circuit breaker actions.\nBidding (Purchasing)\n\u200b\nhttps://github.com/makerdao/dss/blob/liq-2.0/src/clip.sol\n\u200b\nThe purchasing function (\nClipper.take\n) takes five caller supplied arguments:\nid\n: the numerical id of the auction to bid on\namt\n: the maximum amount of collateral to buy (\namt\n) \u2014 a purchase behaves like a limit order [wad]\nmax\n: the maximum acceptable price in DAI per unit collateral (\nmax\n) [ray]\nwho\n: address that will receive the collateral (\nwho\n)\ndata\n: an arbitrary bytestring (if provided, the address \nwho\n, if it is neither the \nDog\n nor \nVat\n address stored by the Clipper, is called as a contract via an interface described below, to which this data is passed) [bytes]\nClipper.take\n performs several initial checks:\na reentrancy check to ensure the function is not being recursively invoked\nthat the four-stage circuit breaker is not tripped\nthat the auction id corresponds to a valid auction\nthat the auction does not need to be reset, either due to having experienced too large a percentage decrease in price, or having existed for too long of a time duration\nthat the caller's specified maximum price is at least the current auction price\nThen, the amount of collateral to attempt to purchase is computed as the minimum of the collateral left in the auction (\nlot\n) and the caller's specified quantity (\namt\n)\u2014the resulting value is the \nslice\n. This value is then multiplied by the current price of the auction to compute the DAI owed in exchange (\nowe\n). If \nowe\n exceeds the DAI collection target of the auction (\ntab\n), then \nowe\n is adjusted to be equal to \ntab\n, and \nslice\n is set to \ntab / price\n (i.e. the auction will not sell more collateral than is needed to cover debt+fees from the liquidated Vault).\nTo make it less likely that auctions are left in a state that is unattractive to bid on, further logic is applied if there will be both left over DAI target and collateral based on the initial determinations for \nslice\n and \nowe\n. If the remaining \ntab\n in such a case would be less than \nchost\n (a value stored by the contract, asynchronously set to \nilk.dust * ilk.chop / WAD\n by the \nupchost()\n function), then: 1) If the overall DAI target is less than \nchost\n, \nthe function reverts. Callers should be aware of this possibility and account for it when necessary.\n 2) Otherwise, \nowe\n is set to \ntab - chost\n, and \nslice\n is set to \n(tab - chost) / price\n.\nThis heuristic for preventing a too-small remaining collateral amount and/or DAI target is imperfect and may fail in some situations; if this occurs, there is no serious harm to the protocol; the auction will simply remain uncompleted. However, governance may wish to fully clear such \"lost\" auctions via \ntake\n or \nyank\n to avoid cluttering the list of active auctions each \nClipper\n maintains, which could impair the performance of DEX and aggregator integrations (and possibly off-chain bots too, depending on how they are written).\nNext, collateral is transferred (within the protocol's \naccounting module\n) to the \nwho\n address provided by the caller. If the caller provided a bytestring with greater than zero length, an external call is made to the \nwho\n address, assuming it exposes a function, follow Solidity conventions, with the following signature:\nclipperCall\n(\n    address\n,\n \n// recipient of DAI\n    uint256\n,\n \n// owe   [rad]\n    uint256\n,\n \n// slice [wad]\n    bytes calldata\n)\nThe first argument is the recipient of DAI. That is, this is the address the \nclipperCallee\n must return DAI to. The second argument is DAI owed (as a 45 decimal digit fixed-precision integer, or \nrad\n), the third argument is the collateral being purchased (as an 18 decimal digit fixed-precision integer, or \nwad\n), regardless of the precision of the external token contract, and the last argument is identical to what bytestring the caller originally supplied to the purchase function. As mentioned earlier, a locking mechanism prevents reentry into the purchase function during this external call, and the \nClipper.redo\n call, for security reasons. Example implementations of the \nClipperCallee\n interface can be found in the \nexchange-callees\n repository.\nAfter the external call completes (or immediately following the transfer of collateral, if no external call was executed), DAI is transferred (internally, within the core \naccounting module\n) from \nmsg.sender\n to the protocol.\nLastly, various values are updated to record the changed state of the auction: the DAI needed to cover debt and fees for outstanding auctions, and outstanding auctions of the given collateral type, are reduced (via a callback to the liquidator contract) is reduced by \nowe\n, and the \ntab\n (DAI collection target) and \nlot\n (collateral for sale) of the auction are adjusted as well. If all collateral has been drained from an auction, all its data is cleared and it is removed from the active auctions list. If collateral remains, but the DAI collection target has been reached, the same is done and excess collateral is returned to the liquidated Vault.\nExample Liquidation\nFigure 1\n: NOTE: in the above figure, \ntau\n is \ntail\n.\nIn this example we can see a linear decrease function (\ncalc\n), with an \nETH-A\n OSM price of \n200 DAI\n, a \nbuf\n of \n20%\n, a \ntail (tau)\n of \n21600\n seconds, a \ntab\n of \n*60,000 DAI\n with a \nlot\n of \n347.32\n ETH. There are two bidders, \nAlice\n and \nBob\n. \nAlice\n calls \ntake\n first and is willing to give \n*50,000 DAI\n in return for \n256.41\n ETH collateral, a price of \n195 DAI\n per ETH. The price of ETH continues to fall over time, and \nBob\n picks up the remaining \n90.91\n ETH for \n10,000 DAI\n, a price of \n110 DAI\n per ETH. If more than \ntail\n seconds have elapsed since the start of the auction, or if the price has fallen to less than \ncusp\n percent of \ntop\n, then \nClipper.take\n would revert if called, and the auction would need to be reset with a \nClipper.redo\n call.\nIncentive to call \nredo()\n\u200b\nhttps://github.com/makerdao/dss/blob/liq-2.0/src/clip.sol\n\u200b\nThe auction initiation function (\nClipper.redo\n) takes two caller supplied arguments:\nid\n: the current auction id\nkpr\n: the address where DAI incentives will be sent\nClipper.redo\n performs several checks and actions:\na reentrancy check to ensure the function is not being recursively invoked\nthat the four-stage circuit breaker is not tripped\nthat the auction id corresponds to a valid auction\nthat the auction needs to be reset, either due to having experienced too large a percentage decrease in price, or having existed for too long of a time duration\nupdates several fields of the existing auction\ntic\n to reset the auction start time\ntop\n with the current OSM price and \nbuf\n percent\nvat.suck\ns DAI to the \nkpr\n as an incentive if eligible\nfires the \nRedo()\n event\nAn auction that has expired or which is currently offered at a value higher than the oracle threshold will likely not complete at favorable values. The system therefore provides a direct incentive to \nClipper.redo\n the auction, resetting it's expiration and setting the starting price to match the current oracle price + buf. The redo includes the same Dai incentive to the keeper as the \nClipper.kick\n, which is based on the flat fee plus the governance-defined percentage of collateral. There is one exception to this incentive. If the \ntab\n or \nlot * price\n remaining is under the \nClipper.chost\n limit, then there will be no incentive paid to \nredo\n the auction. This is to help prevent incentive farming attacks where no keepers bid on dusty lots, and \nClipper.redo\n is called repeatedly. If auctions in this state build up, governance may choose to pay a keeper to clean them up.\nEmergency Shutdown\n\u200b\nhttps://github.com/makerdao/dss/blob/liq-2.0/src/end.sol\n\u200b\nA started auction can be reverted via the \nauth\n function called \nyank\n in \nClipper\n contract. This function requires that the auction exists and executes the following actions:\ncalls \ndog.digs\n in order to decrease its \nDirt\n and \nilk.dirt\n values by the remaining auction \ntab\nsends the remaining collateral to its \nmsg.sender\nremoves the auction struct data\nfires the \nYank()\n event\nThis function might be thought of as a general purpose operation to migrate existing auctions to a new contract; however, the only use-case now is in the \nEnd\n module, which takes care of system shutdown.\nThe \nEnd\n module will be upgraded together with the auction contracts as a new function \nEnd.snip\n is required.\nThis function \nEnd.snip\n is responsible for calling \nClipper.yank\n for any running auction when shutdown is triggered. It will receive the collateral from \nClipper.yank\n and will send it back to the vault owner together with the remaining debt to recover. One consideration to note is that the debt that the vault owner will receive includes the liquidation penalty part already charged.\nInterfaces\nDog\n Interface\nfunction wards(address) external view returns (uint256);\nfunction rely(address) external;\nfunction deny(address) external;\nStandard MakerDAO authorization structure.\nfunction vat() external view returns (address);\nfunction vow() external view returns (address);\nDSS core address introspection.\nfunction ilks(bytes32 ilk) external view returns (\n    address clip,\n    uint256 chop,   // wad\n    uint256 hole,   // rad\n    uint256 dirt);  // rad\nReturns values configured for a given ilk (ex. \nETH-A\n).\nfunction live() external view returns (uint256);\nReturns \n1\n if the system is active.\nfunction Hole() external view returns (uint256);\nfunction Dirt() external view returns (uint256);\nGetters for the global Hole and Dirt configuration. Both return a rad-precision value.\nfunction file(bytes32 what, address data) external;\nfunction file(bytes32 what, uint256 data) external;\nfunction file(bytes32 ilk, bytes32 what, address data) external;\nfunction file(bytes32 ilk, bytes32 what, uint256 data) external;\n(Authenticated) Parameter modification functions, available to governance. The precision for a numeric argument should match the parameter being set.\nfunction chop(bytes32 ilk) external view returns (uint256);\nGetter for the \nchop\n value of a given \nilk\n. \nchop\n has wad precision.\nfunction bark(bytes32 ilk, address urn, address kpr)\n    external returns (uint256 id);\nThe main liquidation function. Initiates an auction. A keeper calls this function to begin the auction of \nurn\n for a particular \nilk\n. \nkpr\n is the address where the keeper incentive is sent, allowing keepers to have liquidation rewards sent to a different address than the caller.\nfunction digs(bytes32 ilk, uint256 rad) external;\n(Authenticated) Removes collateral from the accumulator. Called by the \nClipper\n. The \nrad\n argument has rad precision.\nfunction cage() external;\n(Authenticated) Deactivates the \nDog\n and sets \nlive\n to 0.\nClipper\n Interface\nfunction wards(address) external view returns (uint256);\nfunction rely(address) external;\nfunction deny(address) external;\nStandard MakerDAO authorization structure.\nfunction ilk() external view returns (bytes32);\nThe ilk that this Clipper is associated with.\nfunction dog() external view returns (address);\nfunction vow() external view returns (address);\nfunction spotter() external view returns (address);\nDSS core address introspection.\nfunction calc() external view returns (address);\nThe address of the pricing function used by this Clipper.\nfunction buf() external view returns (uint256);   // ray\nfunction tail() external view returns (uint256);  // seconds\nfunction cusp() external view returns (uint256);  // ray\nfunction chip() external view returns (uint256);  // wad\nfunction tip() external view returns (uint256);   // rad\nGetters for governance-configured auction parameters.\nfunction chost() external view returns (uint256);  // rad\nGetter for the stored product of \nVat.ilk.dust\n and \nDog.ilk.chop\n. This value is used as a heuristic for whether a partial purchase will leave an auction with too little collateral and whether incentives should be given out when \nredo\n is called.\nfunction kicks() external view returns (uint256);\nAuction counter. Increments each time an auction is initiated.\nfunction active(uint256 pos) external view returns (uint256);\nReturns the id of the auction at index \npos\n in the list of active auctions.\nfunction sales(uint256) external view returns (\n        uint256 pos,\n        uint256 tab,   // rad\n        uint256 lot,   // wad\n        address usr,\n        uint96  tic,   // Unix epoch\n        uint256 top);  // ray\nReturns information on a particular auction. Completed auctions are removed from the mapping.\nfunction stopped() external view returns (uint256);\nReturns the current circuit breaker status. \n0\n for all functions allowed, \n1\n if \nkick\n cannot be called, \n2\n if \nkick\n and \nredo\n cannot be called, and \n3\n if \nkick\n, \nredo\n and \ntake\n cannot be called.\nfunction file(bytes32 what, address data) external;\nfunction file(bytes32 what, uint256 data) external;\n(Authenticated) Parameter modification functions, available to governance. Numeric arguments should match the precision of the parameter being set.\nfunction kick(uint256 tab, uint256 lot, address usr, address kpr)\n    external returns (uint256 id);\n(Authenticated) Initiates the auction. Called by the \nDog\n. \ntab\n is rad-precion, \nlot\n is wad-precision.\nfunction redo(uint256 id, address kpr) external;\nCalled to reset an auction due to expiry or price deviation.\nfunction take(\n    uint256 id,\n    uint256 amt,  // wad\n    uint256 max,  // ray\n    address who,\n    bytes calldata data) external;\nCalled to purchase collateral.\nfunction list() external view returns (uint256[] memory);\nfunction count() external view returns (uint256);\nHelpers for iterating the list of active auctions. Use \nlist()\n to get the unsorted array of auctions. Get the number of active auctions with \ncount()\n. The function \nactive(uint256 pos)\n (see above) can be used to access individual entries without needing to call \nlist()\n.\nfunction getStatus(uint256 id) external view returns (bool needsRedo, uint256 price);\nReturns a bool if the auction is eligible for redo and the current price.\nfunction upchost() external;\nUpdates the \nchost\n value stored in the contract to equal the product of \nVat.ilk.dust\n and \nDog.ilk.chop\n (the precision of the final value is rad). This allows \ntake\n and \nredo\n to obtain \nchost\n with a single \nSLOAD\n (reading \ndust\n from the \nVat\n requires 5 \nSLOAD\n operations due to how the API is structured, and reading \nchop\n is an additional \nSLOAD\n).\nfunction yank(uint256 id) external;\n(Authenticated) Allows an auction to be removed during Emergency Shutdown or via a goveranance action.\n4. Known Risks\nThis section covers some of the known risks with Liquidations 2.0\nIncentive Farming\nPeriodically, governance may increase the \nilk.dust\n amount. When this happens, it's usually because gas has become so expensive it impacts the efficiency of liquidations. That is, the cost of calling \nDog.bark()\n, \nClipper.take()\n, or \nClipper.redo()\n may exceed the collateral offered. Incentives may be used as a remedy to this potential issue and possibly a way for the protocol to keep \nilk.dust\n lower; however, governance must take care when increasing the \nilk\ns \ndust\n, \ntip\n, or \nchip\n not to incentivize the creation of many Vaults to farm this incentive. An example of an exploit is as follows:\n1.\ngovernance decides to increment \ndust\n by \n1500 DAI\n at the same time they scale \nilk.tip\n to subsidize auctions.\n2.\nan attacker realizes it would be profitable between gas and the \nchop\n to shard (\nfork\n) their existing Vault into many Vaults or create many new Vaults.\n3.\nthe spell is voted on and passed\n4.\nusing one transaction the attacker puts their Vaults at the edge of unsafe, \npoke()\ns the OSM when next price is going down, then calls \nDog.bark()\n on all their Vaults to collect the incentive.\n5.\nUsing the gains, they can also slightly overbid for their Vaults auctions.\nIn order to thwart this attack governance must be careful when setting \nilk.tip\n and \nilk.chip\n so as not to create this perverse incentive.\nPrice Decreases Too Quickly\nIf the price decreases too quickly it can have the following consequences:\nthe auction ends without any bid, then it needs to be reset and possibly this will keep happening\nbidders end up having reverts due the auction ended before tx confirmation\nbidders end up paying much less than what they were willing to pay (possibly generating permanent bad debt)\nPrice Decreases Too Slowly\nIf the price decreases too slowly it can have the following consequences:\nAuction price never catches up with the market price, eventually being reset\nAfter the reset the price catches up, but is less than an optimal market price\nAfter the reset the price catches up, but still leaves bad debt\nAfter the reset the auction price still might not catch up, causing more resets and very likely leaving bad debt\nFront-Running\nIn \nLIQ-1.2\n there is limited front-running risk as it requires capital to participate in auctions; however, in liquidations 2.0 if a keeper chooses to participate with no capital, there is substantial front-running risk from generalized front-running bots. The easier it is to replace the \nfrom\n address of the transaction with one's own, the greater the risk. To mitigate this risk keepers are encouraged to used authorized proxy contracts to interact with liquidations 2.0 and provide some amount of their own capital when bidding. More aggressive gas prices may also work. Unfortunately, we found no great way to prevent generalized front-running that preserves single-block composability.\nOSM Risk for Start Price\nBecause \nClipper.kick\n and \nClipper.redo\n consult the OSM for the collateral price, we are vulnerable to an oracle attack that can only be mitigated by the oracle delay, \nDog.Hole\n, and \nilk.hole\n. We must rely on the number of guards in place to prevent price manipulation and oracle attacks. The fact that the price is delayed by one hour, however, prseents a risk of its own: since the price is out-of-date relative to the market, it may be either too high or too low to allow for efficient settlement given other parameters like 'buf' and the price decrease function. The consequences of either case are effectively covered by the sections on the risk of the price decreasing either too quickly or too slowly.\nSetting Hole or ilk.hole Too High\nWhile \nDog.Hole\n and \nilk.hole\n can be set much higher in liquidations 2.0, there are still risks to setting this too high. A value for \nDog.Hole\n that's set too high could result in far too much DAI demand, breaking the peg high. This is somewhat mitigated by the PSM and stablecoin collateral types, but should still factor in to how this parameter is set. An \nilk.hole\n that is set too high, may have the additional result of causing a downward spiral as the liquidations push the asset price lower. In addition, if there is an oracle attack, this parameter can be thought of as our maximum exposure.\nSetting Hole or ilk.hole Too Low\nIf we set either \nDog.Hole\n or \nilk.hole\n too low, we run the risk of not being able to liquidate enough collateral at once. This could lead to a buildup of undercollateralized positions in the system, eventually causing the accrual of bad debt.\nAuction Parameter Changes Affect Running Auctions\nParameters, e.g. \ntail\n, \ncusp\n, or the price decrease function or any of its parameters, can be changed at any time by governance and will affect the behavior of running auctions. Integrators should take this possibility into account, reasoning through how sudden changes in parameters would impact their bidding strategies. Governance should endeavor to change parameters infrequently and if possible, only when there are not any auctions that will be affected.\n5. Invariants\nThese invariants have not yet been formally proven, and thus should only be considered intended behavior for now.\nDog\n Invariants\nsum_over_all_ilks(Dog.ilk.dirt) == Dog.Dirt                             (c26.1)\nClipper\n Invariants\nsum_over_auction_ids(Clipper.sales[id].lot) <= Vat.gem(Clipper)         (c27.1)\nThe above is an inequality (and not an \nequality\n) because it is impossible to prevent a user or contract from choosing to send collateral to a \nClipper\n, even though it only makes sense for the \nDog\n to do so. Governance (or a new module) could create a violation of this property by calling \nkick\n without transferring appropriate collateral to the \nClipper\n. Thus this is actually a pseudo-invariant that only holds if callers of \nkick\n respect the requirement to send collateral to the \nClipper\n, but it should hold for the live system if deployment and authorization is done correctly. It should hold if only active auctions are summed over as well.\nInvariants involving quantities from both the \nDog\n and \nClipper\nsum_over_auctions_ids_and_ilks(Dog.ilk.clip.sales[id].tab) == Dog.Dirt  (c28.1)\nThe above should hold if only active auctions are summed over as well.\nsum_over_auctions_ids(Dog.ilk.clip.sales[id].tab) == Dog.ilk.dirt       (c28.2)\nThe above should hold if only active auctions are summed over as well.\nNote that (c28.1) and (c28.2) together imply (c26.1).\nPrevious\nJoin - Detailed Documentation\nNext\n - Smart Contract Modules\nSystem Stabilizer Module\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/dog-and-clipper-detailed-documentation", "title": "Liquidation 2.0 Module"}}
{"page_content": "Flash Mint Module\nEnables any user to execute a flash mint of Dai.\nContract Name:\n flash.sol\nType/Category:\n DSS\n\u0420\u0452\u0406\nContract Source\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nEtherscan\n\u0420\u0452\u0406\n1. Introduction (Summary)\nThe \nFlash\n module allows anyone to mint Dai up to a limit set by Maker Governance with the one condition that they pay it all back in the same transaction with a fee. This allows anyone to exploit arbitrage opportunities in the DeFi space without having to commit upfront capital. \nFlash\n provides many benefits to the Dai ecosystem including, but not limited to:\nImproved market efficiencies for Dai.\nDemocratization of arbitrage - anyone can participate.\nExploits requiring a large amount of capital will be found quicker which makes the DeFi space safer overall.\nFees provide an income source for the protocol.\n2. Contract Details\nGlossary (Flash)\nDebt Ceiling\n: The maximum amount of Dai any single transaction can borrow. Encoded as \nline\n in \nrad\n units.\nMinting Fees\n: How much additional Dai must be returned to the \nFlash\n module at the end of the transaction. This fee is transferred into the \nvow\n at the end of a successful \nmint\n. Encoded as \ntoll\n in \nwad\n units.\n3. Key Mechanisms & Concepts\nUsage\nSince the Flash module conforms to the ERC3156 spec, you can just use the reference borrower implementation from the spec:\npragma solidity ^0.8.0;\n\u0420\u0452\u0406\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\u0420\u0452\u0406\ncontract FlashBorrower is IERC3156FlashBorrower {\n    enum Action {NORMAL, OTHER}\n\u0420\u0452\u0406\n    IERC3156FlashLender lender;\n\u0420\u0452\u0406\n    constructor (\n        IERC3156FlashLender lender_\n    ) public {\n        lender = lender_;\n    }\n\u0420\u0452\u0406\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(\n            msg.sender == address(lender),\n            \"FlashBorrower: Untrusted lender\"\n        );\n        require(\n            initiator == address(this),\n            \"FlashBorrower: Untrusted loan initiator\"\n        );\n        (Action action) = abi.decode(data, (Action));\n        if (action == Action.NORMAL) {\n            require(IERC20(token).balanceOf(address(this)) >= amount);\n            // make a profitable trade here\n            IERC20(token).transfer(initiator, amount + fee);\n        } else if (action == Action.OTHER) {\n            // do another\n        }\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\u0420\u0452\u0406\n    /// @dev Initiate a flash loan\n    function flashBorrow(\n        address token,\n        uint256 amount\n    ) public {\n        bytes memory data = abi.encode(Action.NORMAL);\n        uint256 _allowance = IERC20(token).allowance(address(this), address(lender));\n        uint256 _fee = lender.flashFee(token, amount);\n        uint256 _repayment = amount + _fee;\n        IERC20(token).approve(address(lender), _allowance + _repayment);\n        lender.flashLoan(this, token, amount, data);\n    }\n}\nVat Dai\nIt may be that users are interested in moving dai around in the internal vat balances. Instead of wasting gas by minting/burning ERC20 dai you can instead use the vat dai flash mint function to short cut this.\nThe vat dai version of flash mint is roughly the same as the ERC20 dai version with a few caveats:\nFunction Signature\nvatDaiFlashLoan(IVatDaiFlashBorrower receiver, uint256 amount, bytes calldata data)\nvs\nflashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\nNotice that no token is required because it is assumed to be vat dai. Also, the \namount\n is in \nrad\n and not in \nwad\n.\nApproval Mechanism\nERC3156 specifies using a token approval to approve the amount to repay to the lender. Unfortunately vat dai does not have a way to specify delegation amounts, so instead of giving the flash mint module full rights to withdraw any amount of vat dai we have instead opted to have the receiver push the balance owed at the end of the transaction.\nExample\nHere is an example similar to the one above to showcase the differences:\npragma solidity ^0.6.12;\n\u0420\u0452\u0406\nimport \"dss-interfaces/dss/VatAbstract.sol\";\n\u0420\u0452\u0406\nimport \"./interfaces/IERC3156FlashLender.sol\";\nimport \"./interfaces/IVatDaiFlashBorrower.sol\";\n\u0420\u0452\u0406\ncontract FlashBorrower is IVatDaiFlashBorrower {\n    enum Action {NORMAL, OTHER}\n\u0420\u0452\u0406\n    VatAbstract vat;\n    IVatDaiFlashLender lender;\n\u0420\u0452\u0406\n    constructor (\n        VatAbstract vat_,\n        IVatDaiFlashLender lender_\n    ) public {\n        vat = vat_;\n        lender = lender_;\n    }\n\u0420\u0452\u0406\n    /// @dev Vat Dai Flash loan callback\n    function onVatDaiFlashLoan(\n        address initiator,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(\n            msg.sender == address(lender),\n            \"FlashBorrower: Untrusted lender\"\n        );\n        require(\n            initiator == address(this),\n            \"FlashBorrower: Untrusted loan initiator\"\n        );\n        (Action action) = abi.decode(data, (Action));\n        if (action == Action.NORMAL) {\n            // do one thing\n        } else if (action == Action.OTHER) {\n            // do another\n        }\n\u0420\u0452\u0406\n        // Repay the loan amount + fee\n        // Be sure not to overpay as there are no safety guards for this\n        vat.move(address(this), lender, amount + fee);\n\u0420\u0452\u0406\n        return keccak256(\"VatDaiFlashBorrower.onVatDaiFlashLoan\");\n    }\n\u0420\u0452\u0406\n    /// @dev Initiate a flash loan\n    function vatDaiFlashBorrow(\n        uint256 amount\n    ) public {\n        bytes memory data = abi.encode(Action.NORMAL);\n        lender.vatDaiFlashLoan(this, amount, data);\n    }\n}\nPrevious\nDSR Manager - Detailed Documentation\nNext\n - Smart Contract Modules\nMaker Protocol Emergency Shutdown\nLast modified \n3mo ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/flash-mint-module", "title": "Flash Mint Module"}}
{"page_content": "Governance Module\nThe Maker Protocol's Governance Contracts\nModule Name:\n Governance Module\nType/Category:\n Governance \u0432\u0496\u201d> Chief.sol, Pause.sol, Spell.sol\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\nContract Sources:\n\u0432\u0496\u04e2\nChief\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nPause\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nSpell\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe Governance Module contains the contracts that facilitate MKR voting, proposal execution, and voting security of the Maker Protocol.\n2. Module Details\nThe Governance Module has 3 core components consisting of the \nChief\n, \nPause\n and \nSpell\n contracts.\nGovernance Module Components Documentation\n\u0432\u0496\u04e2\nChief - Detailed Documentation\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nPause - Detailed Documentation\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nSpell - Detailed Documentation\n\u0432\u0496\u04e2\n3. Key Mechanism and Concepts\nSummary of the Governance \nModule Components\nChief\n - The Ds-Chief smart contract provides a method to elect a \n\"chief\"\n contract via an approval voting system. This may be combined with another contract, such as \nDSAuthority\n, to elect a ruleset for a smart contract system.\nPause\n - The \nds-pause\n is a \ndelegatecall\n based proxy with an enforced delay. This allows authorized users to schedule function calls that can only be executed once a predetermined waiting period has elapsed. The configurable delay attribute sets the minimum wait time that will be used during the governance of the system.\nSpell\n - A \nDS-Spell\n is an un-owned object that performs one action or series of atomic actions (multiple transactions) one time only. This can be thought of as a one-off DSProxy with no owner (no DSAuth mixing, it is not a DSThing).\n4. Gotchas (Potential sources of user error)\nChief\nIn general, when we refer to the \n\"chief\"\n, it can be both addresses or people that represent contracts. Thus, ds-chief can work well as a method for selecting code for execution just as well as it can for realizing political processes.\nIOU Token:\n The purpose of the IOU token is to allow for the chaining of governance contracts. In other words, this allows you to have a number of \nDSChief\n, \nDSPrism\n, or other similar contracts use the same governance token by means of accepting the IOU token of the \nDSChief\n contract before it is a governance token.\nApproval Voting:\n This type of voting is when each voter selects which candidates they approve of, with the top n \"most approved\" candidates being then elected. Each voter can cast up to n + k votes, where k equals some non-zero positive integer. Read more \nhere\n.\nImplementations:\n If you are writing a front-end UI for this smart contract, please note that the address[] parameters that are passed to the \netch\n and \nvote\n functions must be byte-ordered sets. Read more \nhere.\n\u0432\u0496\u04e2\nPause\nIdentity & Trust:\n In order to protect the internal storage of the pause from malicious writes during plan execution, a \ndelegatecall\n operation is performed in a separate contract with an isolated storage context (DSPauseProxy), where each pause has its own individual proxy. This means that plans are executed with the identity of the \nproxy\n. Thus when integrating the pause into some auth scheme, you will want to trust the pause's proxy and not the pause itself.\nSpell\nThe spell is only marked as \"done\" if the CALL it makes succeeds, meaning it did not end in an exceptional condition and it did not revert. Conversely, contracts that use return values instead of exceptions to signal errors could be successfully called without having the effect you might desire. \"Approving\" spells to take action on a system after the spell is deployed generally requires the system to use exception-based error handling to avoid griefing.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nChief\nMKR users moving their votes from one spell to another:\n One of the biggest potential failure modes occurs when people are moving their votes from one spell to another. This opens up a gap/period of time when only a small amount of MKR is needed to lift a random hat.\nPause\nThere is no way to bypass the delay.\nThe code executed by the \ndelegatecall\n cannot directly modify storage on the pause.\nThe pause will always retain ownership of it's proxy.\nRead more \nhere.\n\u0432\u0496\u04e2\nSpell\nThe main failure mode of the \nspell\n arises when there is an instance of the spell remaining uncast when it has an amount of MKR voting for it that later becomes a target.\nSmart Contract Modules - \nPrevious\nMKR Module\nNext\nSpell - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/governance-module", "title": "Governance Module"}}
{"page_content": "MKR Module\nThe MKR Governance Token Implementation\nContract Name:\n token.sol\nType/Category:\n MKR Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe MKR Module contains the MKR token, which is a deployed \nDs-Token\n contract. It is an ERC20 token that provides a standard ERC20 token interface. It also contains logic for burning and authorized minting of MKR.\nMKR Interactions with the Maker Protocol\n2. Contract Details:\nGlossary (MKR)\nguy\n - user address\nwad\n - a quantity of tokens, usually as a fixed point integer with 10^18 decimal places.\ndst\n - refers to the destination address.\nKey Functionalities (as defined in the smart contract)\nmint\n - credit tokens at an address whilst simultaneously increasing totalSupply (requires auth).\nburn\n - debit tokens at an address whilst simultaneously decreasing totalSupply (requires auth).\nAliases\n \npush\n - transfer an amount from msg.sender to a given address.\npull\n - transfer an amount from a given address to msg.sender (requires trust or approval).\nmove\n - transfer an amount from a given src address to a given dst address (requires trust or approval).\nStandard ERC-20\nname\n - returns the name of the token - e.g. \"MyToken\".\nsymbol\n - token symbol.\ndecimals\n - returns the number of decimals the token uses - e.g. \n8\n, means to divide the token amount by \n100000000\n to get its user representation.\ntransfer\n - transfers \n_value\n amount of tokens to \naddress _to\n, and \nMUST\n fire the Transfer event. This \nSHOULD\n throw if the message caller\u0432\u0496\u04b7s account balance does not have enough tokens to spend.\ntransferFrom\n - transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\napprove\n - allows \n_spender\n to withdraw from your account multiple times, up to the \n_value\n amount. If this function is called again it overwrites the current allowance with \n_value\n.\ntotalSupply\n - returns the total token supply.\nbalanceOf\n - returns the account balance of another account with \naddress _owner\n.\nallowance\n - returns the amount which \n_spender\n is still allowed to withdraw from \n_owner\n.\nFurther information about the ERC20 Token standard can be found \nhere\n.\nImportant note:\n there is a \ntransferFrom\n auto approval when \nsrc == msg.sender\n.\n3. Key Mechanisms & Concepts\nAlong with MKR having a standard ERC20 token interface, it also has the addition of DSAuth-protected mint and burn functions; binary approval via MAX_UINT; as well as a push, pull and move aliases for transferFrom operations.\nThe MKR token has 3 methods of use within the Maker Protocol (reference \nMaker Protocol 101 Presentation\n):\nAs a utility token:\n As Dai stability fees earned on Vaults accrue within the Maker Protocol, MKR holders can use MKR to vote to enable the Flapper auction house to sell Dai surplus for MKR. Once the auction is complete the Maker protocol burns the MKR.\nAs a governance token:\n MKR is used by MKR holders to vote for the risk management and business logic of the Maker Protocol. Tokens are a simple representation of voting power.\nAs a recapitalization resource:\n MKR can autonomously be minted by the Flopper auction house and sold for DAI, which is used to recap the Maker Protocol in times of insolvency.\n4. Gotchas (Potential source of user error)\nThe MKR token is an ERC-20 token created using DSToken. A key difference to note between Dai and most other popular ERC20 tokens is that both these fields use \nbytes32\n instead of the \nstring\n type.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nMKR.stop\n - ES cannot be triggered. MKR in the chief can still vote, but cannot join or exit.\nPrevious\nMedian - Detailed Documentation\nNext\n - Smart Contract Modules\nGovernance Module\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/mkr-module", "title": "MKR Module"}}
{"page_content": "Oracle Module\nThe Maker Protocol's Oracles\nModule Name:\n Oracle Module\nType/Category:\n Oracles \u2014> OSM.sol & Median.sol\n\u200b\nAssociated MCD System Diagram\n\u200b\nContract Sources:\n\u200b\nMedian\n\u200b\n\u200b\nOSM\n\u200b\n1. Introduction (Summary)\nAn oracle module is deployed for each collateral type, feeding it the price data for a corresponding collateral type to the \nVat\n. The Oracle Module introduces the whitelisting of addresses, which allows them to broadcast price updates off-chain, which are then fed into a \nmedian\n before being pulled into the \nOSM\n. The \nSpot\n'ter will then proceed to read from the \nOSM\n and will act as the liaison between the \noracles\n and \ndss\n.\n2. Module Details\nThe Oracle Module has 2 core components consisting of the \nMedian\n and \nOSM\n contracts.\nOracle Module Components Documentation\n\u200b\nMedian Documentation\n\u200b\n\u200b\nOSM Documentation\n\u200b\n3. Key Mechanism and Concepts\nInteraction Diagram (Credit: MCD-101 Presentation, by Kenton Prescott)\nSummary of the Oracle \nModule Components\nThe \nMedian\n provides Maker's trusted reference price. In short, it works by maintaining a whitelist of price feed contracts which are authorized to post price updates. Every time a new list of prices is received, the median of these is computed and used to update the stored value. The median has permissioning logic which is what enables the addition and removal of whitelisted price feed addresses that are controlled via governance. The permissioning logic allows governance to set other parameters that control the Median's behavior\u2014for example, the \nbar\n parameter is the minimum number of prices necessary to accept a new median value.\nThe \nOSM\n (named via acronym from \"Oracle Security Module\") ensures that new price values propagated from the Oracles are not taken up by the system until a specified delay has passed. Values are read from a designated \nDSValue\n contract (or any contract that implements the \nread()\n and \npeek()\n interface) via the \npoke()\n method; the \nread()\n and \npeek()\n methods will give the current value of the price feed, and other contracts must be whitelisted in order to call these. An OSM contract can only read from a single price feed, so in practice one OSM contract must be deployed per collateral type.\n4. Gotchas (Potential sources of user error)\nRelationship between the OSM and the Median:\nYou can read straight from the median and in return, you would get a more real-time price. However, this depends on the cadence of updates (calls to poke).\nThe OSM is similar but has a 1-hour price delay. It has the same process for reading (whitelist, auth, read and peek) as a median. The way the OSM works, is you cannot update it directly but you can \npoke\n it to go and read from something that also has the same structure (the \npeek\n method - in this case, its the median but you can set it to read from anything that conforms to the same interface).\nWhenever the OSM reads from a source, it queues the value that it reads for the following hour or following \nhop\n property, which is set to 1 hour (but can be anything). When it is \npoke\n'd, it reads the value of the median and it will save the value. Then the previous value becomes that, so it is always off by an hour. After an hour passes, when \npoke\nd, the value that it saved becomes the current value and whatever value is in the median becomes the future value for the next hour.\nspot\n - if you poke it with an ilk (ex: ETH) it will read form the OSM and if the price is valid, it updates.\nRelationship to the \nSpot\n'ter:\nIn relation to the \nSpot\n the oracle module handles how market prices are recorded on the blockchain. The \nSpot\nter operates as the interface contract, which external actors can use to retrieve the current market price from the Oracle module for the specified collateral type. The \nVat\n in turn reads the market price from the \nspot\nter.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nMedian\n - there is currently no way to turn off the oracle (failure or returns false) if all the oracles come together and sign a price of zero. This would result in the price being invalid and would return false on \npeek\n, telling us to not trust the value.\nOSM\npoke()\n is not called promptly, allowing malicious prices to be swiftly uptaken.\nAuthorization Attacks and Misconfigurations.\nRead more \nhere.\n\u200b\nPrevious\nVow - Detailed Documentation\nNext\nOracle Security Module (OSM) - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/oracle-module", "title": "Oracle Module"}}
{"page_content": "Proxy Module\nAllowing Users to interact with the Maker Protocol more easily\nModule Name:\n Proxy Module\nType/Category: Proxy \u0432\u0496\u201d>\n DsrManager.sol, DssCdpManager.sol, VoteProxy.sol & DssProxyActions.sol\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\nSource code:\n\u0432\u0496\u04e2\nDSR Manager\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nCDP Manager\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nVote Proxy\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nProxy Actions\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe Proxy module was created in order to make it more convenient for users/developers to interact with the Maker Protocol. It contains contract interfaces, proxies, and aliases to functions necessary for both DSR and Vault management and Maker governance.\n2. Module Details\nProxy Module Components Documentation\n1.\n\u0432\u0496\u04e2\nDSR Manager - Detailed Documentation\n\u0432\u0496\u04e2\n2.\n\u0432\u0496\u04e2\nCDP Manager - Detailed Documentation\n\u0432\u0496\u04e2\n3.\n\u0432\u0496\u04e2\nVote Proxy - Detailed Documentation\n\u0432\u0496\u04e2\n4.\n\u0432\u0496\u04e2\nProxy Actions - Detailed Documentation\n\u0432\u0496\u04e2\n3. Key Mechanism and Concepts\nWhy are these components important to the Multi-Collateral Dai (MCD) System?\nDSR Manager\nThe \nDsrManager\n provides an easy to use smart contract that allows service providers to deposit/withdraw \ndai\n into the contract \npot\n, to start earning the Dai Saving Rate on a pool of dai in a single function call without the need of a \nds-proxy\n contract. This is useful for smart contracts integrating DSR functionality. \nCDP Manager\nThe \nDssCdpManager\n (aka \nmanager\n) was created to enable a formalized process for Vaults to be transferred between owners. In short, the \nmanager\n works by having a \ndss\n wrapper that allows users to interact with their Vaults in an easy way, treating them as non-fungible tokens (NFTs).\nVote Proxy\nThe VoteProxy \nfacilitates online voting with offline MKR storage\n. By having a VoteProxy, this allows users to have a linked hot wallet that can pull and push MKR from the proxy\u0432\u0496\u04b7s corresponding cold wallet and to DS-Chief, where voting can take place with the online hot wallet.\nThere are two main reasons to have/use this contract:\n1.\nTo support two different voting mechanisms\n2.\nTo minimize the time that MKR owners need to have their wallet online.\nProxy Actions\nThe \ndss-proxy-actions\n was designed to be used by the Ds-Proxy, which is owned individually by users to interact more easily with the Maker Protocol. Note that it is not intended to be used directly (this will be covered later). The dss-proxy-actions contract was developed to serve as a library for user's ds-proxies.\nIn general, the ds proxy receives two parameters:\nProxy library address\nIn this case, the dss proxy actions library.\nCall data\nFunctions and parameters you want to execute.\n4. Gotchas (Potential sources of user error)\nDSR Manager\nFor developers who want to integrate with \nDsrManager\n, it is important to realize that user balances in the \npot\n will be owned by the \nDsrManager\n, which has an internal mapping to determine user balances. Consequently the deposited Dai in DSR might not show up in solutions that are based on \nds-proxy\n (such as \noasis.app/save\n)\nRead more \nhere\n.\nCDP Manager\nFor the developers who want to integrate with the \nmanager\n, they will need to understand that the Vault actions are still in the \nurn\n environment. Regardless of this, the \nmanager\n tries to abstract the \nurn\n usage by a \nCDPId\n. This means that developers will need to get the \nurn\n (\nurn = manager.urns(cdpId)\n) to allow the \njoin\ning of collateral to that Vault.\nRead more \nhere\n.\nVote Proxy\nOne-time proxy setup cost:\n As a new proxy contract user, you will need to set it up before you can use it for future voting. The price of the setup will depend on the current Ethereum gas price but will ultimately make voting easier and safer for users.\nRead more \nhere\n.\nProxy Actions\nUsing dss-proxy-actions directly can result in the loss of control over your Vault:\n If you open a new Vault via the dss proxy actions (centralized) without a ds proxy you would be creating a Vault that is owned by the dss proxy actions that anyone could call publicly. It would be owned by the dss proxy actions contact and anyone could execute actions on your Vault. Therefore, if you use the dss proxy actions directly it can be quite risky.\nRead more \nhere\n.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nCDP Manager\nPotential Issues around Chain Reorganization\nWhen \nopen\n is executed, a new \nurn\n is created and a \ncdpId\n is assigned to it for a specific \nowner\n. If the user uses \njoin\n to add collateral to the \nurn\n immediately after the transaction is mined, there is a chance that a reorganization of the chain occurs. This would result in the user losing the ownership of that \ncdpId\n/\nurn\n pair, therefore losing their collateral. However, this issue can only arise when avoiding the use of the \nproxy functions\n via a \nprofile proxy\n as the user will \nopen\n the \ncdp\n and \njoin\n collateral in the same transaction.\nRead more \nhere\n.\nVote Proxy\nThe loss of private keys for both the hot and cold wallet will prevent you from voting.\nProxy Actions\nDs proxy is a general purpose proxy / there is always a risk when using a proxy\nIn terms of failure modes, this means you can execute a malicious proxy action as well as a direct action that could potentially send your ETH to a random address. To be extra cautious, you should check your wallets call data and/or audit what your wallet does as they could potentially present users with some unwanted random call data and execute unwanted actions.\nRead more here (link)\nPrevious\nJug - Detailed Documentation\nNext\nProxy Actions - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/proxy-module", "title": "Proxy Module"}}
{"page_content": "Rates Module\nThe Maker Protocol's Rate Accumulation Mechanism\nModule Name:\n Rates Module\nType/Category:\n Rates\n\u0432\u0410\u041b\nAssociated MCD System Diagram\n\u0432\u0410\u041b\nContract Sources:\n\u0432\u0410\u041b\nJug\n\u0432\u0410\u041b\n\u0432\u0410\u041b\nPot\n\u0432\u0410\u041b\nIntroduction\nA fundamental feature of the MCD system is to accumulate stability fees on Vault debt balances, as well as interest on Dai Savings Rate (DSR) deposits.\nThe mechanism used to perform these accumulation functions is subject to an important constraint: accumulation must be a constant-time operation with respect to the number of Vaults and the number of DSR deposits. Otherwise, accumulation events would be very gas-inefficient (and might even exceed block gas limits).\nFor both stability fees and the DSR, the solution is similar: store and update a global \"cumulative rate\" value (per-collateral for stability fees), which can then be multiplied by a normalized debt or deposit amount to give the total debt or deposit amount when needed.\nThis can be described more concretely with mathematical notation:\nDiscretize time in 1-second intervals, starting from \nt\n_0;\nLet the (per-second) stability fee at time \nt\n have value \nF_i\n (this generally takes the form 1+\nx\n, where \nx\n is small)\nLet the initial value of the cumulative rate be denoted by \nR\n_0\nLet a Vault be created at time \nt_0\n with debt \nD\n_0 drawn immediately; the normalized debt \nA\n (which the system stores on a per-Vault basis) is calculated as \nD\n_0/\nR\n_0\nThen the cumulative rate \nR\n at time \nT\n is given by:\nR\n(\nt\n)\n\u0432\u0419\u00b0\nR\n0\n\u0432\u0418\u041f\ni\n=\nt\n0\n+\n1\nt\nF\ni\n=\nR\n0\n\u0432\u041b\u0415\nF\nt\n0\n+\n1\n\u0432\u041b\u0415\nF\nt\n0\n+\n2\n\u0432\u041b\u0453\nF\nt\n\u0432\u0418\u0422\n1\n\u0432\u041b\u0415\nF\nt\nR(t) \\equiv R_0 \\prod_{i=t_0 + 1}^{t} F_i = R_0 \\cdot F_{t_0 + 1} \\cdot F_{t_0 + 2} \\cdots F_{t-1} \\cdot F_t\n\n\nR\n(\nt\n)\n\u0432\u0419\u00b0\nR\n0\n\u0432\u0410\u041b\ni\n=\nt\n0\n\u0432\u0410\u041b\n+\n1\n\u0432\u0418\u041f\nt\n\u0432\u0410\u041b\nF\ni\n\u0432\u0410\u041b\n=\nR\n0\n\u0432\u0410\u041b\n\u0432\u041b\u0415\nF\nt\n0\n\u0432\u0410\u041b\n+\n1\n\u0432\u0410\u041b\n\u0432\u041b\u0415\nF\nt\n0\n\u0432\u0410\u041b\n+\n2\n\u0432\u0410\u041b\n\u0432\u041b\u0453\nF\nt\n\u0432\u0418\u0422\n1\n\u0432\u0410\u041b\n\u0432\u041b\u0415\nF\nt\n\u0432\u0410\u041b\nAnd the total debt of the Vault at time \nt\n would be:\nD\n(\nt\n)\n\u0432\u0419\u00b0\nA\n\u0432\u041b\u0415\nR\n(\nt\n)\n=\nD\n0\n\u0432\u0418\u041f\nt\n=\n1\nT\nF\ni\nD(t) \\equiv A \\cdot R(t) = D_0 \\prod_{t=1}^{T} F_i\n\nD\n(\nt\n)\n\u0432\u0419\u00b0\nA\n\u0432\u041b\u0415\nR\n(\nt\n)\n=\nD\n0\n\u0432\u0410\u041b\nt\n=\n1\n\u0432\u0418\u041f\nT\n\u0432\u0410\u041b\nF\ni\n\u0432\u0410\u041b\nIn the actual system, \nR\n is not necessarily updated with every block, and thus actual \nR\n values within the system may not have the exact value that they should in theory. The difference in practice, however, should be minor, given a sufficiently large and active ecosystem.\nDetailed explanations of the two accumulation mechanisms may be found below.\nStability Fee Accumulation\nOverview\nStability fee accumulation in MCD is largely an interplay between two contracts: the \nVat\n (the system's central accounting ledger) and the \nJug\n (a specialized module for updating the cumulative rate), with the \nVow\n involved only as the address to which the accumulated fees are credited.\nThe Vat stores, for each collateral type, an \nIlk\n struct that contains the cumulative rate (\nrate\n) and the total normalized debt associated with that collateral type (\nArt\n). The Jug stores the per-second rate for each collateral type as a combination of a \nbase\n value that applies to all collateral types, and a \nduty\n value per collateral. The per-second rate for a given collateral type is the sum of its particular \nduty\n and the global \nbase\n.\nCalling \nJug.drip(bytes32 ilk)\n computes an update to the ilk's \nrate\n based on \nduty\n, \nbase\n, and the time since \ndrip\n was last called for the given ilk (\nrho\n). Then the Jug invokes \nVat.fold(bytes32 ilk, address vow, int rate_change)\n which:\nadds \nrate_change\n to \nrate\n for the specified ilk\nincreases the \nVow\n's surplus by \nArt*rate_change\nincreases the system's total debt (i.e. issued Dai) by \nArt*rate_change\n.\nEach individual Vault (represented by an \nUrn\n struct in the Vat) stores a \"normalized debt\" parameter called \nart\n. Any time it is needed by the code, the Vault's total debt, including stability fees, can be calculated as \nart*rate\n (where \nrate\n corresponds to that of the appropriate collateral type). Thus an update to \nIlk.rate\n via \nJug.drip(bytes32 ilk)\n effectively updates the debt for all Vaults collateralized with \nilk\n tokens.\nExample With Visualizations\nSuppose at time 0, a Vault is opened and 20 Dai is drawn from it. Assume that \nrate\n is 1; this implies that the stored \nart\n in the Vault's \nUrn\n is also 20. Let the \nbase\n and \nduty\n be set such that after 12 years, \nart*rate\n = 30 (this corresponds to an annual stability of roughly 3.4366%). Equivalently, \nrate\n = 1.5 after 12 years. Assuming that \nbase + duty\n does not change, the growth of the effective debt can be graphed as follows:\nNow suppose that at 12 years, an additional 10 Dai is drawn. The debt vs time graph would change to look like:\nWhat \nart\n would be stored in the Vat to reflect this change? (hint: \nnot\n 30!) Recall that \nart\n is defined from the requirement that \nart * rate\n = Vault debt. Since the Vault's debt is known to be 40 and \nrate\n is known to be 1.5, we can solve for \nart\n: 40/1.5 ~ 26.67.\nThe \nart\n can be thought of as \"debt at time 0\", or \"the amount of Dai that if drawn at time zero would result in the present total debt\". The graph below demonstrates this visually; the length of the green bar extending upwards from t = 0 is the post-draw \nart\n value.\nSome consequences of the mechanism that are good to keep in mind:\nThere is no stored history of draws or wipes of Vault debt\nThere is no stored history of stability fee changes, only the cumulative effective \nrate\nThe \nrate\n value for each collateral perpetually increases (unless the fee becomes negative at some point)\nWho calls \ndrip\n?\nThe system relies on market participants to call \ndrip\n rather than, say, automatically calling it upon Vault manipulations. The following entities are motivated to call \ndrip\n:\nKeepers seeking to liquidate Vaults (since the accumulation of stability fees can push a Vault's collateralization ratio into unsafe territory, allowing Keepers to liquidate it and profit in the resulting collateral auction)\nVault owners wishing to draw Dai (if they don't call \ndrip\n prior to drawing from their Vault, they will be charged fees on the drawn Dai going back to the last time \ndrip\n was called\u0432\u0410\u0424unless no one calls \ndrip\n before they repay their Vault, see below)\nMKR holders (they have a vested interest in seeing the system work well, and the collection of surplus in particular is critical to the ebb and flow of MKR in existence)\nDespite the variety of incentivized actors, calls to \ndrip\n are likely to be intermittent due to gas costs and tragedy of the commons until a certain scale can be achieved. Thus the value of the \nrate\n parameter for a given collateral type may display the following time behavior:\nDebt drawn and wiped between \nrate\n updates (i.e. between \ndrip\n calls) would have no stability fees assessed on it. Also, depending on the timing of updates to the stability fee, there may be small discrepancies between the actual value of \nrate\n and its ideal value (the value if \ndrip\n were called in every block). To demonstrate this, consider the following:\nat t = 0, assume the following values:\nrate\n=\n1\n\u00ac\u2020;\u00ac\u2020total\u00ac\u2020fee\n=\nf\n\\text{rate} = 1 \\text{ ; total fee} = f\n\nrate\n=\n1\n\u00ac\u2020;\u00ac\u2020total\u00ac\u2020fee\n=\nf\nin a block with t = 28, \ndrip\n is called\u0432\u0410\u0424now:\nrate\n=\nf\n28\n\\text{rate} = f^{28}\n\nrate\n=\nf\n28\nin a block with t = 56, the fee is updated to a new, different value:\ntotalfee\n\u0432\u0416\u0422\ng\n\\text{totalfee}  \\xrightarrow{} g\ntotalfee\n\u0432\u0410\u041b\ng\nin a block with t = 70, \ndrip\n is called again; the actual value of \nrate\n that obtains is:\nrate\n=\nf\n28\ng\n42\n\\text{rate} = f^{28} g^{42}\n\nrate\n=\nf\n28\ng\n42\nhowever, the \"ideal\" \nrate\n (if \ndrip\n were called at the start of every block) would be:\nrate\ni\nd\ne\na\nl\n=\nf\n56\ng\n14\n\\text{rate}_{ideal} = f^{56}g^{14}\n\nrate\ni\nd\ne\na\nl\n\u0432\u0410\u041b\n=\nf\n56\ng\n14\nDepending on whether \nf\n > \ng\n or \ng\n > \nf\n, the net value of fees accrued will be either too small or too large. It is assumed that \ndrip\n calls will be frequent enough such inaccuracies will be minor, at least after an initial growth period. Governance can mitigate this behavior by calling \ndrip\n immediately prior to fee changes. The code in fact enforces that \ndrip\n must be called prior to a \nduty\n update, but does not enforce a similar restriction for \nbase\n (due to the inefficiency of iterating over all collateral types).\nDai Savings Rate Accumulation\nOverview\nDSR accumulation is very similar to stability fee accumulation. It is implemented via the \nPot\n, which interacts with the Vat (and again the Vow's address is used for accounting for the Dai created). The Pot tracks normalized deposits on a per-user basis (\npie[usr]\n) and maintains a cumulative interest rate parameter (\nchi\n). A \ndrip\n function analogous to that of Jug is called intermittently by economic actors to trigger savings accumulation.\nThe per-second (or \"instantaneous\") savings rate is stored in the \ndsr\n parameter (analogous to \nbase+duty\n in the stability fee case). The \nchi\n parameter as a function of time is thus (in the ideal case of \ndrip\n being called every block) given by:\nchi\n(\nt\n)\n\u0432\u0419\u00b0\nchi\n0\n\u0432\u0418\u041f\ni\n=\nt\n0\n+\n1\nt\ndsr\ni\n\\text{chi}(t) \\equiv \\text{chi}0 \\prod{i=t_0 + 1}^{t} \\text{dsr}_i\n\nchi\n(\nt\n)\n\u0432\u0419\u00b0\nchi\n0\n\u0432\u0418\u041f\ni\n=\nt\n0\n\u0432\u0410\u041b\n+\n1\nt\ndsr\ni\n\u0432\u0410\u041b\nwhere chi_0 is simply chi(\nt\n_0).\nSuppose a user joins \nN\n Dai into the Pot at time \nt\n_0. Then, their internal savings Dai balance is set to:\npie[usr]\n=\nN\n/\nchi\n0\n\\text{pie[usr]} = N / \\text{chi}_0\n\npie[usr]\n=\nN\n/\nchi\n0\n\u0432\u0410\u041b\nThe total Dai the user can withdraw from the Pot at time \nt\n is:\npie[usr]\n\u0432\u041b\u0415\nchi\n(\nt\n)\n=\nN\n\u0432\u0418\u041f\ni\n=\nt\n0\n+\n1\nt\ndsr\ni\n\\text{pie[usr]} \\cdot \\text{chi}(t) = N \\prod_{i=t_0 + 1}^{t} \\text{dsr}_i\n\npie[usr]\n\u0432\u041b\u0415\nchi\n(\nt\n)\n=\nN\ni\n=\nt\n0\n\u0432\u0410\u041b\n+\n1\n\u0432\u0418\u041f\nt\n\u0432\u0410\u041b\ndsr\ni\n\u0432\u0410\u041b\nThus we see that updates to \nchi\n effectively increase all Pot balances at once, without having to iterate over all of them.\nAfter updating \nchi\n, \nPot.drip\n then calls \nVat.suck\n with arguments such that the additional Dai created from this savings accumulation is credited to the Pot contract while the Vow's \nsin\n (unbacked debt) is increased by the same amount (the global debt and unbacked debt tallies are increased as well). To accomplish this efficiently, the Pot keeps track of a the total sum of all individual \npie[usr]\n values in a variable called \nPie\n.\nNotable Properties\nThe following points are useful to keep in mind when reasoning about savings accumulation (all have analogs in the fee accumulation mechanism):\nif \ndrip\n is called only infrequently, the instantaneously value of \nchi\n may differ from the ideal\nthe code requires that \ndrip\n be called prior to \ndsr\n changes, which eliminates deviations of \nchi\n from its ideal value due to such changes not coinciding with \ndrip\n calls\nchi\n is a monotonically increasing value unless the effective savings rate becomes negative (\ndsr\n < \nONE\n)\nThere is no stored record of depositing or withdrawing Dai from the Pot\nThere is no stored record of changes to the \ndsr\nWho calls \ndrip\n?\nThe following economic actors are incentivized (or forced) to call \nPot.drip\n:\nany user withdrawing Dai from the Pot (otherwise they lose money!)\nany user putting Dai into the Pot\u0432\u0410\u0424this is not economically rational, but is instead forced by smart contract logic that requires \ndrip\n to be called in the same block as new Dai is added to the Pot (otherwise, an economic exploit that drains system surplus is possible)\nany actor with a motive to increase the system debt, for example a Keeper hoping to trigger flop (debt) auctions\nA Note On Setting Rates\nLet's see how to set a rate value in practice. Suppose it is desired to set the DSR to 0.5% annually. Assume the real rate will track the ideal rate. Then, we need a per-second rate value \nr\n such that (denoting the number of seconds in a year by \nN\n):\nr\nN\n=\n1.005\nr^N = 1.005\n\nr\nN\n=\n1.005\nAn arbitrary precision calculator can be used to take the \nN\n-th root of the right-hand side (with \nN\n = 31536000 = 365\n24\n60*60), to obtain:\nr\n=\n1.000000000158153903837946258002097...\nr = 1.000000000158153903837946258002097...\n\nr\n=\n1.000000000158153903837946258002097...\nThe \ndsr\n parameter in the Pot implementation is interpreted as a \nray\n, i.e. a 27 decimal digit fixed-point number. Thus we multiply by 10^27 and drop anything after the decimal point:\ndsr\n=\n1000000000158153903837946258\n\\text{dsr} = 1000000000158153903837946258\n\ndsr\n=\n1000000000158153903837946258\nThe \ndsr\n could then be set to 0.5% annually by calling:\nPot.file(\"dsr\", 1000000000158153903837946258)\nPrevious\nChief - Detailed Documentation\nNext\nPot - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/rates-module", "title": "Rates Module"}}
{"page_content": "Maker Protocol Emergency Shutdown\nIntroducing the Shutdown Mechanism of the Maker Protocol\nIntroduction\nThe Maker Protocol, which powers Multi Collateral Dai, is a smart-contract system that backs and stabilizes the value of Dai through a dynamic combination of Vaults, autonomous system of smart contracts, and appropriately incentivized external actors. The Dai Target Price is 1 US Dollar, translating to a 1:1 US Dollar soft peg. Shutdown is a process that can be used as a last resort to directly enforce the Target Price to holders of Dai and Vaults, and protect the Maker Protocol against attacks on its infrastructure.\nShutdown stops and gracefully settles the Maker Protocol while ensuring that all users, both Dai holders and Vault holders, receive the net value of assets they are entitled to.\nIn short, it allows Dai holders to directly redeem Dai for collateral after an Emergency Shutdown processing period. \nOverview of the Shutdown Process \nThe process of initiating Emergency Shutdown is decentralized\n \nand controlled by MKR voters, who can trigger it by depositing MKR into the Emergency Shutdown Module.\nEmergency Shutdown is triggered in the case of serious emergencies, such as long-term market irrationality, hacks, or security breaches.\nEmergency Shutdown stops and gracefully settles the Maker Protocol while ensuring that all users, both Dai holders and Vault users, receive the net value of assets they are entitled to.\nVault owners can retrieve excess collateral from their Vaults immediately after initialization of Emergency Shutdown. They can do this via Vault frontends, such as Oasis Borrow, that have Emergency Shutdown support implemented, as well as via command-line tools.\nDai holders can, after a waiting period determined by MKR voters, swap their Dai for a relative share of all types of collateral in the system. The Maker Foundation will initially offer a web page for this purpose.\nDai holders always receive the same relative amount of collateral from the system, whether they are among the first or last people to process their claims.\nDai holders may also sell their Dai to Keepers (if available) to avoid self-management of the different collateral types in the system.\nFor more information about the Shutdown of the Maker Protocol, read the below \nEnd - Detailed Documentation\n as well as the \nEmergency Shutdown Module Documentation.\n \n\u200b\nSmart Contract Modules - \nPrevious\nFlash Mint Module\nNext\nEmergency Shutdown for Partners\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/shutdown", "title": "Maker Protocol Emergency Shutdown"}}
{"page_content": "System Stabilizer Module\nKeeping the Maker Protocol Stable\nModule Name:\n System Stabilizer\nType/Category:\n DSS \u0432\u0496\u201d> System Stabilizer Module (Vow.sol, Flap.sol, Flop.sol)\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\nContract Sources: \n\u0432\u0496\u04e2\nVow\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFlop \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFlap \n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe System Stabilizer Module's purpose is to correct the system when the value of the collateral backing Dai drops below the liquidation level (determined by governance) when the stability of the system is at risk. The system stabilizer module creates incentives for Auction Keepers (external actors) to step in and drive the system back to a safe state (system balance) by participating in both debt and surplus auctions and, in turn, earn profits by doing so.\nFor a better understanding of how the Auction Keepers relate to the System Stabilization Mechanism, read the following resources:\n\u0432\u0496\u04e2\nAuctions & Keepers within MCD 101\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nHow to Run Your Own Auction Keeper Bot in MCD Blog Post\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nAuction Keeper Bot Developer Setup Guide\n\u0432\u0496\u04e2\n2. Module Details\nThe System Stabilizer Module has 3 core components consisting of the \nVow\n, \nFlop\n, and \nFlap\n contracts.\nSystem Stabilizer Components Documentation\n\u0432\u0496\u04e2\nVow Documentation\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFlop Documentation\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFlap Documentation\n\u0432\u0496\u04e2\n3. Key Mechanisms & Concepts\nSummary of the \nSystem Stabilizer Module Components\n1.\nThe \nVow\n represents the overall Maker Protocol's \nbalance\n (both system surplus and system debt). The purpose of the \nvow\n is to cover deficits via debt auctions and discharge surpluses via surplus auctions.\n2.\nThe \nFlopper\n (Debt Auction) is used to get rid of the \nVow\n\u0432\u0496\u04b7s debt by auctioning off MKR for a fixed amount of internal system Dai. When \nflop\n auctions are kicked off, bidders compete with decreasing bids of MKR. After the auction settlement, the Flopper sends received internal Dai to the \nVow\n in order to cancel out its debt. Lastly, the Flopper mints the MKR for the winning bidder.\n3.\nThe \nFlapper\n (Surplus Auction) is used to get rid of the \nVow\n\u0432\u0496\u04b7s surplus by auctioning off a fixed amount of internal Dai for MKR. When \nflap\n auctions are kicked off, bidders compete with increasing amounts of MKR. After auction settlement, the Flapper burns the winning MKR bid and sends internal DAI to the winning bidder.\nHow the System Stabilizer Module Interacts with the other DSS Modules\nHow do the \nVow\n, \nFlop\n and \nFlap\n contracts help the MCD system operate?\nVow\nWhen the Maker Protocol receives system debt and system surplus through collateral auctions and CDP stability fee accumulation, it will deviate from system equilibrium. The job of the Vow is to bring it back to system equilibrium.\nThe Priority of the Vow\n1.\nTo kick-off debt and surplus auctions (Flop and Flap), which in turn, corrects the system\u0432\u0496\u04b7s imbalances.\nFlop\nThe purpose of debt auctions is to cover the system deficit, which is resembled by \nSin\n(the total debt in the queue). It sells an amount of minted MKR and purchases Dai that will be canceled 1-to-1 with \nSin\n.\nThe Priorities of the Flopper:\n1.\nTo raise an amount of Dai equivalent to the amount of bad debt as fast as possible.\n2.\nTo minimize the amount of MKR inflation.\nA diagram detailing the interactions a user has with Flopper and the Vow\nFlap\nThe purpose of the surplus auctions is to release Dai surplus from the \nVow\n while users bid with MKR, which will be burned, thus reducing the overall MKR supply. It will sell a fixed amount of Dai to purchase and burn MKR.\nThe Priority of the Flapper:\n1.\nTo mechanically reduce the MKR supply when auctioning off Dai surplus.\nA diagram detailing the interactions a user has with Flapper and the Vow.\n4. Gotchas (Potential Sources of User Error)\nAuction \nKeepers\nIn the context of running an Auction Keeper to perform bids within an auction, a primary failure mode would occur when a Keeper specifies an unprofitable price for MKR (more info \nhere\n).\nThis failure mode is due to the fact that there is nothing the system can do to stop a user from paying significantly more than the fair market value for the token in an auction (this goes for all auction types, \nflip\n, \nflop\n, and \nflap\n).\nKeepers that are performing badly are primarily at risk during the \ndent\n phase since they could return too much collateral to the original CDP and end up overpaying (i.e. pay too much Dai (\nbid\n) for too few gems (\nlot\n)).\nNote:\n This does not apply to the Flap contract (Flop and Flip only)\nWhen no Auction Keepers Bid:\nFor both the \nFlip\n and \nFlap\n auctions, the \ntick\n function will restart an auction if there have been 0 bids and the original \nend\n has passed.\nIn the case of a \nFlop\n auction expiring without receiving any bids, anyone can restart the auction by calling \ntick\n. Along with restarting the auction, it also includes a necessary increase of the initial \nlot\n size by \npad\n (default to 50%). This extra process is because the lack of bidding for the \nlot\n could be due market circumstances, where the \nlot\n value is too low and is no longer enough for recovering the \nbid\n amount.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nGovernance Trade-offs\nbeg\nIf too high, it would discourage bidding and create a less efficient auction mechanism.\nIf too low, it would not be that significant but would encourage small bids and increase the likelihood of the \nBid.end\n being hit before the \"true\" price was found.\nttl\nIf too high, it would cause the winning bidder to wait \"too long\" to collect their winnings (depending on the situation, possibly subjecting them to market volatility).\nIf too low, it would increase the likelihood of bids expiring before other bidders get a chance to respond.\ntau\nIf too high, it would not have that significant of an impact as auctions would still operate normally based on the \nBid.tic\n.\nIf too low, it would increase the chance that an auction will end before the \"true\" price was found.\nOther Non-Obvious Auction Failure Modes (This is for all auction types: Flip, Flop, Flap)\nPotential Issues around Network Congestion\nWhen auctioning off collateral tokens, bids are finalized after an interval of time (\nttl\n) has passed. Hence, in the case when extreme network congestion occurs, \nttl\n and auctions are affected because they can take longer than three hours to confirm a transaction. Therefore, due to Ethereum network congestion, this can result in auctions settling for less than the fair market value. Due to this potential issue, bidders need to calculate network congestion risks when making bids.\nExample:\nWhen high network congestion occurs, where common APIs can be shut down due to denial of service (DoS), and where high gas prices are present, this can result in bidding becoming extremely expensive regardless of whether bids win or not. Unfortunately, this also results in only enabling those who have the experience and technical knowledge to build their own transactions are able to use and participate in auctions. Therefore, auctions thus settle for less than the fair market value.\nAudit Section Source:\n Timestamp dependence in auctions enables denial of service \n(Page 8)\n\u0432\u0496\u04e2\nTransaction-reordering / Front Running Attacks on Auctions\nFront running attacks are possible. In order to mitigate this possibility, we reviewed and evaluated other auction options such as \ndutch\n and/or commit reveal but do not currently feel this change is worth delaying the whole system for. Due to the modular nature of the system and the fact that the auction modules can be swapped out, it will be possible for governance to upgrade the auction process in the future.\nSmart Contract Modules - \nPrevious\nLiquidation 2.0 Module\nNext\nFlapper - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/system-stabilizer-module", "title": "System Stabilizer Module"}}
{"page_content": "Advanced\nTo override the address of one of the contracts used by Dai.js or a plugin, you can pass the \nsmartContract.addressOverrides\n option. You need to know the key of the contract in the addresses file to override it.\n\u200b\nList of mainnet addresses\n\u200b\nconst\n service \n=\n Maker\n.\ncreate\n(\n'test'\n \n{\n \nsmartContract\n:\n \n{\n \naddressOverrides\n:\n \n{\n \nPROXY_REGISTRY\n:\n \n'0xYourAddress'\n \n}\n \n}\n \n});\n\u200b\nPrevious\nSystem data\nNext\nTransaction manager\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration", "title": "Advanced"}}
{"page_content": "Collateral types\nUse the \n'mcd:cdpType'\n service to look up parameters for different collateral types in the system. In the code, this is called \nCdpTypeService\n.\nconst\n service \n=\n maker\n.\nservice\n(\n'mcd:cdpType'\n);\nProperties\ncdpTypes\nThis is a list of \ncollateral type instances\n, initialized during \nMaker.create\n.\nservice\n.\ncdpTypes\n.\nforEach\n(\ntype\n \n=>\n console\n.\nlog\n(\ntype\n.\nilk\n));\n// ETH-A\n// BAT-A\n// USDC-A\nInstance methods\ngetCdpType()\nReturn the \ncollateral type instance\n for the specified currency and/or \nilk\n.\n// this will error if more than one type is defined for ETH\nconst\n type \n=\n service\n.\ngetCdpType\n(\nETH\n);\n\u0432\u0496\u04e2\n// disambiguate using the ilk name string:\nconst\n ethA \n=\n service\n.\ngetCdpType\n(\nnull\n,\n \n'ETH-A'\n);\nCollateral type instances\nProperties\nilk\nThe name of the collateral type as a string, e.g. \"ETH-A\".\ntotalCollateral\nThe total amount of collateral locked in all vaults of this collateral type.\ntotalDebt\nThe total Dai debt drawn against all vaults of this collateral type.\ndebtCeiling\nThe debt ceiling for this collateral type.\nliquidationRatio\nVaults of this type become unsafe (subject to liquidation) when their ratio between USD value of collateral and Dai drawn is less than or equal to this amount. \nprice\nThe USD price of this collateral type's token, using recent price feed data, as a \ncurrency ratio\n. (See \"A note on caching\" above).\nconsole\n.\nlog\n(\ntype\n.\nprice\n.\ntoString\n());\n \n// \"9000.01 ETH/USD\"\nliquidationPenalty\nThe penalty added to the Dai amount to be raised at auction when a vault is liquidated, as a percentage. e.g. if the penalty is 13%, this value will be \nBigNumber(0.13)\n.\nannualStabilityFee\nThe annual stability fee (risk premium) of the collateral type, not including the \nbase rate\n, as a BigNumber. e.g. if the rate is 5%, this value will be \nBigNumber(0.05)\n.\nCaching\nWhen a vault instance is created, its data is pre-fetched from the blockchain, allowing the properties below to be read synchronously. This data is cached in the instance. To refresh this data, do the following:\nvault\n.\nreset\n();\nawait\n vault\n.\nprefetch\n();\nTo refresh the data for all collateral type instances at once:\nservice\n.\nresetAllCdpTypes\n();\nawait\n service\n.\nprefetchAllCdpTypes\n();\nPrevious\nVault manager\nNext\nDai Savings Rate\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/cdptypeservice", "title": "Collateral types"}}
{"page_content": "Currency units\nMethods that take numerical values as input can also take instances of token classes that the library provides. These are useful for managing precision, keeping track of units, and passing in wei values. Most methods that return numerical values return them wrapped in one of these classes. There are two types:\ncurrency units\n, which represent an amount of a type of currency\nprice units\n, aka currency ratios, which represent an exchange rate between two currencies.\nThe classes that begin with \nUSD\n are price units; e.g. \nUSD_ETH\n represents the price of ETH in USD. Useful instance methods:\ntoNumber\n: return the raw JavaScript value. This may fail for very large numbers.\ntoBigNumber\n: return the raw value as a \nBigNumber\n.\nisEqual\n: compare the values and symbols of two different instances.\ntoString\n: show the value in human-readable form, e.g. \"500 USD/ETH\".\nimport\n Maker \nfrom\n \n'@makerdao/dai'\n;\n\u0432\u0410\u041b\n// Multi-Collateral Dai\n\u0432\u0410\u041b\nimport\n \n{\n \nETH\n,\n \nBAT\n,\n \nDAI\n \n}\n \nfrom\n \n'@makerdao/dai-plugin-mcd'\n;\n\u0432\u0410\u041b\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n...\n);\nconst\n mgr \n=\n maker\n.\nservice\n(\n'mcd:cdpManager'\n);\n\u0432\u0410\u041b\n// lock BAT into a new vault and draw Dai\nconst\n vault \n=\n \nawait\n mgr\n.\nopenLockAndDraw\n(\n \n'BAT-A'\n,\n \nBAT\n(\n100\n),\n \nDAI\n(\n100\n)\n);\n\u0432\u0410\u041b\n// Single-Collateral Sai\n\u0432\u0410\u041b\nconst\n \n{\n \nMKR\n,\n \nSAI\n,\n \nETH\n,\n \nWETH\n,\n \nPETH\n,\n \nUSD_ETH\n,\n \nUSD_MKR\n,\n \nUSD_SAI\n}\n \n=\n Maker\n;\n\u0432\u0410\u041b\n// These are all identical:\n\u0432\u0410\u041b\n// each method has a default type\ncdp\n.\nlockEth\n(\n0.25\n);\ncdp\n.\nlockEth\n(\n'0.25'\n);\n\u0432\u0410\u041b\n// you can pass in a currency unit instance\ncdp\n.\nlockEth\n(\nETH\n(\n0.25\n));\n\u0432\u0410\u041b\n// currency units have convenient converter methods\ncdp\n.\nlockEth\n(\nETH\n.\nwei\n(\n250000000000000000\n));\n\u0432\u0410\u041b\nconst\n eth \n=\n \nETH\n(\n5\n);\neth\n.\ntoString\n()\n \n==\n \n'5.00 ETH'\n;\n\u0432\u0410\u041b\nconst\n price \n=\n \nUSD_ETH\n(\n500\n);\nprice\n.\ntoString\n()\n \n==\n \n'500.00 USD/ETH'\n;\n\u0432\u0410\u041b\n// multiplication handles units\nconst\n usd \n=\n eth\n.\ntimes\n(\nprice\n);\nusd\n.\ntoString\n()\n \n==\n \n'2500.00 USD'\n;\n\u0432\u0410\u041b\n// division does too\nconst\n eth2 \n=\n usd\n.\ndiv\n(\neth\n);\neth2\n.\nisEqual\n(\neth\n);\nIf you would like to use these helper classes outside of Dai.js, check out \n@makerdao/currency\n.\nPrevious\nDai Savings Rate\nNext\nSystem data\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/currency-units", "title": "Currency units"}}
{"page_content": "Getting started\nInstallation\nInstall the package with npm in your terminal:\nnpm install @makerdao/dai\nOnce it's installed, import the module into your project as shown below.\nimport\n Maker \nfrom\n \n'@makerdao/dai'\n;\n// or\nconst\n Maker \n=\n \nrequire\n(\n'@makerdao/dai'\n);\nMulti-Collateral Dai support in Dai.js is implemented as a \nplugin\n. This may change in the future. The MCD Plugin is also available as an \nnpm\n package and its source code can be found on \nGithub\n.\nnpm install @makerdao/dai-plugin-mcd\nimport\n \n{\n McdPlugin \n}\n \nfrom\n \n'@makerdao/dai-plugin-mcd'\n;\n// or\nconst\n \n{\n McdPlugin \n}\n \n=\n \nrequire\n(\n'@makerdao/dai-plugin-mcd'\n);\n(Note the \n.default\n at the end of the line when using \nrequire\n.)\nUMD\nThis library is also usable as a \nUMD module\n, which you can build with \nnpm run build:frontend\n.\n<\nscript src\n=\n\"./dai.js\"\n \n/>\n\u0432\u0496\u04e2\n<\nscript\n>\n// once the script loads, window.Maker is available\n</\nscript\n>\nQuick Examples\nLook up information about a vault\nThis code uses \ngetCdpIds\n to look up a vault that was created in the \nOasis Borrow\n UI. Since this code is only reading data, not creating any transactions, it is not necessary to provide a private key or connect a wallet.\n// you provide these values\nconst\n infuraKey \n=\n \n'your-infura-api-key'\n;\nconst\n ownerAddress \n=\n \n'0xf00...'\n;\n\u0432\u0496\u04e2\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\n \nplugins\n:\n \n[\nMcdPlugin\n],\n \nurl\n:\n \n`\nhttps://mainnet.infura.io/v3/\n${\ninfuraKey\n}\n`\n});\n\u0432\u0496\u04e2\nconst\n manager \n=\n maker\n.\nservice\n(\n'mcd:cdpManager'\n);\nconst\n proxyAddress \n=\n maker\n.\nservice\n(\n'proxy'\n).\ngetProxyAddress\n(\nownerAddress\n);\nconst\n data \n=\n \nawait\n manager\n.\ngetCdpIds\n(\nproxyAddress\n);\n \n// returns list of { id, ilk } objects\nconst\n vault \n=\n \nawait\n manager\n.\ngetCdp\n(\ndata\n[\n0\n].\nid\n);\n\u0432\u0496\u04e2\nconsole\n.\nlog\n([\n  vault\n.\ncollateralAmount\n,\n \n// amount of collateral tokens\n  vault\n.\ncollateralValue\n,\n \n// value in USD, using current price feed values\n  vault\n.\ndebtValue\n,\n \n// amount of Dai debt\n  vault\n.\ncollateralizationRatio\n,\n \n// collateralValue / debt\n  vault\n.\nliquidationPrice  \n// vault becomes unsafe at this price\n].\nmap\n(\nx\n \n=>\n x\n.\ntoString\n());\nCreate a vault\nThe code below opens a Vault, locks ETH into it, and draws out Dai. \nSince this code sends transactions, it requires an account that can sign transactions. The simplest way to do this is to provide a \nprivateKey\n configuration option as shown below, but you can also connect to Metamask or other browser-based providers, or connect to hardware wallets.\nimport\n Maker \nfrom\n \n'@makerdao/dai'\n;\nimport\n \n{\n McdPlugin\n,\n \nETH\n,\n \nDAI\n \n}\n \nfrom\n \n'@makerdao/dai-plugin-mcd'\n;\n\u0432\u0496\u04e2\n// you provide these values\nconst\n infuraKey \n=\n \n'your-infura-api-key'\n;\nconst\n myPrivateKey \n=\n \n'your-private-key'\n;\n\u0432\u0496\u04e2\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\n \nplugins\n:\n \n[\nMcdPlugin\n],\n \nurl\n:\n \n`\nhttps://mainnet.infura.io/v3/\n${\ninfuraKey\n}\n`\n,\n \nprivateKey\n:\n myPrivateKey\n});\n\u0432\u0496\u04e2\n// verify that the private key was read correctly\nconsole\n.\nlog\n(\nmaker\n.\ncurrentAddress\n());\n\u0432\u0496\u04e2\n// make sure the current account owns a proxy contract;\n// create it if needed. the proxy contract is used to \n// perform multiple operations in a single transaction\nawait\n maker\n.\nservice\n(\n'proxy'\n).\nensureProxy\n();\n\u0432\u0496\u04e2\n// use the \"vault manager\" service to work with vaults\nconst\n manager \n=\n maker\n.\nservice\n(\n'mcd:cdpManager'\n);\n \n// ETH-A is the name of the collateral type; in the future,\n// there could be multiple collateral types for a token with\n// different risk parameters\nconst\n vault \n=\n \nawait\n manager\n.\nopenLockAndDraw\n(\n \n'ETH-A'\n,\n \n \nETH\n(\n50\n),\n \n \nDAI\n(\n1000\n)\n);\n\u0432\u0496\u04e2\nconsole\n.\nlog\n(\nvault\n.\nid\n);\nconsole\n.\nlog\n(\nvault\n.\ndebtValue\n);\n \n// '1000.00 DAI'\nIn the next section, learn more about how to configure the Maker instance with \nMaker.create\n. Or jump to learning more about \naccounts\n, \nvaults\n, \nproxies\n, and \ncurrency units\n.\nIntegration Examples\nFor larger examples of integrating this library, check out this \nrepo\n and the \nDai react template\n.\n\u0432\u0496\u04e2\nBuilding on top of the Maker Protocol - \nPrevious\nThe Dai Javascript Library of the Maker Protocol\nNext\nConfiguration\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/getting-started", "title": "Getting started"}}
{"page_content": "Configuration\nMaker.create\nYou can configure the behavior of Dai.js by passing different arguments to \nMaker.create\n. The first argument is the name of a preset, and the second is an options object.\nPresets\n'browser'\nUse this preset when using the library in a browser environment. It will attempt to connect using \nwindow.ethereum\n or \nwindow.web3\n.\n'http'\nConnect to a JSON-RPC node. Requires \nurl\n to be set in the options.\n'test'\nUse a local node (e.g. Ganache) running at \nhttp://127.0.0.1:2000\n, and sign transactions using node-managed keys.\nconst\n makerBrowser \n=\n \nawait\n Maker\n.\ncreate\n(\n'browser'\n);\n\u0432\u0496\u04e2\nconst\n makerHttp \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\n \nurl\n:\n \n'https://kovan.infura.io/v3/YOUR_INFURA_PROJECT_ID'\n});\n\u0432\u0496\u04e2\nconst\n makerTest \n=\n \nawait\n Maker\n.\ncreate\n(\n'test'\n);\nOptions\nprivateKey\nOptional. The private key used to sign transactions. If this is omitted, the first account available from the Ethereum provider will be used. Only used with the \n'http'\n preset.\nIf this is omitted and the provider does not have an unlocked account, the \nmaker\n object will start in \nread-only mode\n.\nurl\nThe URL of the node to connect to. Only used with the \n'http'\n preset.\nweb3.transactionSettings\nObject containing transaction options to be applied to all transactions sent through the library.\nDefault value: \n{ gasLimit: 4000000 }\nweb3.confirmedBlockCount\nNumber of blocks to wait after a transaction has been mined when calling \nconfirm\n. See \nTransactions\n for further explanation. \nDefault value: 5\nweb3.inject\nFor advanced users. You can inject your own custom instance of a Web3 provider with this, instead of using the default HttpProvider.\nlog\nSet this to \nfalse\n to reduce the verbosity of logging.\nautoAuthenticate\nSet this to \nfalse\n to create the Maker instance without connecting yet. If so, you must run \nawait maker.authenticate()\n before using any other methods.\n// It doesn't necessarily make sense to set all these\n// options at the same time (e.g. `url` and `inject`),\n// this is just meant to illustrate the shape of the\n// options object.\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\n \nprivateKey\n:\n \nYOUR_PRIVATE_KEY\n,\n \n// '0xabc...'\n \nurl\n:\n \n'http://some-ethereum-rpc-node.net'\n,\n \nweb3\n:\n \n{\n \nstatusTimerDelay\n:\n \n2000\n,\n \nconfirmedBlockCount\n:\n \n8\n \ntransactionSettings\n:\n \n{\n \ngasPrice\n:\n \n12000000000\n \n},\n \ninject\n:\n someProviderInstance\n \n},\n \nlog\n:\n \nfalse\n,\n \nautoAuthenticate\n:\n \nfalse\n});\nInstance methods\nservice()\nReturns:\n service object\nReturn a service instance that was included in this instance of \nmaker\n.\nconst\n accountsService \n=\n maker\n.\nservice\n(\n'accounts'\n);\nServices\nThe MCD plugin defines several services for working with Multi-Collateral Dai. Review \nGetting started\n to see how to add the plugin.\n\u0432\u0496\u04e2\n'mcd:cdpManager'\n: for working with Vaults.\n\u0432\u0496\u04e2\n'mcd:cdpType'\n: for reading parameters and live data (totals and prices) for collateral types.\n\u0432\u0496\u04e2\n'mcd:savings'\n: for working with the Dai Savings Rate.\n\u0432\u0496\u04e2\n'mcd:systemData'\n: for reading system-wide parameters.\nRead-only mode\nAs mentioned above, the \nMaker\n instance can be used in read-only mode, if you just want to read data from the blockchain without signing any transactions. Simply omit the \nprivateKey\n option.\nYou can start in read-only mode and still \nadd an account\n with the ability to sign transactions later on.\nPrevious\nGetting started\nNext\nPlugins\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/maker", "title": "Configuration"}}
{"page_content": "Dai Savings Rate\nUse the \n'mcd:savings'\n service to work with the Dai Savings Rate system. In the code, this is called \nSavingsService\n.\nconst\n service \n=\n maker\n.\nservice\n(\n'mcd:savings'\n);\nInstance methods\nAll the methods below are asynchronous. \njoin\n, \nexit\n, and \nexitAll\n use a \nproxy contract\n.\njoin(amount)\nDeposit the specified amount of Dai into the Dai Savings Rate (DSR) contract.\nawait\n service\n.\njoin\n(\nDAI\n(\n1000\n));\nexit(amount)\nWithdraw the specified amount of Dai from the DSR contract.\nexitAll()\nWithdraw all Dai owned by the current account from the DSR contract.\nbalance()\nReturn the amount of Dai in the DSR contract owned by the \ncurrent address\n. Strictly speaking, this method returns the amount of Dai owned by the proxy contract for the current address. to work with the methods above.\nbalanceOf(address)\nReturn the amount of Dai in the DSR contract owned by the specified address.\ngetTotalDai()\nGet the total amount of Dai in the DSR contract for all users.\ngetYearlyRate()\nGet the current annual savings rate.\nPrevious\nCollateral types\nNext\nCurrency units\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/savingsservice", "title": "Dai Savings Rate"}}
{"page_content": "Single-Collateral Sai\nInstallation\nSingle-Collateral Dai support in Dai.js is implemented as a \nplugin\n. The SCD plugin is also available as an \nnpm\n package and its source code can be found on \nGithub\n.\nnpm install @makerdao/dai-plugin-scd\nimport\n \n{\n ScdPlugin \n}\n \nfrom\n \n'@makerdao/dai-plugin-scd'\n;\n// or\nconst\n \n{\n ScdPlugin \n}\n \n=\n \nrequire\n(\n'@makerdao/dai-plugin-scd'\n);\nQuick example\nThe code below creates a CDP, locks ETH into it, and draws out Sai.\nimport\n Maker \nfrom\n \n'@makerdao/dai'\n;\nimport\n \n{\n ScdPlugin \n}\n \nfrom\n \n'@makerdao/dai-plugin-scd'\n;\n\u200b\nasync\n \nfunction\n \nopenLockDraw\n()\n \n{\n \nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n\"http\"\n,\n \n{\n \nplugins\n:\n \n[\nScdPlugin\n],\n \nprivateKey\n:\n \nYOUR_PRIVATE_KEY\n,\n \nurl\n:\n \n'https://kovan.infura.io/v3/YOUR_INFURA_PROJECT_ID'\n \n});\n\u200b\n \nawait\n maker\n.\nauthenticate\n();\n \nconst\n cdpService \n=\n \nawait\n maker\n.\nservice\n(\n'cdp'\n);\n \nconst\n cdp \n=\n \nawait\n cdpService\n.\nopenCdp\n();\n\u200b\n \nawait\n cdp\n.\nlockEth\n(\n0.25\n);\n \nawait\n cdp\n.\ndrawSai\n(\n50\n);\n\u200b\n \nconst\n debt \n=\n \nawait\n cdp\n.\ngetDebtValue\n();\n  console\n.\nlog\n(\ndebt\n.\ntoString\n);\n \n// '50.00 SAI'\n}\n\u200b\nopenLockDraw\n();\nThe services and objects below are used to work with Single-Collateral Sai.\n\u200b\nCDP Service\n\u200b\n\u200b\nCollateralized Debt Position\n\u200b\n\u200b\nSystem Status\n\u200b\n\u200b\nToken Conversion\n\u200b\nopenCdp()\nReturns:\n promise (resolves to new CDP object once mined)\nopenCdp()\n will create a new CDP, and then return the CDP object, which can be used to access other CDP functionality. The promise will resolve when the transaction is mined.\nconst\n cdpService \n=\n \nawait\n maker\n.\nservice\n(\n'cdp'\n);\nconst\n newCdp \n=\n \nawait\n cdpService\n.\nopenCdp\n();\ngetCdp(int id)\nReturns:\n promise (resolves to CDP object)\ngetCdp(id)\n creates a CDP object for an existing CDP. The CDP object can then be used to interact with your CDP.\nconst\n cdpService \n=\n \nawait\n maker\n.\nservice\n(\n'cdp'\n);\nconst\n cdp \n=\n \nawait\n cdpService\n.\ngetCdp\n(\n614\n);\nOnce you have an instance of a CDP, you can use \nCDP instance methods\n to read its state and perform actions.\nPrevious\nAdding a new service\nNext\nCollateralized Debt Position\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai", "title": "Single-Collateral Sai"}}
{"page_content": "System data\nUse the \nmcd:systemData\n service to look up system-wide parameters. In the code, this is called \nSystemDataService\n.\nconst\n service \n=\n maker\n.\nservice\n(\n'mcd:systemData'\n);\nInstance methods\ngetAnnualBaseRate()\nReturns the base rate applied to all collateral types, in addition to their individual risk premiums.\nconst\n base \n=\n \nawait\n service\n.\ngetAnnualBaseRate\n();\ngetSystemWideDebtCeiling()\nReturns the debt ceiling for the entire system.\nconst\n line \n=\n \nawait\n service\n.\ngetSystemWideDebtCeiling\n();\nisGlobalSettlementInvoked()\nReturns a boolean that is true if emergency shutdown has been triggered.\nconst\n dead \n=\n \nawait\n service\n.\nisGlobalSettlementInvoked\n();\nPrevious\nCurrency units\nNext\nAdvanced\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/systemdataservice", "title": "System data"}}
{"page_content": "Vault manager\nThe vault manager works with vaults that are owned by the \nCdpManager\n contract, which is also used by Oasis Borrow. This intermediary contract allows the use of incrementing integer IDs for vaults, familiar to users of Single-Collateral Sai, as well as other conveniences.\nIn the code, this is called \nCdpManager\n.\nconst\n mgr \n=\n maker\n.\nservice\n(\n'mcd:cdpManager'\n);\nInstance methods\nThe methods below are all asynchronous.\ngetCdpIds()\nReturn an array describing the vaults owned by the specified address. Note that if the vaults were created in Oasis Borrow, the address of the proxy contract should be used.\nconst\n proxyAddress \n=\n \nawait\n maker\n.\nservice\n(\n'proxy'\n).\ncurrentProxy\n();\nconst\n data \n=\n \nawait\n mgr\n.\ngetCdpIds\n(\nproxyAddress\n);\nconst\n \n{\n id\n,\n ilk \n}\n \n=\n data\n[\n0\n];\n// e.g. id = 5, ilk = 'ETH-A'\ngetCdp()\nGet an existing vault by its numerical ID. Returns a \nVault instance\n.\nconst\n vault \n=\n \nawait\n mgr\n.\ngetCdp\n(\n111\n);\nopen()\nOpen a new vault with the specified \ncollateral type\n. Will create a \nproxy\n if one does not already exist. Returns a \nVault instance\n. Works with the \ntransaction manager\n.\nconst\n txMgr \n=\n maker\n.\nservice\n(\n'transactionManager'\n);\nconst\n open \n=\n \nawait\n mgr\n.\nopen\n(\n'ETH-A'\n);\ntxMgr\n.\nlisten\n(\nopen\n,\n \n{\n \npending\n:\n \ntx\n \n=>\n console\n.\nlog\n(\n'tx pending: '\n \n+\n tx\n.\nhash\n)\n});\nconst\n vault \n=\n \nawait\n open\n;\nopenLockAndDraw()\nOpen a new vault, then lock and/or draw in a single transaction. Will create a \nproxy\n if one does not already exist. Returns a \nVault instance\n.\nconst\n vault \n=\n \nawait\n mgr\n.\nopenLockAndDraw\n(\n \n'BAT-A'\n,\n \n \nBAT\n(\n1000\n),\n \nDAI\n(\n100\n)\n);\nVault instances\nIn the code, these are called \nManagedCdp\n.\nProperties\nA note on caching:\n When a vault instance is created, its data is pre-fetched from the blockchain, allowing the properties below to be read synchronously. This data is cached in the instance. To refresh this data, do the following:\nvault\n.\nreset\n();\nawait\n vault\n.\nprefetch\n();\ncollateralAmount\nThe amount of collateral tokens locked, as a \ncurrency unit\n. \ncollateralValue\nThe USD value of collateral locked, given the current price according to the price feed, as a \ncurrency unit\n.\ndebtValue\nThe amount of Dai drawn, as a \ncurrency unit\n.\nliquidationPrice\nThe USD price of collateral at which the Vault becomes unsafe.\nisSafe\nWhether the Vault is currently safe or not.\nInstance methods\nAll of the methods below are asynchronous and work with the \ntransaction manager\n. Amount arguments should be \ncurrency units\n, e.g.:\nimport\n \n{\n \nETH\n,\n \nDAI\n \n}\n \nfrom\n \n'@makerdao/dai-plugin-mcd'\n;\n\u0432\u0496\u04e2\nawait\n vault\n.\nlockAndDraw\n(\nETH\n(\n2\n),\n \nDAI\n(\n20\n));\nlockCollateral(amount)\nDeposit the specified amount of collateral.\ndrawDai(amount)\nGenerate the specified amount of Dai.\nlockAndDraw(lockAmount, drawAmount)\nDeposit some collateral and generate some Dai in a single transaction.\nwipeDai(amount)\nPay back the specified amount of Dai.\nwipeAll()\nPay back all debt. This method ensures that dust amounts do not remain.\nfreeCollateral(amount)\nWithdraw the specified amount of collateral.\nwipeAndFree(wipeAmount, freeAmount)\nPay back some debt and withdraw some collateral in a single transaction.\nwipeAllAndFree(freeAmount)\nPay back all debt, ensuring dust amounts do not remain, and withdraw a specified amount of collateral in a single transaction.\ngive(address)\nTransfer ownership of this vault to \naddress\n. Note that if the new owner plans to use this vault with Oasis Borrow, it should be transferred to their proxy with \ngiveToProxy\n instead.\ngiveToProxy(address)\nLook up the proxy contract owned by \naddress\n and transfer ownership of this vault to that proxy.\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nPrevious\nPlugins\nNext\nCollateral types\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/the-mcd-plugin", "title": "Vault manager"}}
{"page_content": "Auction Keeper Bot Setup Guide\nWalkthrough how to set up your own Auction Keeper\nLevel:\n Intermediate\nEstimated Time:\n 60 minutes\nAudience:\n Developers\nOverview\nThe Maker Protocol, which powers Multi Collateral Dai (MCD), is a smart contract based system that backs and stabilizes the value of Dai through a dynamic combination of Vaults (formerly known as CDPs), autonomous feedback mechanisms, and incentivized external actors. To keep the system in a stable financial state, it is important to prevent both debt and surplus from building up beyond certain limits. This is where Auctions and Auction Keepers come in. The system has been designed so that there are three types of Auctions in the system: Surplus Auctions, Debt Auctions, and Collateral Auctions. Each auction is triggered as a result of specific circumstances.\nAuction Keepers are external actors that are incentivized by profit opportunities to contribute to decentralized systems. In the context of the Maker Protocol, these external agents are incentivized to automate certain operations around the Ethereum blockchain. This includes:\nSeeking out opportunities and starting new auctions\nDetect auctions started by other participants\nBid on auctions by converting token prices into bids\nMore specifically, Keepers participate as bidders in the Debt and Collateral Auctions when Vaults are liquidated and auction-keeper enables the automatic interaction with these MCD auctions. This process is automated by specifying bidding models that define the decision making process, such as what situations to bid in, how often to bid, how high to bid etc. Note that bidding models are created based on individually determined strategies.\nLearning Objectives\nThis guide's purpose is to provide a walkthrough of how to use \nauction-keeper\n and interact with a Kovan deployment of the Multi Collateral Dai (MCD) smart contracts. More specifically, the guide will showcase how to set up and run an Auction Keeper bot for yourself. After going through this guide, you will achieve the following:\nLearn about Auction Keepers and how they interact with the Maker Protocol\nUnderstand bidding models\nGet your own auction keeper bot running on the Kovan testnet\nGuide Agenda\nThis guide will show how to use the auction-keeper to interact with the Kovan deployment of the MCD smart contracts. More specifically, the guide will showcase how to go through the following stages of setting up and running an Auction Keeper bot:\n1.\nIntroduction\n2.\nBidding Models\nStarting and stopping bidding models\nCommunicating with bidding models\n3.\nSetting up the Keeper Bot (Flip Auction Keeper)\nPrerequisites\nInstallation\n4.\nRunning your Keeper Bot (Usage)\nKeeper Limitations\n5.\nAccounting\nGetting MCD K-DAI\nGetting MCD K-MKR\nGetting MCD Collateral Tokens\n6.\nTesting\n7.\nSupport\nWe are proud to say that since the Maker Protocol is an open-source platform, all of the code we have created to run the Keeper bot is free and accessible to all.\n1. Introduction\nAuction Keepers participate in auctions as a result of liquidation events and thereby acquire collateral at attractive prices. An \nauction-keeper\n can participate in three different types of auctions:\n1.\n\u0432\u0496\u04e2\nCollateral Auction (\nflip\n)\n\u0432\u0496\u04e2\n2.\n\u0432\u0496\u04e2\nSurplus Auction (\nflap\n)\n\u0432\u0496\u04e2\n3.\n\u0432\u0496\u04e2\nDebt Auction (\nflop\n)\n\u0432\u0496\u04e2\nAuction Keepers have the unique ability to plug in external \nbidding models\n, which communicate information to the Keeper on when and how high to bid (these types of Keepers can be left safely running in the background). Shortly after an Auction Keeper notices or starts a new auction, it will spawn a new instance of a \nbidding model\n and act according to its specified instructions. Bidding models will be automatically terminated by the Auction Keeper the moment the auction expires.\nNote:\nAuction Keepers will automatically call \ndeal\n (claiming a winning bid / settling a completed auction) if the Keeper's address won the auction.\nAuction Keeper Architecture\nAs mentioned above, Auction Keepers directly interact with \nFlipper\n, \nFlapper\n and \nFlopper\n auction contracts deployed to the Ethereum mainnet. All decisions which involve pricing details are delegated to the \nbidding models\n. The Bidding models are simply executable strategies, external to the main \nauction-keeper\n process. This means that the bidding models themselves do not have to know anything about the Ethereum blockchain and its smart contracts, as they can be implemented in basically any programming language. However, they do need to have the ability to read and write JSON documents, as this is how they communicate/exchange with \nauction-keeper\n. It's important to note that as a developer running an Auction Keeper, it is required that you have basic knowledge on how to properly start and configure the auction-keeper. For example, providing startup parameters as keystore / password are required to setup and run a Keeper. Additionally, you should be familiar with the MCD system, as the model will receive auction details from auction-keeper in the form of a JSON message containing keys such as lot, beg, guy, etc.\nSimple Bidding Model Example:\nA simple bidding model could be a shell script which echoes a fixed price (further details below).\nThe Purpose of Auction Keepers\nThe main purpose of Auction Keepers are:\nTo discover new opportunities and start new auctions.\nTo constantly monitor all ongoing auctions.\nTo detect auctions started by other participants.\nTo Bid on auctions by converting token prices into bids.\nTo ensure that instances of \nbidding model\n are running for each auction type as well as making sure the instances match the current status of their auctions. This ensure that Keepers are bidding according to decisions outlined by the bidding model.\nThe auction discovery and monitoring mechanisms work by operating as a loop, which initiates on every new block and enumerates all auctions from \n1\n to \nkicks\n. When this occurs, even when the \nbidding model\n decides to send a bid, it will not be processed by the Keeper until the next iteration of that loop. It's important to note that the \nauction-keeper\n not only monitors existing auctions and discovers new ones, but it also identifies and takes opportunities to create new auctions.\n2. Bidding Models\nStarting and Stopping Bidding Models\nAuction Keeper maintains a collection of child processes, as each \nbidding model\n is its own dedicated process. New processes (new \nbidding model\n instances) are spawned by executing a command according to the \n--model\n command-line parameter. These processes are automatically terminated (via \nSIGKILL\n) by the keeper shortly after their associated auction expires. Whenever the \nbidding model\n process dies, it gets automatically re-spawned by the Keeper.\nExample:\nbin/auction-keeper --model '../my-bidding-model.sh' [...]\nCommunicating with \nbidding models\nAuction Keepers communicate with \nbidding models\n via their standard input/standard output. Once the process has started and every time the auction state changes, the Keeper sends a one-line JSON document to the \nstandard input\n of the \nbidding model.\nA sample JSON message sent from the keeper to the model looks like the:\n{\"id\": \"6\", \"flapper\": \" 0xf0afc3108bb8f196cf8d076c8c4877a4c53d4e7c \", \"bid\": \"7.142857142857142857\", \"lot\": \"10000.000000000000000000\", \"beg\": \"1.050000000000000000\", \"guy\": \" 0x00531a10c4fbd906313768d277585292aa7c923a \", \"era\": 1530530620, \"tic\": 1530541420, \"end\": 1531135256, \"price\": \"1400.000000000000000028\"}\nGlossary (Bidding Models):\nid\n - auction identifier.\nflipper\n - Ethereum address of the \nFlipper\n contract (only for \nflip\n auctions).\nflapper\n - Ethereum address of the \nFlapper\n contract (only for \nflap\n auctions).\nflopper\n - Ethereum address of the \nFlopper\n contract (only for \nflop\n auctions).\nbid\n - current highest bid (will go up for \nflip\n and \nflap\n auctions).\nlot\n - amount being currently auctioned (will go down for \nflip\n and \nflop\n auctions).\ntab\n - bid value (not to be confused with the bid price) which will cause the auction to enter the \ndent\n phase (only for \nflip\n auctions).\nbeg\n - minimum price increment (\n1.05\n means minimum 5% price increment).\nguy\n - Ethereum address of the current highest bidder.\nera\n - current time (in seconds since the UNIX epoch).\ntic\n - time when the current bid will expire (\nNone\n if no bids yet).\nend\n - time when the entire auction will expire (end is set to \n0\n is the auction is no longer live).\nprice\n - current price being tendered (can be \nNone\n if price is infinity).\nBidding models\n should never make an assumption that messages will be sent only when auction state changes. It is perfectly fine for the \nauction-keeper\n to periodically send the same message(s) to \nbidding models\n.\nAt the same time, the \nauction-keeper\n reads one-line messages from the \nstandard output\n of the \nbidding model\n process and tries to parse them as JSON documents. It will then extract the two following fields from that document:\nprice\n - the maximum (for \nflip\n and \nflop\n auctions) or the minimum (for \nflap\n auctions) price the model is willing to bid.\ngasPrice\n (optional) - gas price in Wei to use when sending a bid.\nAn example of a message sent from the Bidding Model to the Auction Keeper may look like:\n    {\"price\": \"150.0\", \"gasPrice\": 7000000000}\nIn the case of when Auction Keepers and Bidding Models communicate in terms of prices, it is the MKR/DAI price (for \nflap\n and \nflop\n auctions) or the collateral price expressed in DAI for \nflip\n auctions (for example, OMG/DAI).\nAny messages written by a Bidding Model to \nstderr\n (standard error) will be passed through by the Auction Keeper to its logs. This is the most convenient way of implementing logging from Bidding Models.\n3. Setting up the Auction Keeper Bot (Installation)\nPrerequisite\nGit\n\u0432\u0496\u04e2\nPython v3.6.6\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nvirtualenv\n\u0432\u0496\u04e2\nThis project requires \nvirtualenv\n to be installed if you want to use Maker's python tools. This helps to ensure that you are running the right version of python as well as check that all of the pip packages that are installed in the \ninstall.sh\n are in the right place and have the correct versions.\n\u0432\u0496\u04e2\nX-code\n (for Macs)\n\u0432\u0496\u04e2\nDocker-Compose\n\u0432\u0496\u04e2\nGetting Started\nInstallation from source:\n1.\nClone the \nauction-keeper\n repository:\ngit clone https://github.com/makerdao/auction-keeper.git\n1.\nSwitch into the \nauction-keeper\n directory:\ncd auction-keeper\n1.\nInstall required third-party packages:\ngit submodule update --init --recursive\n1.\nSet up the virtual env and activate it:\npython3 -m venv _virtualenv\nsource _virtualenv/bin/activate\n5. Install requirements:\npip3 install -r requirements.txt\nPotential Errors:\nNeeding to upgrade pip version to 19.2.2:\nFix by running \npip install --upgrade pip\n.\nFor other known Ubuntu and macOS issues please visit the \npymaker\n README.\n4. Running your Keeper Bot\nThe Kovan version runs on the \nKovan Release 1.0.2\n\u0432\u0496\u04e2\nTo change to your chosen version of the kovan release, copy/paste your preferred contract addresses in \nkovan-addresses.json\n in \nlib/pymaker/config/kovan-addresses.json\n1. Creating your bidding model (an example detailing the simplest possible bidding model)\nThe stdout (standard output) provides a price for the collateral (for \nflip\n auctions) or MKR (for \nflap\n and \nflop\n auctions). The \nsleep\n locks the price in place for a minute, after which the keeper will restart the price model and read a new price (consider this your price update interval).\nThe simplest possible \nbidding model\n you can set up is when you use a fixed price for each auction. For example:\n    #!/usr/bin/env bash\n    echo \"{\\\"price\\\": \\\"150.0\\\"}\" # put your desired fixed price amount here \n    sleep 60 # locking the price for a 60 seconds period\nOnce you have created your bidding model, save it as \nmodel-eth.sh\n (or whatever name you feel seems appropriate).\n2. Setting up an Auction Keeper for a Collateral (Flip) Auction\nCollateral Auctions will be the most common type of auction that the community will want to create and operate Auction keepers for. This is due to the fact that Collateral auctions will occur much more frequently than Flap and Flop auctions.\nExample (Flip Auction Keeper):\nThis example/process assumes that the user has an already existing shell script that manages their environment and connects to the Ethereum blockchain and that you have some Dai and Kovan ETH in your wallet. If you don't have any balance, check the section below on how to get some.\nAn example on how to set up your environment: as \nmy_environment.sh\nSERVER_ETH_RPC_HOST=https://your-ethereum-node\nSERVER_ETH_RPC_PORT=8545\nACCOUNT_ADDRESS=0x16Fb96a5f-your-eth-address-70231c8154saf\nACCOUNT_KEY=\"key_file=/Users/username/Documents/Keeper/accounts/keystore,pass_file=/Users/username/Documents/keeper/accounts/pass\"\nSERVER_ETH_RPC_HOST\n - Should not be an infura node, as it doesn't provide all the functionality that the python script needs\n\nACCOUNT_KEY\n - Should have the absolute path to the keystore and password file. Define the path as shown above, as the python script will parse through both the keystore and password files.\n#!/bin/bash\ndir=\"$(dirname \"$0\")\"\n\u0432\u0496\u04e2\nsource my_environment.sh  # Set the RPC host, account address, and keys.\nsource _virtualenv/bin/activate # Run virtual environment\n\u0432\u0496\u04e2\n# Allows keepers to bid different prices\nMODEL=$1\n\u0432\u0496\u04e2\nbin/auction-keeper \\\n    --rpc-host ${SERVER_ETH_RPC_HOST:?} \\\n    --rpc-port ${SERVER_ETH_RPC_PORT?:} \\\n    --rpc-timeout 30 \\\n    --eth-from ${ACCOUNT_ADDRESS?:} \\\n    --eth-key ${ACCOUNT_KEY?:} \\\n    --type flip \\\n    --ilk ETH-A \\\n    --from-block 14764534 \\\n    --vat-dai-target 1000 \\\n    --model ${dir}/${MODEL} \\\n    2> >(tee -a -i auction-keeper-flip-ETH-A.log >&2)\nOnce finalized, you should save your script to run your Auction Keeper as \nflip-eth-a.sh \n(or something similar to identify that this Auction Keeper is for a Flip Auction). In addition, make sure to verify the above copy+pasted script doesn't create extra spaces or characters on pasting+saving in your editor. You will notice an error when running it later below otherwise.\nImportant Note about Running Auction Keepers on the Ethereum Mainnet!\nIf you get to the point where the auction keeper bot is not accepting mainnet as a valid argument, this is because there is no \nnetwork\n parameter. To fix this, just omit that parameter.\nOther Notes:\nAll Collateral types (\nilk\n's) combine the name of the token and a letter corresponding to a set of risk parameters. For example, as you can see above, the example uses ETH-A. Note that ETH-A and ETH-B are two different collateral types for the same underlying token (WETH) but have different risk parameters.\nFor the MCD addresses, we simply pass \n--network mainnet|kovan\n in and it will load the required JSON files bundled within auction-keeper (or pymaker).\n3. Passing the bidding the model as an argument to the Keeper script\n1.\nConfirm that both your bidding model (model-eth.sh) and your script (flip-eth-a.sh) to run your Auction Keeper are saved.\n2.\nThe next step is to \nchmod +x\n both of them.\n3.\nLastly, run \nflip-eth-a.sh model-eth.sh\n to pass your bidding model into your Auction Keeper script.\nExample of a working keeper:\nAfter running the \n./flip-eth-a.sh model-eth.sh\n command you will see an output like this:\n019-10-31 13:33:08,703 INFO     Keeper connected to RPC connection https://parity0.kovan.makerfoundation.com:8545\n2019-10-31 13:33:08,703 INFO     Keeper operating as 0x16Fb96a5fa0427Af0C8F7cF1eB4870231c8154B6\n2019-10-31 13:33:09,044 INFO     Executing keeper startup logic\n2019-10-31 13:33:09,923 INFO     Sent transaction DSToken('0x1D7e3a1A65a367db1D1D3F51A54aC01a2c4C92ff').approve(address,uint256)('0x9E0d5a6a836a6C323Cf45Eb07Cb40CFc81664eec', 115792089237316195423570985008687907853269984665640564039457584007913129639935) with nonce=1257, gas=125158, gas_price=default (tx_hash=0xc935e3a95e5d0839e703dd69b6cb2d8f9a9d3d5cd34571259e36e771ce2201b7)\n2019-10-31 13:33:12,964 INFO     Transaction DSToken('0x1D7e3a1A65a367db1D1D3F51A54aC01a2c4C92ff').approve(address,uint256)('0x9E0d5a6a836a6C323Cf45Eb07Cb40CFc81664eec', 115792089237316195423570985008687907853269984665640564039457584007913129639935) was successful (tx_hash=0xc935e3a95e5d0839e703dd69b6cb2d8f9a9d3d5cd34571259e36e771ce2201b7)\n2019-10-31 13:33:13,152 WARNING  Insufficient balance to maintain Dai target; joining 91.319080635247876480 Dai to the Vat\n2019-10-31 13:33:13,751 INFO     Sent transaction <pymaker.dss.DaiJoin object at 0x7fa6e91baf28>.join('0x16Fb96a5fa0427Af0C8F7cF1eB4870231c8154B6', 91319080635247876480) with nonce=1258, gas=165404, gas_price=default (tx_hash=0xcce12af8d27f9d6185db4b359b8f3216ee783250a1f3b3921256efabb63e22b0)\n2019-10-31 13:33:16,491 INFO     Transaction <pymaker.dss.DaiJoin object at 0x7fa6e91baf28>.join('0x16Fb96a5fa0427Af0C8F7cF1eB4870231c8154B6', 91319080635247876480) was successful (tx_hash=0xcce12af8d27f9d6185db4b359b8f3216ee783250a1f3b3921256efabb63e22b0)\n2019-10-31 13:33:16,585 INFO     Dai token balance: 0.000000000000000000, Vat balance: 91.319080635247876480133691494546726938904901298\n2019-10-31 13:33:16,586 INFO     Watching for new blocks\n2019-10-31 13:33:16,587 INFO     Started 1 timer(s)\nNow the keeper is actively listening for any action. If it sees an undercollateralized position, then it will try to bid for it.\nAuction Keeper Arguments Explained\nTo participate in all auctions, a separate keeper must be configured for \nflip\n of each collateral type, as well as one for \nflap\n and another for \nflop\n.\n1.\n--type\n - the type of auction the keeper is used for. In this particular scenario, it will be set to \nflip\n.\n2.\n--ilk\n - the type of collateral.\n3.\n--addresses\n - .json of all of the addresses of the MCD contracts as well as the collateral types allowed/used in the system.\n4.\n--vat-dai-target\n - the amount of DAI which the keeper will attempt to maintain in the Vat, to use for bidding. It will rebalance it upon keeper startup and upon \ndeal\ning an auction.\n5.\n--model\n - the bidding model that will be used for bidding.\n6.\n--from-block\n to the block where the first urn was created to instruct the keeper to use logs published by the vat contract to bulid a list of urns, and then check the status of each urn.\nCall \nbin/auction-keeper --help\n for a complete list of arguments.\nAuction Keeper Limitations\nIf an auction starts before the auction Keeper has started, the Keeper will not participate in the auction until the next block has been mined.\nKeepers do not explicitly handle global settlement (\nEnd\n). If global settlement occurs while a winning bid is outstanding, the Keeper will not request a \nyank\n to refund the bid. The workaround is to call \nyank\n directly using \nseth\n.\nThere are some Keeper functions that incur gas fees regardless of whether a bid is submitted. This includes, but is not limited to, the following actions:\nSubmitting approvals.\nAdjusting the balance of surplus to debt.\nBiting a CDP or starting a flap or flop auction, even if insufficient funds exist to participate in the auction.\nThe Keeper will not check model prices until an auction officially exists. As such, it will \nkick\n, \nflap\n, or \nflop\n in response to opportunities regardless of whether or not your DAI or MKR balance is sufficient to participate. This imposes a gas fee that must be paid.\nAfter procuring more DAI, the Keeper must be restarted to add it to the \nVat\n.\n5. Accounting\nThe Auction contracts exclusively interact with DAI (for all auctions types) and collateral (for \nflip\n auctions) in the \nVat\n. More explicitly speaking:\nThe DAI that is used to bid on auctions is withdrawn from the \nVat\n.\nThe Collateral and surplus DAI won at auction end is placed in the \nVat\n.\nBy default, all the DAI and collateral within your \neth-from\n account is \nexit\n'ed from the Vat and added to your account token balance when the Keeper is shut down. Note that this feature may be disabled using the \nkeep-dai-in-vat-on-exit\n and \nkeep-gem-in-vat-on-exit\n switches, respectively. The use of an \neth-from\n account with an open CDP is discouraged, as debt will hinder the auction contracts' ability to access your DAI, and the \nauction-keeper\n's ability to \nexit\n DAI from the \nVat\n.\nWhen running multiple Auction Keepers using the same account, the balance of DAI in the \nVat\n will be shared across all of the Keepers. If using this feature, you should set \n--vat-dai-target\n to the same value for each Keeper, as well as sufficiently high in order to cover total desired exposure.\nNote:\nMKR used to bid on \nflap\n auctions is directly withdrawn from your token balance. The MKR won at \nflop\n auctions is directly deposited to your token balance.\nGetting Kovan MCD DAI, MKR and other Collateral tokens\n1. Getting MCD K-DAI (K-MCD 0.2.12 Release)\nContract address\n: \n0xb64964e9c0b658aa7b448cdbddfcdccab26cc584\n1.\nLog into your MetaMask account from the browser extension. Add or confirm that the custom MCD K-DAI token is added to your list of tokens.\nThis done by selecting \"Add Token\" and then by adding in the details under the \"Custom token\" option.\n2.\nHead to Oasis Borrow \nhere\n.\nConfirm that you are in fact on the Kovan Network before proceeding.\n3.\nConnect your MetaMask account.\n4.\nApprove the MetaMask connection.\n5.\nBelow the \"Overview\" button, find and select the plus sign button to start setting up your CDP.\n6.\nSelect the collateral type you want to proceed with and click \"Continue\".\ne.g. ETH-A\n7.\nDeposit your K-ETH and generate K-DAI by selecting and inputing an amount of K-ETH and the amount of K-DAI you would like to generate. To proceed, click \"Continue\".\ne.g. Deposit 0.5 K-ETH and generate 100 DAI.\n8.\nClick on the checkbox to confirm that you have read and accepted the \nTerms of Service\n then click the \"Create CDP\" button.\n9.\nApprove the transaction in your MetaMask extension.\n10.\nClick the \"Exit\" button and wait for your CDP to be created.\nAfter all of these steps have been completed, you will have the generated MCD K-DAI and it will be present within your wallet. You can easily payback your DAI or generate more.\n2. Getting MCD K-MKR (K-MCD 1.0.2 Release)\nContract address:\n \n0xaaf64bfcc32d0f15873a02163e7e500671a4ffcd\nThis requires familiarity with Seth as well as having the tool set up on your local machine. If unfamiliar, use \nthis\n guide to install and set it up.\nRun the following command in Seth:\nseth send 0xcbd3e165ce589657fefd2d38ad6b6596a1f734f6 'gulp(address)' 0xaaf64bfcc32d0f15873a02163e7e500671a4ffcd\nAddress information:\nThe \n0x94598157fcf0715c3bc9b4a35450cce82ac57b20\n address is the faucet that issues 1 MKR per request.\nThe \n0xaaf64bfcc32d0f15873a02163e7e500671a4ffcd\n address is that of the MCD K-MKR token. It will issue 1 MKR.\nImportant Note:\n The faucet address and token addresses often change with each dss deployment. The current addresses displayed above are from the \n0.2.12 Release\n. Please visit \nhttps://changelog.makerdao.com/\n for the most updated release version.\nPlease refer to this \nguide\n to obtain collateral test tokens for Kovan.\n3. Getting MCD Collateral Tokens\n6. Testing your Keeper\nTo help with the testing of your Auction Keeper, we have created a collection of python and shell scripts herein that may be used to test \nauction-keeper\n, \npymaker\n's auction facilities, and relevant smart contracts in \ndss\n. For more information about testing your Auction Keeper with your own testchain visit \ntests/manual/README\n.\n7. Support\nWe welcome any questions or concerns about the Auction Keepers in the \n#keeper\n channel in the Maker Chat.\nKeepers - \nPrevious\nAuction Keepers\nNext\n - Keepers\nMarket Maker Keepers\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/auction-keepers/auction-keeper-bot-setup-guide", "title": "Auction Keeper Bot Setup Guide"}}
{"page_content": "Market Maker Keeper Bot Setup Guide\nA Marketing Making Bot Set up Guide\nLevel:\n Intermediate\nEstimated Time:\n 60 minutes\nAudience:\n Developers\nGuide Agenda\n1.\nIntroduction\n2.\nPrerequisites\n3.\nInstallation\n4.\nTesting\n5.\nBands and Bands Configuration\n1.\nExample\n6.\nOrder Rate Limitation\n7.\nData Templating Language\n8.\nPrice Feed Configuration\n1.\nExample\n9.\nRunning Keepers\n1.\nExample (Oasis Market Maker Keeper)\n10.\nSupport Information\n1. Introduction\nThis guide is dedicated to showing you how to create your very own Market Maker Keeper Bot as well as educate the community about Market Maker Keeper bots and help both users and developers understand the value of this incredible software. We are proud to say that all of the code needed to get a Market Maker Keeper bot up and running is open-sourced.\nList of current exchanges that Market Maker Keeper Bots can be built for\nOasisDEX (\noasis-market-maker-keeper\n)\nEtherDelta (\netherdelta-market-maker-keeper\n)\nRadarRelay and ERCdEX (\n0x-market-maker-keeper\n)\nParadex (\nparadex-market-maker-keeper\n)\nDDEX (\nddex-market-maker-keeper\n)\nEthfinex (\nethfinex-market-maker-keeper\n)\nGoPax (\ngopax-market-maker-keeper\n)\nOKEX (\nokex-market-maker-keeper\n)\nTheOcean (\ntheocean-market-maker-keeper\n)\n2. Prerequisite\nGit\n\u0432\u0496\u04e2\nPython v3.6.6\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nvirtualenv\n\u0432\u0496\u04e2\nThis project requires \nvirtualenv\n to be installed if you want to use Maker's python tools. This helps with making sure that you are running the right version of python and checks that all of the pip packages that are installed in the \ninstall.sh\n are in the right place and have the right versions.\n\u0432\u0496\u04e2\nX-code\n (for macs)\n3. Getting Started (Installation)\n1. Clone the \nmarket-maker-keeper\n repository and switch into its directory:\n git clone \n[email\u00a0protected]\n:makerdao/market-maker-keeper.git\n cd market-maker-keeper \n2. Initializing the git submodules that will bring in both the pymaker and the pyexchange library:\ngit submodule update --init --recursive\n3. Set up the virtual env and activate it:\n python3 -m venv _virtualenv\n source _virtualenv/bin/activate\n4. Check to make sure you have the correct version (Python 3.6.6) of Python by running:\n python3 -V\n5. Install Requirements:\npip3 install $(cat requirements.txt $(find lib -name requirements.txt | sort) | sort | uniq | sed 's/ *== */==/g')\nNote:\n This command is (used in place of \npip install -r requirements.txt\n) for iterating through all the dependencies in the lib directory to grab all of the requirements needed.\nPotential errors that could arise:\nNeeding to upgrade to \npip\n version 19.2.2.\nRun: \npip install --upgrade pip\n to fix.\nInstalling \njsonnet\n (if running macOS Mojave)\nTo fix, run the following:\nxcode-select --install\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg\npip3 install jsonnet==0.9.5\nRe-run:\n \npip3 install $(cat requirements.txt $(find lib -name requirements.txt | sort) | sort | uniq | sed 's/ *== */==/g')\nOther \nPotential Installation Issues:\nRead the following document for other known Ubuntu and macOS issues (\npymaker\n).\n4. Testing\nThere is quite a lot of value in running all the unit tests to make sure \nmarket-maker keeper\n has been installed properly. After the repository has been cloned and the installation has been completed, you can run unit tests by executing the following commands.\nFirstly, the following command will install the libraries required to run unit tests:\npip3 install -r requirements-dev.txt\n\u0432\u0496\u04e2\nTo run the unit tests (py.test, etc..), use the following script:\n./test.sh\n\u0432\u0496\u04e2\nExample output:\n===================================== test session starts =====================================\nplatform darwin -- Python 3.6.6, pytest-3.3.0, py-1.8.0, pluggy-0.6.0\nrootdir: /Users/charlesst.louis/market-maker-keeper, inifile:\nplugins: timeout-1.2.1, mock-1.6.3, cov-2.5.1, asyncio-0.8.0\ncollected 97 items                                                                            \n\u0432\u0496\u04e2\ntests/test_airswap_market_maker_keeper.py ................                              [ 16%]\ntests/test_band.py ......                                                               [ 22%]\ntests/test_etherdelta_market_maker_keeper.py ..........................                 [ 49%]\ntests/test_feed.py .                                                                    [ 50%]\ntests/test_limit.py .......                                                             [ 57%]\ntests/test_oasis_market_maker_cancel.py ...                                             [ 60%]\ntests/test_oasis_market_maker_keeper.py ...................                             [ 80%]\ntests/test_price_feed.py ............                                                   [ 92%]\ntests/test_reloadable_config.py .......                                                 [100%]\n\u0432\u0496\u04e2\n---------- coverage: platform darwin, python 3.6.6-final-0 -----------\nName                                                    Stmts   Miss  Cover\n---------------------------------------------------------------------------\nmarket_maker_keeper/__init__.py                             0      0   100%\nmarket_maker_keeper/airswap_market_maker_keeper.py        252    142    44%\nmarket_maker_keeper/band.py                               260     37    86%\nmarket_maker_keeper/bibox_market_maker_keeper.py           93     93     0%\nmarket_maker_keeper/bitinka_market_maker_keeper.py         96     96     0%\nmarket_maker_keeper/bittrex_market_maker_keeper.py         96     96     0%\nmarket_maker_keeper/coinbase_market_maker_keeper.py       103    103     0%\nmarket_maker_keeper/coinbene_market_maker_keeper.py        95     95     0%\nmarket_maker_keeper/control_feed.py                         7      5    29%\nmarket_maker_keeper/ddex_market_maker_keeper.py           126    126     0%\nmarket_maker_keeper/ercdex_market_maker_keeper.py          12     12     0%\nmarket_maker_keeper/etherdelta_market_maker_keeper.py     193    142    26%\nmarket_maker_keeper/ethfinex_market_maker_keeper.py        94     94     0%\nmarket_maker_keeper/feed.py                                84     46    45%\nmarket_maker_keeper/gas.py                                 20     10    50%\nmarket_maker_keeper/gateio_market_maker_keeper.py         106    106     0%\nmarket_maker_keeper/gopax_market_maker_keeper.py           99     99     0%\nmarket_maker_keeper/hitbtc_market_maker_keeper.py          98     98     0%\nmarket_maker_keeper/idex_market_maker_keeper.py           193    193     0%\nmarket_maker_keeper/imtoken_pricing_server.py              51     51     0%\nmarket_maker_keeper/imtoken_utils.py                       97     97     0%\nmarket_maker_keeper/kucoin_market_maker_keeper.py         108    108     0%\nmarket_maker_keeper/limit.py                               46      0   100%\nmarket_maker_keeper/liquid_market_maker_keeper.py          97     97     0%\nmarket_maker_keeper/mpx_market_maker_keeper.py            137    137     0%\nmarket_maker_keeper/oasis_market_maker_cancel.py           38     22    42%\nmarket_maker_keeper/oasis_market_maker_keeper.py          133     94    29%\nmarket_maker_keeper/okex_market_maker_keeper.py            92     92     0%\nmarket_maker_keeper/order_book.py                         219    188    14%\nmarket_maker_keeper/order_history_reporter.py              38     26    32%\nmarket_maker_keeper/paradex_market_maker_keeper.py        131    131     0%\nmarket_maker_keeper/price_feed.py                         187     86    54%\nmarket_maker_keeper/reloadable_config.py                   67      3    96%\nmarket_maker_keeper/setzer.py                              24     17    29%\nmarket_maker_keeper/spread_feed.py                          7      5    29%\nmarket_maker_keeper/tethfinex_market_maker_keeper.py      149    149     0%\nmarket_maker_keeper/theocean_market_maker_keeper.py       129    129     0%\nmarket_maker_keeper/util.py                                 8      4    50%\nmarket_maker_keeper/zrx_market_maker_keeper.py            177    177     0%\nmarket_maker_keeper/zrxv2_market_maker_keeper.py           26     26     0%\n---------------------------------------------------------------------------\nTOTAL                                                    3988   3232    19%\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\n================================== 97 passed in 4.04 seconds ==================================\n\u0432\u0496\u04e2\n5. Understanding Bands Configuration\nThe Bands configuration file is directly related to how your Market Maker Keeper will work. As mentioned in the introduction, these Keepers continuously monitor and adjust their positions in the order book, maintaining open buy and sell orders in multiple bands at the same time. For each \nbuy\n and \nsell\n band, the Keepers aim to have open orders for at least the \nminAmount\n. In both cases, they will ensure the price of open orders stay within the \n<minMargin, maxMargin>\n range from the current price. When running, Keepers place orders for the average amounts (\navgAmount\n) in each band by using use \navgMargin\n to calculate the order price.\nAs long as the price of orders stays within the set band(s) (i.e. it is in between the \n<minMargin,maxMargin>\n range from the current price), the Keepers keep them open/running. If some orders leave the band, they either enter another adjacent band or fall outside all bands. In the case of the latter, they would get immediately canceled. In case of the former, Keepers can keep these orders open as long as their amount is within the \n<minAmount,maxAmount>\n ranges for the band they just entered. If it is above the maximum, some of the open orders will get canceled and potentially a new one will be created to bring the total amount back within the range. If it is below the minimum, a new order gets created for the remaining amount so that the total amount of orders in this band is equal to \navgAmount\n. The same process will happen if the total amount of open orders in a band falls below the \nminAmount\n as a result of other market participants taking these orders. In this case, a new order gets created for the remaining amount so the total amount of orders in this band is equal to \navgAmount\n. There are some Keepers that will constantly use gas to cancel orders (ex: OasisDEX, EtherDelta and 0x) and create new ones (OasisDEX) as the price changes. Gas usage can be limited by setting the margin and amount ranges wide enough but also by making sure that the bands are always adjacent to each other and that their \n<min,max>\n amount ranges overlap.\nFile format\nThe bands configuration file consists of two main sections:\n1.\nbuyBands\n2.\nsellBands\nNote:\n Each section is an array containing one object per each band.\nThe \nminMargin\n and \nmaxMargin\n fields in each band object represent the margin (spread) range of that band. These ranges may not overlap for bands of the same type (\nbuy\n or \nsell\n), and should be adjacent to each other for better Keeper performance (where fewer orders will get canceled if the bands are adjacent to each other). The \navgMargin\n represents the margin (spread) of newly created orders within a band.\nGlossary\n1.\nminAmount\n - the\n minimum amount for keeper engagement for a band.\n2.\navgAmount\n - the target amount for keeper engagement for a band.\n3.\nmaxAmount\n - the\n maximum amount for keeper engagement for a band.\n4.\ndustCutoff\n - a\n field for the minimum amount of every single order created in each individual band (expressed in buy tokens for buy bands and in sell tokens for sell bands).\nSetting this to a non-zero value prevents Keepers from creating a lot of very tiny orders, which can cost a lot of gas. For example, in the case of OasisDEX, it can result in an order that is too small getting rejected by other exchanges.\nSetting up your own Bands Configuration File:\n1. Creating your bands.json file\nTo start, take the sample configuration file below and copy-paste it to a \n.json\n file within the root directory of your \nmarket-maker-keeper\n folder. For ease of use, we sugges to name it \nbands.json\n. This bands file will get configured as a command-line argument when we start up the Market Maker Keeper.\nA Sample bands.json file containing two Bands:\nThis example shows bands for the ETH-DAI pair, where ETH represents the base currency and DAI as the quote currency:\n{\n    \"_buyToken\": \"DAI\",\n    \"buyBands\": [\n        {\n            \"minMargin\": 0.005,\n            \"avgMargin\": 0.01,\n            \"maxMargin\": 0.02,\n            \"minAmount\": 20.0,\n            \"avgAmount\": 30.0,\n            \"maxAmount\": 40.0,\n            \"dustCutoff\": 0.0\n        },\n        {\n            \"minMargin\": 0.02,\n            \"avgMargin\": 0.025,\n            \"maxMargin\": 0.03,\n            \"minAmount\": 40.0,\n            \"avgAmount\": 60.0,\n            \"maxAmount\": 80.0,\n            \"dustCutoff\": 0.0\n        }\n    ],\n    \"buyLimits\": [],\n\u0432\u0496\u04e2\n    \"_sellToken\": \"ETH\",\n    \"sellBands\": [\n        {\n            \"minMargin\": 0.005,\n            \"avgMargin\": 0.01,\n            \"maxMargin\": 0.02,\n            \"minAmount\": 2.5,\n            \"avgAmount\": 5.0,\n            \"maxAmount\": 7.5,\n            \"dustCutoff\": 0.0\n        },\n        {\n            \"minMargin\": 0.02,\n            \"avgMargin\": 0.025,\n            \"maxMargin\": 0.05,\n            \"minAmount\": 4.0,\n            \"avgAmount\": 6.0,\n            \"maxAmount\": 8.0,\n            \"dustCutoff\": 0.0\n        }\n    ],\n    \"sellLimits\": []\n}\nThis \nbands.json\n file should be adequate enough for you to paste and run it as is. Of course, you are free to configure it however you would like.\nNote:\n Since this example will be focused on getting a Market Maker Keeper set up on Kovan, you need to make certain that you have enough Kovan ETH (K-Eth) to get your Keeper up and running. To receive Kovan ETH, join the following Gitter Channel: \nhttps://gitter.im/kovan-testnet/faucet\n and post your ETH address from your MetaMask account to the main chat. The Kovan faucet will then populate your wallet with the test funds (note that this could take a couple of minutes or a couple of hours as it is done manually by the channel\u0432\u0496\u04b7s administrator).\n2. Setting Amounts\nYou will need to set this up if you are going to be trading small amounts to start. This will need to be set up such that those amounts are sufficiently meaningful on the exchange you want to work with (based on the rules of the exchanges that you want to work. For example, their specificly set dust limits).\nAs mentioned above, there is one parameter in the configuration file (\ndustCutoff\n)\n that will be used to determine the \nminAmount\n of trade quantity. The \ndustCutoff\n will need to be set \nhigher than/or at\n the \nminAmount\n trade quantity of the specific exchange. This is to make sure you don't create trades that are less than an exchanges' minimum trade requirements. Note that in your configuration file, you can also lower the required quantities to make it easier on yourself. Reducing the K-ETH amounts will be helpful in reducing wait times as you likely won't want to wait long periods to get enough K-ETH to run your Keeper).\nBands Example\nHere, we will be going over some example interactions using the \nbands.json file\n described above. These examples assume that it is denominated in DAI and the price of 10 DAI is 1 ETH.\nUsing Band 1\nIf we look at the first buy band, the initial buy order will be 30 DAI (\navgAmount\n) with the price of -> \nprice - (price * avgMargin)\n -> \n0.1 - (0.1 * 0.01)\n -> \n0.099 ETH per Dai\n.\nIf the \nbuy\n order listed above (30 DAI @ 0.099 ETH) gets partially filled (15 DAI are purchased), then we will have (15 DAI remaining in the order). However, this amount is below the band's \nminAmount\n (20 DAI), therefore, another whole order of 15 DAI will be placed on the exchange at the same price of 0.099 ETH.\nIn addition to the \nbuy\n orders, when the Market Maker Keeper starts up, two \nsell\n orders will also be placed.\nUsing Band 2\nFor ease of explanation, let's assume we are selling ETH priced at 100.00 DAI (5 ETH @ 101 DAI and 6 ETH @ 102.5 DAI).\nNow imagine a situation where the price of ETH suddenly drops to 97.50 DAI, pushing the bands down. In this scenario, the second band will start working and will become responsible for both of the \nsell\n orders, as they fit in between the second band's \nminMargin\n and \nmaxMargin\n.\nThe Market Maker Keeper will now reset it's bands by performing the following:\n1.\nCreating an order in \nBand 1\n (5 ETH @ 98.475 DAI) using \navgMargin\n and \navgAmount\n.\n2.\nCancelling the second order (5 ETH @ 102.5 DAI) (which is now in \nBand 2\n) becuase \nmaxMargin\n has been breached (when \nprice + (price * maxMargin) = orderPrice\n -> \n97.5 + (97.5 * 0.05)\n -> 102.375 > 102.5).\n3.\nKeep the first order (5 ETH @ 101 DAI), which is now in \nBand 2\n because it is within \nminMargin\n and \nmaxMargin\n of \nBand 2.\n4.\nCreating an order in \nBand 2\n (1 ETH @ 99.937 DAI) using \navgMargin\n and \navgAmount\n.\nThis results in a total of 3 orders:\nBand 1\n -> (5 ETH @ 98.475 DAI)\nBand 2\n -> (5 ETH @ 101 DAI)\nBand 2\n -> (1 ETH @ 99.837 DAI)\n6. \nOrder Rate Limitation\nNext, we will want to add the \nRate Limitation\n to the configurations file. This will make sure that we don't constantly churn out old orders as well as help manage gas consumption. We do this because we want the \nperiod\n and the \namount\n to be set to a low amount when we start out. This is done because we don't want new users' Market Maker Keeper bots to be frantically trading all of the time. The goal here is that we want to set up our initial states such that it is only placing an order every 5 min or so (or whatever time amount you decide on).\nThere are two (optional) limit sections (\nbuyLimits\n and \nsendLimits\n) that can be used for limiting the \nmaximum\n rate of orders created by Market Maker Keepers. They both use the same format.\nExample of order rate limits:\n\"buyLimits\": [\n    {\n        \"period\": \"1h\",\n        \"amount\": 50.0\n    },\n    {\n        \"period\": \"1d\",\n        \"amount\": 200.0\n    }\n]\nThe \nperiod\n defines the amount of time that the limit should be applied over.\nThe \namount\n is the maximum amount of orders that should be placed during the set \nperiod\n amount.\nIn the example above, the \nperiod\ns are set to 1-hour and 1-day and the \namount\ns are set to 50.0 orders and 200.0 orders. This means that over the course of 1-hour, only 50.0 orders can be placed and over the course of 1-day, only 200.0 orders can be placed. The amounts will be expressed either in terms of the \nbuy\n or the \nsell\n token, this will depend on the section. Note that the above snippet imposes a limit of \n50.0\n \nbuy\n token within each 60-minute window. Additionally, a maximum of \n200.0\n \nbuy\n tokens within each 24-hour window. Note that the supported time units are \ns\n, \nm\n, \nh\n, \nd\n, and \nw\n.\n7. \nData Templating Language\nThe \nJsonnet\n data templating language that can be used for the configuration file.\nIn the case of the data templating language, think of this like a pre-processing language for parsing the file. The whole purpose of the jsonnet is to set up a configuration file such that you can have it increment based on a price. Therefore, in addition to the price feed, you can also base percentages away from the market price. As you can see below, there is a hardcoded amount/price and then the amounts below it which are dependent on the price.\n{\n  \"_price\": 10,\n\u0432\u0496\u04e2\n  \"_buyToken\": \"DAI\",\n  \"buyBands\": [\n    {\n      \"minMargin\": 0.020,\n      \"avgMargin\": 0.050,\n      \"maxMargin\": 0.075,\n      \"minAmount\": 0.05 * $._price,\n      \"avgAmount\": 0.25 * $._price,\n      \"maxAmount\": 0.35 * $._price,\n      \"dustCutoff\": 0.1\n    }\n  ],\n\u0432\u0496\u04e2\n  \"_sellToken\": \"ETH\",\n  \"sellBands\": []\n}\nNote:\n If you are working with a token that's price does not fluctuate wildly, you do not need to incorporate relative qualities for your amount. This is typically for people who want Market Maker Keepers open for months at a time and don't want to worry about having to change any of their configurations.\nAnother thing to note about these files is that the Market Maker Keeper reloads the configuration files automatically when it detects a change in them. This makes it easier as you don't have to constantly restart your Keeper bot when you change your band configurations. In short, this works by periodically taking a hash of the configuration file and comparing that hash with the current version. When it sees a change in that hash of the file, it will reload the configuration file and cancel orders as necessary to maintain the newly updated bands.\n8. Price Feed Configuration\nThe price feed is one of the most important determining factors of success in a Market Maker Keeper. If you have the bands set up the way you want, the price feed will help make sure your bands are set at meaningful levels relative to the inside market. If you have wide bands and your strategy is to add liquidity to handle market imbalances, then the price feed is not as important. However, as you tighten up the spreads, the price feed is a crucial component to ensure that you are going to profit in the market.\nBelow, we list some of the existing public feeds. You can also use web sockets if you have your own price feed that you want to use. In short, it works by each Market Maker Keeper taking in a \n--price-feed\n command-line argument which then determines the price used for market-making.\nAs of today, these are the possible values of this argument that we list some of the existing public feeds:\nfixed:200\n - uses a fixed price, (\n1.56\n in this example). See below for a more in-depth example. When on mainnet, you typically won't use a fixed amount but it is an ideal example for this walkthrough as there aren't price feeds for Kovan.\neth_dai\n - uses the price from the GDAX WebSocket ETH/USD price feed.\neth_dai-setzer\n - uses the average of Kraken and Gemini ETH/USD prices.\neth_dai-tub\n - uses the price feed from \nTub\n (only works for keepers being able to access an Ethereum node).\ndai_eth\n - inverse of the \neth_dai\n price feed.\ndai_eth-setzer\n - inverse of the \neth_dai-setzer\n price feed.\ndai_eth-tub\n - inverse of the \neth_dai-tub\n price feed.\nbtc_dai\n - uses the price from the GDAX WebSocket BTC/USD price feed.\ndai_btc\n - inverse of the \nbtc_dai\n price feed.\nws://...\n or \nwss://...\n - uses a price feed advertised over a WebSocket connection (custom protocol).\nAdditionally, we have a Uniswap price feed that can be used by Market Maker Keepers: \nhttps://github.com/makerdao/uniswap-price-feed \n.\nNote:\n The \n--price-feed\n command line argument can also contain a comma-separated list of several different price feeds. In this case, if one of them becomes unavailable, the next one in the list will be used instead. All listed price feeds will be constantly running in the background, the second one and following ones ready to take over when the first one becomes unavailable. \nIn the example below (in the Running Keepers section), you can see an example of how to use a fixed price amount.\n9. Running Market Maker Keepers\nEach Market Maker Keeper is a command-line tool which takes in generic command-line arguments (such as \n--config\n, \n--price-feed\n, \n--price-feed-expiry\n, \n--debug\n, etc.) as well as some arguments which are specific to that particular Keeper (such as Ethereum node parameters, addresses, exchange API keys, etc.). All accepted command-line arguments are listed in the example section below. They can also be discovered by trying to start a Market Maker Keeper with the \n--help\n argument.\nExample (Oasis Market Maker Keeper)\nIn order to run \noasis-market-maker-keeper\n, you will need to go through the following process:\n1.\nFirstly, you would deploy an Ethereum node (we recommend Parity).\n2.\nGenerate an account in it.\n3.\nPermanently unlock that account.\n4.\nTransfer some tokens to it.\n5.\nLastly, you can run the keeper (as seen below).\nThe below file should be copy and pasted into a new file within the root directory of the repository (\nmarket-maker-keeper\n). This should be placed within the same folder where you put the \nbands.json\n file.\n#!/bin/bash\n\u0432\u0496\u04e2\nbin/oasis-market-maker-keeper \\\n    --rpc-host 127.0.0.1 \\\n    --rpc-port  \\\n    --rpc-timeout 10 \\\n    --eth-from [address of your generated Ethereum account] \\\n\t\t--eth-key ${ACCOUNT_KEY} \\\n    --tub-address  0x448a5065aebb8e423f0896e6c5d525c040f59af3 \\\n    --oasis-address  0x14fbca95be7e99c15cc2996c6c9d841e54b79425 \\\n    --price-feed fixed:200 \\\n    --buy-token-address [address of the quote token, could be DAI] \\\n    --sell-token-address [address of the base token, could be WETH] \\\n    --config [path to the json bands configuration file, e.g bands.json] \\\n    --smart-gas-price \\\n    --min-eth-balance 0.001\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nMake sure that you retrieve and paste the correct contract addresses when using the above snippet.\n--eth-key ${ACCOUNT_KEY}\n - includes both the \n.json\n file (account.json) of your account and a \n.pass\n file (ex: account.pass) that contains your password in plaintext.\nIf you do not have an account, you can use \nMyEtherWallet\n on Kovan and export the account details (by means of the Keystore file method). Make sure that you download the .json file to your local machine as this is what you will need to set up the account.\nList of required Kovan Addresses for the above :\nV2_OASIS_SERVER1_ADDRESS= \nV2_OASIS_SERVER1_KEY=\"key_file=/home/ed/Projects/member-account.json,pass_file=/home/ed/Projects/member-account.pass\"\nTUB_ADDRESS=0xa71937147b55deb8a530c7229c442fd3f31b7db2 # tub-address\nSAI_ADDRESS=0xc4375b7de8af5a38a93548eb8453a498222c4ff2 # buy-token-address\nWETH_ADDRESS=0xd0a1e359811322d97991e03f863a0c30c2cf029c # sell-token-address\nOASIS_ADDRESS_NEW=0x4a6bc4e803c62081ffebcc8d227b5a87a58f1f8f # oasis-address\n\u0432\u0496\u04e2\nGeneral Notes:\nThe \nOASIS_SERVER1_KEY\n is simply your Kovan account private key (point this to your ETH accounts key file) and password file. If you do not have this, please set up a file with your password (in plain text).\nETH From is the address location where the market-maker-keeper is going to get the tokens that it uses to participate and place orders.\nExample:\n Since Oasis is a decentralized exchange (dex), it is on-chain, so you need to provide all of the relevant addresses to the dex. Most DEX's are like this because when you are configuring with a dex you need to pass many addresses in, whereas, with a centralized exchange you are generally giving an API key, and username and password (see below for an example of how the process differs for centralized exchanges differ versus decentralized exchanges).\nThis Oasis example is currently for \nSingle Collateral DAI\n (SCD), where we configure the TUB_ADDRESS. However, as we move over to \nMulti-Collateral DAI (MCD)\n the \nTUB_ADDRESS\n will be changed to the \nPIP_ADDRESS\n for MCD.\nOnce completed, you can now run your Market Maker Keeper! Follow the next steps to get it running:\n1.\nOpen up your terminal\n2.\nRun \nchmod +x <the file name of your version of the above bin/oasis-market-maker-keeper snippet>\n3.\nRun \n./<the file name of your version of the above bin/oasis-market-maker-keeper snippet>\n4.\nThat's it, your Market Maker Keeper should now be running!\nMarket Maker Keepers on Centralized Exchanges versus Decentralized Exchanges\nIn the situation where you want to use a centralized exchange vs. a decentralized exchange, the process differs a little:\n1.\nYou would need to have an existing account or create an account (on the exchange itself).\n2.\nGet the set of API keys with trading permissions (will usually need to be generated as well).\n3.\nDeposit tokens in your account on the exchange (as the keepers do not handle deposits and withdrawals themselves).\n4.\nRun the Market Maker Keeper.\n10. Support\nWe are here to help!\n We welcome any questions about market making in the \n#keeper\n channel in the Maker Chat.\nKeepers - \nPrevious\nMarket Maker Keepers\nNext\n - Keepers\nCage Keeper\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/keepers/market-maker-keepers/market-maker-keeper-bot-setup-guide", "title": "Market Maker Keeper Bot Setup Guide"}}
{"page_content": "Cat - Detailed Documentation\nThe Maker Protocol's Liquidation Agent\nContract Name:\n cat.sol\nType/Category:\n DSS\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nCat\n is the system's liquidation agent, it enables keepers to mark positions as unsafe and sends them to auction.\n2. Contract Details\nGlossary (Cat)\nMath\nmul(uint, uint)\n/\nrmul(uint, uint)\n - will revert on overflow or underflow\nbite(bytes32, address)\n will revert if \nlot\n or \nart\n are larger than or equal to 2^255.\nbite\n will not leave a Vault with debt and no collateral.\nAuth\nwards\n are allowed to call protected functions (Administration and \ncage()\n)\nStorage\nilks\n stores \nIlk\n structs\nIlk\n is the struct with the address of the collateral auction contract (\nflip\n), the penalty for that collateral to be liquidated (\nchop\n) and the maximum size of collateral that can be auctioned at once (\ndunk\n).\nlive\n must be \n1\n for the \nCat\n to \nbite\n. (see \ncage\n in mechanisms)\nbox\n the limit on the debt and penalty fees available for auction. [RAD]\ndunk\n (\"debt chunk\") amount of debt plus penalty fee per auction, in Dai. [RAD]\nvat\n address that conforms to a \nVatLike\n interface (see \nvat\n documentation\n for more info). It is set during the constructor and \ncannot be changed\n.\nvow\n address that conforms to a \nVowLike\n interface (see \nvow\n documentation\n for more info).\nThe values of all parameters here (except \nvat\n) are changeable by an address that is \nrely\ned on. For instance, the \nEnd\n module should be \nauth\ned to allow for it to call \ncage()\n and update \nlive\n from 1 to 0. Governance (through an \nauth\ned address) should be able to add collateral types to \nCat\n, update their parameters, and change the \nvow\n.\nUnsafe\nbite\n can be called at anytime but will only succeed if the Vault is unsafe. A Vault is unsafe when its locked collateral (\nink\n) times its collateral's liquidation price (\nspot\n) is less than its debt (\nart\n times the fee for the collateral \nrate\n). Liquidation price is the oracle-reported price scaled by the collateral's liquidation ratio.\nEvents\nBite\n: emitted when a \nbite(bytes32, address)\n is successfully executed. Contains:\nilk\n: Collateral\nurn\n: Vault address\nink\n: see \nlot\n in \nbite\nart\n: see \nart\n in \nbite\ntab\n: see \ntab\n in \nbite\nflip\n: address of the auction contract\nid\n: ID of the auction in the \nFlipper\n3. Key Mechanisms & Concepts\ncage()\nauth\nsets \nlive\n to 0 (prevents \nbite\n). See \nEnd\n documentation \nfor further description.\nOnce \nlive=0\n it cannot be set back to 1.\nbite(bytes32 ilk, address urn)\nbytes32 ilk\n parameter represents the collateral type that is being bitten.\naddress urn\n the address that identifies the Vault being bitten.\nreturns \nuint id\n which is the ID of the new auction in the \nFlipper\n.\nbite\n checks if the Vault is in an unsafe position and if it is, it starts a Flip auction for a piece of the collateral to cover a share of the debt.\nThe following is a line-by-line explanation of what \nbite\n does.\nfunction bite(bytes32 ilk, address urn) public returns (uint id) {\n  // Get the rate, spot, and dust from the ilk in the vat.\n  (,uint256 rate,uint256 spot,,uint256 dust) = vat.ilks(ilk);\n  // get the ink and art from the urn from the Vat.\n  (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n\u0432\u0496\u04e2\n  // ensure End has not happened\n  require(live == 1);\n  // require the Vault to be unsafe (see definition above).\n  require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\n\u0432\u0496\u04e2\n\t// Loads the `ilk` data into memory as an optimization.\n  Ilk memory milk = ilks[ilk];\n  // Declares a variable that will be assigned in the following scope.\n  uint256 dart;\n\u0432\u0496\u04e2\n\t// Defines a new scope, this prevents a stack too deep error in solidity\n  {\n\t\t// Calculate the available space in the box\n    uint256 room = sub(box, litter);\n\u0432\u0496\u04e2\n    // test whether the remaining space in the litterbox is dusty\n    require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\n\u0432\u0496\u04e2\n\t\t// Sets the amount of debt to be covered by the auction.\n    // (smaller of either the amount of normalized debt, maximum debt chunk size, or space in the box)\n    // divided by the rate, divided by the penalty fee.\n    dart = min(art, mul(min(milk.dunk, room), WAD) / rate / milk.chop);\n  }\n\u0432\u0496\u04e2\n\t// Takes the minimum of the collateral balance or the\n  // amount of collateral represented by the debt to be covered\n  uint256 dink = min(ink, mul(ink, dart) / art);\n\u0432\u0496\u04e2\n\t// Prevents no-collateral auctions\n  require(dart >  0      && dink >  0     , \"Cat/null-auction\");\n  // Protects against int overflow when converting from uint to int\n  require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\n\u0432\u0496\u04e2\n\t// Called in this way, vat.grab will:\n  // - Remove the dink and the dart from the bitten Vault (urn)\n  // - Adds the collateral (dink) to the Cat's gem\n  // - Adds the debt (dart) to the Vow's debt (vat.sin[vow])\n  // - Increases the total unbacked dai (vice) in the system\n  // This may leave the CDP in a dusty state\n  vat.grab(\n    ilk, urn, address(this), address(vow), -int256(dink), -int256(dart)\n  );\n  // Adds the debt to the debt-queue in Vow (Vow.Sin and Vow.sin[now])\n  vow.fess(mul(dart, rate));\n\u0432\u0496\u04e2\n  { // Avoid stack too deep\n    // This calcuation will overflow if dart*rate exceeds ~10^14,\n    // i.e. the maximum dunk is roughly 100 trillion DAI.\n    // Multiplies the accumulated rate by the normalized debt to be covered \n    // to get the total debt tab (debt + stability fee + liquidation penalty) for the auction.\n    uint256 tab = mul(mul(dart, rate), milk.chop) / WAD;\n    // Updates the amount of litter in the box\n    litter = add(litter, tab);\n\u0432\u0496\u04e2\n\t\t// Calls kick on the collateral's Flipper contract.\n    // tab is the total debt to be sent to auction\n    // gal: address(vow) sets up the Vow as the recipient of the Dai income for this auction\n    // bid: 0 indicates that this is the opening bid\n    // This moves the collateral from the Cat's gem to the Flipper's gem in the Vat\n    id = Kicker(milk.flip).kick({\n        urn: urn,\n        gal: address(vow),\n        tab: tab,\n        lot: dink,\n        bid: 0\n    });\n  }\n\u0432\u0496\u04e2\n  // Emits an event about the bite to notify actors (for instance keepers) about the new auction\n  emit Bite(ilk, urn, dink, dart, mul(dart, rate), milk.flip, id);\n}\nAdministration\nVarious file function signatures for administering \nCat\n:\nSetting new vow (\nfile(bytes32, address)\n)\nSetting new collateral (\nfile(bytes32, bytes32, address)\n)\nSetting penalty or dunk size for collateral (\nfile(bytes32, bytes32, uint)\n)\nUsage\nThe primary usage will be for keepers to call \nbite\n on a Vault they believe to be unsafe in order to start the auction process.\n4. Gotchas (Potential source of user error)\nWhen the \nCat\n is upgraded, there are multiple references to it that must be updated at the same time (\nEnd\n, \nVat.rely\n, \nVow.rely\n). It must also rely on the \nEnd\n, the system's \npause.proxy()\nA \nVat\n upgrade will require a new \nCat\nThe Cat stores each \nIlk\n's liquidation penalty and maximum auction size.\nEach ilk will be initiated with the \nfile\n for their \nFlipper\n; however, auctions cannot start until \nfile\n is also called to set the \nchop\n and the \ndunk\n. Without these auctions for either 0 gems or 0 dai would be created by calling \nbite\n on an unsafe Vault.\nbite\n needs to be called \nn\n times where \nn = urn.ink / ilks[ilk].dunk\n if \nn > 1\n. This allows for the possibility that the Vault becomes safe between \nbite\n calls either through increased collateral (in value or quantity), or decreased debt.\nCalling \nbite\n returns the auction \nid\n and emits and event with the \nid\n. This is required to bid in the \nFlipper\n on the auction.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nCoding Error\nA bug in the \nCat\n could lead to loss (or locking) of Dai and Collateral by assigning it to an address that cannot recover it (i.e. a bad Vow address or an incorrectly programmed Flipper). The main coding failure mode of \nCat\n is if it has a bug that causes auctions to cease to function. This would require upgrading the system to a corrected \nCat\n contract. If there is a bug in \nCat\n that reverts on \ncage\n then it would cause Shutdown could fail (until a correct \nCat\n is launched).\nFeeds\nThe \nCat\n relies indirectly on the price Feeds as it looks to the \nVat\n's tracking of the collateral prices (\nspot\n) to determine Vault safety. If this system breaks down, it could lead to theft of collateral (too low \nspot\n) or unbacked Dai (incorrectly high \nspot\n).\nGovernance\nGovernance can authorize and configure new collaterals for \nCat\n. This could lead to misconfiguration or inefficiencies in the system. Misconfiguration could cause \nCat\n not to operate properly or at all. For instance, if an \nIlk.dunk\n is set to be greater than 2**255 could allow for very, very large Vaults to be un-\nbite\n-able.\nInefficiencies in the \ndunk\n or \nchop\n could affect auctions. For instance, a \ndunk\n that is too large or too small could lead to disincentives for keepers to participate in auctions. A \nchop\n that is too small would not sufficiently dis-incentivize risky Vaults and too large could lead to it being converted to bad debt. Further discussion of how the parameters could lead to system attacks is described in this \nAuction Grinding paper\n.\nFlipper\nThe \nCat\n relies on an external Flipper contract to run the auction and moves the collateral from the \nCat\n to the \nFlipper\n contracts in the \nVat\n. A faulty collateral auction contract could result in the loss of collateral or dai or non-functioning auctions.\nMiscellaneous - \nPrevious\nLiquidations 1.2 System (Deprecated)\nNext\nFlipper - Detailed Documentation\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/miscellaneous/liquidations-1.2-system-deprecated/cat-detailed-documentation", "title": "Cat - Detailed Documentation"}}
{"page_content": "Flipper - Detailed Documentation\nThe Maker Protocol's Collateral Auction House\nContract Name:\n flip.sol\nType/Category:\n DSS \u0432\u0496\u201d> Collateral Auction Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\nFlip ETH-A\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nFlip BAT-A\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nSummary:\n Collateral Auctions are used to sell collateral from Vaults that have become undercollateralized in order to preserve the collateralization of the system. The Cat sends bitten collateral to the Flip module to be auctioned off to keepers. The collateral auction has two phases: \ntend\n and \ndent\n.\nFlip Interactions with the Maker Protocol \n2. Contract Details\nFlipper (Glossary)\nwards [usr: address]\n, \nrely\n/\ndeny\n/\nauth\n - Auth mechanisms\nBid\n - State of a specific Auction {\nbid\n, \nlot\n, \nguy\n, \ntic\n, \nend\n, \nusr\n, \ngal\n, \ntab\n}\nbid\n - Bid amount (DAI)/ DAI paid\nlot\n - quantity up for auction / collateral gems for sale\nguy\n - high bidder (address)\ntic\n - Bid expiry\nend\n - when the auction will finish / max auction duration\nusr\n - address of the Vault being auctioned. Receives gems during the \ndent\n phase\ngal\n - recipient of auction income / receives dai income (this is the Vow contract)\ntab\n - total dai wanted from the auction / total dai to be raised (in flip auction)\nbids[id: uint]\n - storage of all bids\nvat\n - storage of the Vat's address\nilk\n - id of the Ilk for which the Flipper is responsible\nbeg\n - minimum bid increase (default: 5%)\nttl\n - bid duration (default: 3 hours)\ntau\n - auction length (default: 2 days)\nkicks\n - Total auction count, used to track auction \nid\ns\nkick\n - function used by \nCat\n to start an auction / Put collateral up for auction\ntick\n - restart an auction if there have been 0 bids and the \nend\n has passed\ntend\n - first phase of an auction. Increasing Dai \nbid\ns for a set \nlot\n of Gems\ndent\n - second phase of an auction. Set Dai \nbid\n for a decreasing \nlot\n of Gems\nfile\n - function used by governance to set \nbeg\n, \nttl\n, and \ntau\ndeal\n - claim a winning bid / settles a completed auction\nyank\n - used during Global Settlement to move \ntend\n phase auctions to the \nEnd\n by retrieving the collateral and repaying dai to the highest bidder.\nclaw\n: reduces the amount of litter in the Cat's box\nParameters Set By Governance (through \nfile\n)\nbeg\nttl\ntau\nAlso, \nCat\n's \ndunk\n and \nchop\n also inform how \nFlip\n works as the \ndunk\n becomes the \nBid.lot\n and influences, along with the \nchop\n, the \nBid.tab\n.\nParameters Not Set By Governance\nvat\nilk\nBoth of these are set in the constructor and cannot be changed. If the Vat address is changed and each time a new collateral is added to the system, a new Flip will need to be deployed.\nAuthorizations\nThe Flipper must be \nVat.wish\n'ed on by the \nCat\n in order to \nflux\n during \nkick\n.\nThe \nEnd\n must be \nrely\n'ed on by the Flipper to allow for \nyank\n.\nThe \nCat\n must be \nrely\n'ed on by the Flipper to allow for \nkick\n.\n3. Key Mechanisms & Concepts\nThe Flip auction process begins with Maker Governance voters determining the collateral's minimum collateralization ratio (\nSpot.Ilk.mat\n) which is then tested against the Vault's state (collateral price, total debt owed) to determine whether the Vault is safe (See \nCat\n documentation for more information on the \nbite\n process). The last step of a \nbite\n is to \nkick\n a \nFlip\n auction for that specific collateral. Note that the liquidation penalty gets added to the \ntab\n when the \nFlip\n auction gets kicked. This only determines when the auction switches from \ntend\n to \ndent\n. However, this amount is not added to the total debt amount (only to the part that is being \npartially liquidated\n) unless everything has in fact been liquidated.\nGovernance also determines the size of the \nlot\n (where a \nlot\n is the quantity of collateral gems up for auction in a \nflip\n auction) when a Vault gets bitten. This allows for partial liquidations of large Vaults. Partial liquidations make auctions more flexible and less likely to impact the base collateral price by creating a single large auction. They also allow large Vaults to become safe again if the price recovers before the Vault is fully liquidated. Keepers will want to keep this in mind when biting unsafe Vaults as well since they will have a choice to start one or many partial liquidation auctions.\nStarting in the \ntend\n-phase, bidders compete for a fixed \nlot\n amount of Gem with increasing \nbid\n amounts of Dai. Once \ntab\n amount of Dai has been raised, the auction moves to the \ndent\n-phase. The point of the \ntend\n phase is to raise Dai to cover the system's debt.\nDuring the \ndent\n-phase bidders compete for decreasing \nlot\n amounts of Gem for the fixed \ntab\n amount of Dai. Forfeited Gem is returned to the liquidated Urn for the owner to retrieve. The point of the \ndent\n phase is to return as much collateral to the Vault holder as the market will allow.\nOnce the auction's last bid has expired or the auction itself has reached the \nend\n anyone can call \ndeal\n to payout the highest bidder (\nBid.guy\n). This moves Gem's from the Flipper's balance in the Vat to the bidder's balance.\nA diagram detailing the interactions a user has with Flipper, Cat and the Vow.\n4. Gotchas (Potential Source of User Error)\nKeepers\nIn the context of running a keeper (more info \nhere\n) to perform bids within an auction, a primary failure mode would occur when a keeper specifies an unprofitable price for the collateral.\nThis failure mode is due to the fact that there is nothing the system can do to stop a user from paying significantly more than the fair market value for the token in an auction (this goes for all auction types, \nflip, flop, and flap\n).\nKeepers that are performing badly are primarily at risk during the \ndent\n phase since they could return too much collateral to the original Vault and end up overpaying (i.e. pay too much Dai (\nbid\n) for too few gems (\nlot\n)).\nBidding Requirements during an auction\nDuring \ntend\n, \nbid\n amounts will increase by a \nbeg\n percentage with each new \ntend\n. The bidder must know the auction's \nid\n, specify the right amount of \nlot\n for the auction, bid at least \nbeg\n% more than the last bid but not more than \ntab\n and must have a sufficient \nVat.dai\n balance.\nDuring \ndent\n, \nlot\n amounts will decrease by a \nbeg\n percentage with each new \ndent\n. The bidder must know the auction's \nid\n, specify the right amount of \nbid\n for the auction and offer to take \nbeg\n% less \nlot\n than the last bid.\nPlacing Bids\nWhen a \ntend\n bid is beaten out by another bidder, the new winner's internal DAI balance is used to refund the previous winning bidder. When a \ndent\n bid is beaten out by another bidder, the Flipper's gem balance is used to refund the Vault holder. Once placed, bids cannot be canceled.\nIllustration of the bidding flow:\n1.\nCat \nkick\ns a new Flip Auction. The Cat emits a \nbite\n event with the Flipper's address and the auction \nid\n. The Flipper emits a \nkick\n event with the \nid\n and other auction details.\nStart \ntend\n auction:\n1.\nBidder 1 makes a bid that increases the \nbid\n size by \nbeg\n. Bidder 1's DAI balance in the Vat is decreased by \nbid\n and the Vow's DAI balance in the Vat is increased by \nbid\n.\n2.\nBidder 2 makes a bid that increases Bidder 1's \nbid\n by at least \nbeg\n. Bidder 2's DAI balance in the Vat is decreased by \nbid\n and Bidder 1's DAI balance in the Vat is increased by \nbid\n (thereby refunding Bidder 1 for their now-losing bid). Bidder 2's DAI balance in the Vat is decreased by \nbid\n - Bidder 1's \nbid\n and the \nVow\n's DAI balance is increased by the same number. \ntic\n is reset to \nnow\n + \nttl\n3.\nBidder 1 makes a bid that increases Bidder 2's \nbid\n by at least \nbeg\n. Bidder 1's DAI = \nVat.dai[bidder1]\n - Bidder 2's previous \nbid\n; Bidder 2's DAI = \nVat.dai[bidder2]\n + Bidder 2's previous \nbid\n. Then Bidder 1's DAI = \nVat.dai[bidder1] - (bid - Bidder 2's bid)\n and Vow's DAI = \nVat.dai[bidder1] + (bid - Bidder 2's bid)\n. \ntic\n is reset to \nnow\n + \nttl\n4.\nOnce a new \nbid\n comes in that is equal to the \ntab\n the \ntend\n phase is complete.\nStart \ndent\n auction:\nNote:\n \nThis phase must start before \ntic\n expires and before \nbid.end\n is passed.\n1.\nBidder 2 (and all the other bidders within the auction) decide it is no longer worth it to continue to increase their \nbid\ns, so they stop bidding. Once the \nBid.tic\n expires, Bidder 1 calls \ndeal\n and the gem tokens are sent to their Vat balance.\nNote:\n An auction can also end in the \ntend\n phase by not reaching \ntab\n before the \ntic\n or \nend\n are reached. If this happens, then the winning bidder is awarded using the \ndeal\n function and the difference between the final \nbid\n and the \ntab\n stays as bad debt in the \nVow\n to be dealt with during a \nFlop\n auction.\nThe End\nIn the case of Global Settlement, the \nEnd\n is able to call \nyank\n on the Flipper. \nYank\n closes a \ntend\n-phase auction by returning the \nguy\n's Dai bid and moving the Gems from the Flipper to the \nEnd\n. \ndent\n-phase auctions can continue to the \ndeal\n phase as they have already raised the necessary Dai and are in the process of returning Gems to the original Vault holder.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nBounds on Operating Conditions\nBecause \nFlip.tend\n compares the bidder's \nbid\n with the previous \nbid * beg\n, it will compare the two numbers at 10^63 precision (\nrad * wad\n). This means that any \nbid\n that is greater than 115,792,089,237,316 will cause an overflow. Governance should endeavour to not set \nbeg\n or \nlot\n (via \nCat.ilks[ilk].dunk\n) so that it is likely that an auction keeper would end up \nbid\n'ding that much DAI during the \ntend\n phase. This is very unlikely so long as the target price of Dai remains 1 USD, but is included here for awareness.\n1. \nSee System Stabilizer Module Documentation\n\u0432\u0496\u04e2\n2. Last Minute Auction/Low Keeper Participation Risks\nAuction Grinding\nAuction grinding allows an attacker to generate debt, allow their Vault to be bitten, win their own auction to get their collateral back at a discount. This type of failure is most possible when the liquidation penalty is set too low.\nFor the full details about this risk, reference @livnev's Paper \nhere\n.\nPrevious\nCat - Detailed Documentation\nNext\n - Miscellaneous\nSCD <> MCD Migration\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/miscellaneous/liquidations-1.2-system-deprecated/flipper-detailed-documentation", "title": "Flipper - Detailed Documentation"}}
{"page_content": "Join - Detailed Documentation\nContract Name:\n join.sol\nType/Category:\n DSS \u2014> Token Adapter Module\n\u200b\nAssociated MCD System Diagram\n\u200b\n\u200b\nContract Source\n\u200b\nEtherscan\n\u200b\nJoin Dai \n\u200b\n\u200b\nJoin Eth\n\u200b\n\u200b\nJoin Bat\n\u200b\n1. Introduction (Summary)\nJoin consists of three smart contracts: \nGemJoin\n, \nETHJoin\n, and \nDaiJoin:\n\n\nGemJoin\n - allows standard ERC20 tokens to be deposited for use with the system. \nETHJoin\n - allows native Ether to be used with the system. \n\nDaiJoin\n - allows users to withdraw their Dai from the system into a standard ERC20 token.\nEach \njoin\n contract is created specifically to allow the given token type to be \njoin\n'ed to the \nvat\n. Because of this, each \njoin\n contract has slightly different logic to account for the different types of tokens within the system.\nJoin Interactions with the Maker Protocol\n2. Contract Details:\nGlossary (Join)\nvat\n - storage of the \nVat\n\u2019s address.\nilk\n - id of the Ilk for which a \nGemJoin\n is created for.\ngem\n - the address of the \nilk\n for transferring.\ndai\n - the address of the \ndai\n token.\none\n - a 10^27 uint used for math in \nDaiJoin\n.\nlive\n - an access flag for the \njoin\n adapter.\ndec\n - decimals for the Gem.\nEvery \njoin\n contract has 4 public functions: a constructor, \njoin\n, \nexit\n, and \ncage\n. The constructor is used on contract initialization and sets the core variables of that \njoin\n contract. \nJoin\n and \nexit\n are both true to their names. \nJoin\n provides a mechanism for users to add the given token type to the \nvat\n. It has slightly different logic in each variation, but generally resolves down to a \ntransfer\n and a function call in the \nvat\n. \nExit\n is very similar, but instead allows the the user to remove their desired token from the \nvat\n. \nCage\n allows the adapter to be drained (allows tokens to move out but not in).\n3. Key Mechanisms & Concepts\nThe \nGemJoin\n contract serves a very specified and singular purpose which is relatively abstracted away from the rest of the core smart contract system. When a user desires to enter the system and interact with the \ndss\n contracts, they must use one of the \njoin\n contracts. After they have finished with the \ndss\n contracts, they must call \nexit\n to leave the system and take out their tokens. When the \nGemJoin\n gets \ncage\nd by an \nauth\ned address, it can \nexit\n collateral from the Vat but it can no longer \njoin\n new collateral.\nUser balances for collateral tokens added to the system via \njoin\n are accounted for in the \nVat\n as \nGem\n according to collateral type \nIlk\n until they are converted into locked collateral tokens (\nink\n) so the user can draw Dai.\nThe \nDaiJoin\n contract serves a similar purpose. It manages the exchange of Dai that is tracked in the \nVat\n and ERC-20 Dai that is tracked by \nDai.sol\n. After a user draws Dai against their collateral, they will have a balance in \nVat.dai\n. This Dai balance can be \nexit\n' ed from the Vat using the \nDaiJoin\n contract which holds the balance of \nVat.dai\n and mint's ERC-20 Dai. When a user wants to move their Dai back into the \nVat\n accounting system (to pay back debt, participate in auctions, pack \nbag\n's in the \nEnd\n, or utilize the DSR, etc), they must call \nDaiJoin.join\n. By calling \nDaiJoin.join\n this effectively \nburn\n's the ERC-20 Dai and transfers \nVat.dai\n from the \nDaiJoin\n's balance to the User's account in the \nVat\n. Under normal operation of the system, the \nDai.totalSupply\n should equal the \nVat.dai(DaiJoin)\n balance. When the \nDaiJoin\n contract gets \ncage\n'd by an \nauth\n'ed address, it can move Dai back into the Vat but it can no longer \nexit\n Dai from the Vat.\n4. Gotchas (Potential source of user error)\nThe main source of user error with the \nJoin\n contract is that Users should never \ntransfer\n tokens directly to the contracts, they \nmust\n use the \njoin\n functions or they will not be able to retrieve their tokens.\nThere are limited sources of user error in the \njoin\n contract system due to the limited functionality of the system. Barring a contract bug, should a user call \njoin\n by accident they could always get their tokens back through the corresponding \nexit\n call on the given \njoin\n contract.\nThe main issue to be aware of here would be a well-executed phishing attack. As the system evolves and potentially more \njoin\n contracts are created, or more user interfaces are made, there is the potential for a user to have their funds stolen by a malicious \njoin\n contract which does not actually send tokens to the \nvat\n, but instead to some other contract or wallet.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nThere could potentially be a \nvat\n upgrade that would require new \njoin\n contracts to be created.\nIf a \ngem\n contract were to go through a token upgrade or have the tokens frozen while a user's collateral was in the system, there could potentially be a scenario in which the users were unable to redeem their collateral after the freeze or upgrade was finished. This scenario likely presents little risk though because the token going through this upgrade would more than likely want to work alongside the Maker community to be sure this was not an issue.\nSmart Contract Modules - \nPrevious\nCollateral Module\nNext\n - Smart Contract Modules\nLiquidation 2.0 Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/collateral-module/join-detailed-documentation", "title": "Join - Detailed Documentation"}}
{"page_content": "Spot - Detailed Documentation\nThe Maker Protocol's liaison between the\u0412\u00a0Oracles\u0412\u00a0and\u0412\u00a0Core Contracts\nContract Name:\n spot.sol\nType/Category:\n DSS \u0432\u0496\u201d> Core Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan \n\u0432\u0496\u04e2\n1. Introduction\nThe \nSpot\n liaison between the \noracles\n and the core contracts. It functions as an interface contract and only stores the current \nilk\n list.\n2. Contract Details\nMath\nAll mathematical operations will revert on overflow or underflow\nComplexity\nAll methods execute in constant time\nVariables\nilk\n a given collateral type\nilk.pip\n the contract which holds the current price of a given \nilk\nilk.mat\n the liquidation ratio for a given \nilk\nvat\n the core of the mcd system\npar\n value of DAI in the reference asset (e.g. $1 per DAI)\nCollateral\nOnly authorized users can update any variables in contract\n3. Key \nMechanisms & Concepts\nPoke\npoke\n is the only non-authenticated function in \nspot\n. The function takes in a \nbytes32\n of the \nilk\n to be \"poked\". \npoke\n calls two \nexternal\n functions:\n1.\npeek\n calls the \nOSM\n for the given \nilk\n and takes back in the \nval\n and \nhas\n(a boolean which is false if there was an error in the \nosm\n). The second external call only happens if \nhas == true\n.\n2.\nWhen calculating the \nspot\n, the \npar\n is crucial to this calculation as it defines the relationship between DAI and 1 unit of value in the price. The \nval\n is then divided by the \npar\n(to get a ratio of \nval\n to \nDAI\n) and then the resulting value is divided by the \nilk.mat\n. This gives us the current \nspot\n price for the given \nilk\n.\n3.\nfile\n is then called after calculating the \nspot\n. This updates the \nvat\n with the current liquidation price of the \nilk\n which the function was called for.\n4. \nGotchas\nThe methods in the \nspotter\n are relatively basic compared to most other portions of \ndss\n. There is not much room for user error in the single unauthed method \npoke\n. If an incorrect \nbytes32\n is supplied the call will fail.\nAny module that is authed against the \nspot\n has full root access, and can, therefore, add and remove which \nilks\n can be \"poked\". While not completely breaking the system, this could cause considerable risk.\n5. \nFailure Modes\nCoding Error\nA bug in \nspot\n would most likely result in the prices for collaterals not being updated anymore. In this case, the system would need to authorize a new \nspot\n which would then be able to update the prices. Overall this is not a catastrophic failure as this would only pause all price fluctuation for some period.\nFeeds\nThe \nspot\n relies upon a set of trusted oracles to provide price data. Should these price feeds fail, it would become possible for unbacked Dai to be minted, or safe Vaults could be unfairly liquidated.\nSpot Price Becoming Stale\nWhen \npoke\n is not called frequently enough, the \nVat\n's \nspot\n price will become stale. This could arise for a few reasons including tragedy of the commons or miner collusion and could lead to negative outcomes such as inappropriate liquidations, or the prevention of liquidations that should be possible.\nPrevious\nVat - Detailed Documentation\nNext\n - Smart Contract Modules\nCollateral Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/core-module/spot-detailed-documentation", "title": "Spot - Detailed Documentation"}}
{"page_content": "Vat - Detailed Documentation\nThe Maker Protocol's Core Accounting System\nContract Name: Vat.sol\nType/Category:\n DSS \u0432\u0496\u201d> Core System Accounting\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nVat\n is the core Vault engine of \ndss\n. It stores Vaults and tracks all the associated Dai and Collateral balances. It also defines the rules by which Vaults and balances can be manipulated. The rules defined in the \nVat\n are immutable, so in some sense, the rules in the \nVat\n can be viewed as the constitution of \ndss\n.\n2. Contract Details\nGlossary (Vat -\n Vault \nEngine)\ngem\n: collateral tokens.\ndai\n: stablecoin tokens.\nsin\n: unbacked stablecoin (system debt, not belonging to any \nurn\n).\nilks\n: a mapping of \nIlk\n types.\nIlk\n: a collateral type.\nArt\n: total normalized stablecoin debt.\nrate\n: stablecoin debt multiplier (accumulated stability fees).\nspot\n: collateral price with safety margin, i.e. the maximum stablecoin allowed per unit of collateral.\nline\n: the debt ceiling for a specific collateral type.\ndust\n: the debt floor for a specific collateral type.\nurns\n: a mapping of \nUrn\n types.\nUrn\n: a specific Vault.\nink\n: collateral balance.\nart\n: normalized outstanding stablecoin debt.\ninit\n: create a new collateral type.\nslip\n: modify a user's collateral balance.\nflux\n: transfer collateral between users.\nmove\n: transfer stablecoin between users.\ngrab\n: liquidate a Vault.\nheal\n: create / destroy equal quantities of stablecoin and system debt (\nvice\n).\nfold\n: modify the debt multiplier, creating / destroying corresponding debt.\nsuck\n: mint unbacked stablecoin (accounted for with \nvice\n).\nLine\n: the total debt ceiling for all collateral types.\nfrob\n: modify a Vault.\nlock\n: transfer collateral into a Vault.\nfree\n: transfer collateral from a Vault.\ndraw\n: increase Vault debt, creating Dai.\nwipe\n: decrease Vault debt, destroying Dai.\ndink\n: change in collateral.\ndart\n: change in debt.\nfork\n: to split a Vault - binary approval or splitting/merging Vaults.\ndink\n: amount of collateral to exchange.\ndart\n: amount of stablecoin debt to exchange.\nwish\n: check whether an address is allowed to modify another address's gem or dai balance.\nhope\n: enable \nwish\n for a pair of addresses.\nnope\n: disable \nwish\n for a pair of addresses.\nNote:\n \nart\n and \nArt\n represent normalized debt, i.e. a value that when multiplied by the correct rate gives the up-to-date, current stablecoin debt.\nAccounting\ndebt\n is the sum of all \ndai\n (the total quantity of dai issued).\nvice\n is the sum of all \nsin\n (the total quantity of system debt).\nIlk.Art\n the sum of all \nart\n in the \nurn\ns for that \nIlk\n.\ndebt\n is \nvice\n plus the sum of \nIlk.Art * Ilk.rate\n across all \nilks\n.\nCollateral\ngem\n can always be transferred to any address by it's owner.\nDai\ndai\n can only move with the consent of it's owner.\ndai\n can always be transferred to any address by it's owner.\n3. Mechanisms & Concepts\nThe core Vault, Dai, and collateral state is kept in the \nVat\n. The \nVat\n contract has no external dependencies and maintains the central \"Accounting Invariants\" of Dai. The core principles that apply to the \nvat\n are as follows:\n1.\nDai cannot exist without collateral:\nAn \nilk\n is a particular type of collateral.\nCollateral \ngem\n is assigned to users with \nslip\n.\nCollateral \ngem\n is transferred between users with \nflux\n.\n2. The Vault data structure is the \nUrn\n:\nhas \nink\n - encumbered collateral\nhas \nart\n - encumbered, normalized debt\n3. Similarly, a collateral is an \nIlk\n:\nhas \nArt\n - encumbered, normalized debt\nhas \nrate\n - debt scaling factor (discussed further below)\nhas \nspot\n - price with safety margin\nhas \nline\n - debt ceiling\nhas \ndust\n - debt floor\nNote:\n Above, when using the term \"encumbered\", this refers to being \"locked in a Vault\".\nVault Management\nVaults are managed via \nfrob(i, u, v, w, dink, dart)\n, which modifies the Vault of user \nu\n, using \ngem\n from user \nv\nand creating \ndai\n for user \nw\n.\nVaults are confiscated via \ngrab(i, u, v, w, dink, dart)\n, which modifies the Vault of user \nu\n, giving \ngem\n to user \nv\nand creating \nsin\n for user \nw\n. \ngrab\n is the means by which Vaults are liquidated, transferring debt from the Vault to a users \nsin\n balance.\nSin represents \"seized\" or \"bad\" debt and can be canceled out with an equal quantity of Dai using \nheal(uint rad\n where \nmsg.sender\n is used as the address for the \ndai\n and \nsin\n balances.\nNote:\n Only the Vow will ever have \nsin\n, so only the Vow can successfully call \nheal\n. This is because whenever \ngrab\n and \nsuck\n are called, the Vow's address is passed as the recipient of \nsin\n. Note that this is contingent on the current design and implementation of the system.\nNote:\n \nheal\n can only be called with a positive number (uint) and will \nsub(dai[u])\n along with \nsub\ning the \nsin\n.\nThe quantity \ndai\n can be transferred between users with \nmove\n.\nRate Updates via \nfold(bytes32 ilk, address u, int rate)\nAn ilk's \nrate\n is the conversion factor between any normalized debt (\nart\n) drawn against it and the present value of that debt with accrued fees. The \nrate\n parameter to \nfold\n is actually the change in the \nIlk.rate\n value, i.e. a difference of scaling factors (new - old). It is a signed integer, and hence current account values may increase or decrease. The quantity \nIlk.Art*rate\n is added to the \ndai\n balance of the address \nu\n (representing an increase or decrease in system surplus); the debt balances of all Vaults collateralized with the specified \nIlk\n are updated implicitly via the addition of \nrate\n to \nIlk.rate\n.\nFor more information on Rates and System Stabilization, see the Rates Module and System Stabilizer Module documentation below:\n\u0432\u0496\u04e2\nRates Module\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nSystem Stabilizer \n\u0432\u0496\u04e2\n4. Gotchas\nThe methods in the \nVat\n are written to be as generic as possible and as such have interfaces that can be quite verbose. Care should be taken that you have not mixed the order of parameters.\nAny module that is \nauth\ned against the \nVat\n has full root access, and can therefore steal all collateral in the system. This means that the addition of a new collateral type (and associated adapter) carries considerable risk.\n5. Failure Modes\nCoding Error\nA bug in the \nVat\n could be catastrophic and could lead to the loss (or locking) of all Dai and Collateral in the system. It could become impossible to modify Vault's or to transfer Dai. Auctions could cease to function. Shutdown could fail.\nFeeds\nThe \nVat\n relies upon a set of trusted oracles to provide price data. Should these price feeds fail, it would become possible for unbacked Dai to be minted, or safe Vaults could be unfairly liquidated.\nGovernance\nGovernance can authorize new modules against the \nVat\n. This allows them to steal collateral (\nslip\n) or mint unbacked Dai (\nsuck\n / addition of worthless collateral types). Should the cryptoeconomic protections that make doing so prohibitively expensive fail, the system may be vulnerable and left open for bad actors to drain collateral.\nAdapters\nThe \nVat\n relies on external Adapter contracts to ensure that the collateral balances in the \nVat\n represent real external collateral balances. Adapter contracts are authorized to make arbitrary modifications to all collateral balances. A faulty collateral adapter could result in the loss of all collateral in the system.\nSmart Contract Modules - \nPrevious\nCore Module\nNext\nSpot - Detailed Documentation\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/core-module/vat-detailed-documentation", "title": "Vat - Detailed Documentation"}}
{"page_content": "Dai - Detailed Documentation\nThe Dai Token Contract\nContract Name:\n dai.sol\nType/Category:\n DSS \u0432\u0410\u0424> Dai Module\n\u0432\u0410\u041b\nAssociated MCD System Diagram\n\u0432\u0410\u041b\n\u0432\u0410\u041b\nContract Source\n\u0432\u0410\u041b\n\u0432\u0410\u041b\nEtherscan\n\u0432\u0410\u041b\n1. Introduction (Summary)\nThe \nDai\n contract is the user-facing ERC20 token contract maintaining the accounting for external Dai balances. Most functions are standard for a token with changing supply, but it also notably features the ability to issue approvals for transfers based on signed messages.\nDai Interactions with the Maker Protocol\n2. Contract Details\nDAI (Glossary)\nKey Functionalities (as defined in the smart contract)\nMint\n - Mint to an address\nBurn\n - Burn at an address\nPush\n - Transfer\nPull\n - Transfer From\nMove\n - Transfer From\nApprove\n - Allow pulls and moves\nPermit\n - Approve by signature\nOther\nname\n - Dai Stablecoin\nsymbol\n - DAI\nversion\n - 1\ndecimals\n - 18\ntotalSupply\n - Total DAI Supply\nbalanceOf(usr: address)\n - User balance\nallowance(src: address, dst: address)\n - Approvals\nnonces(usr: address)\n - Permit nonce\nUnits\nwad\n - fixed point decimal with 18 decimals (for basic quantities, e.g. balances).\n3. Key Mechanisms & Concepts\nFor the most part, \ndai.sol\n functions as a typical ERC20 token. These tokens have been already been \nheavily documented here\n and it is recommended to read through that documentation for the core functions of an ERC20 token.\nDifferences From ERC20:\n1.\ntransferFrom\n in the DAI contract works in a slightly different form than the generic \ntransferFrom\n function. The DAI contract allows for \"unlimited approval\". Should the user approve an address for the maximum uint256 value, then that address will have unlimited approval until told otherwise.\n2.\npush\n, \npull\n & \nmove\n are aliases for \ntransferFrom\n calls in the form of \ntransferFrom(msg.sender, usr, amount)\n , \ntransferFrom(usr, msg.sender, amount)\n & \ntransferFrom(src, dst, amount)\n .\n3.\npermit\n is a signature-based approval function. This allows for an end-user to sign a message which can then be relayed by another party to submit their approval. This can be useful for applications in which the end-user does not need to hold \nETH\n.\nIn order to use this functionality, a user's address must sign a message with the \nholder\n, \nspender\n, \nnonce\n, \nexpiry\n and the \nallowed\n amount. This can then be submitted to \nPermit()\n to update the user's approval.\n4. Gotchas (Potential Source of User Error)\nUnlimited allowance is a relatively uncommon practice (though becoming more common). This could be something used to trick a user by a malicious contract into giving access to all their DAI. This is concerning in upgradeable contracts where the contract may appear innocent until upgraded to a malicious contract.\nDAI is also susceptible to the known \nERC20 race condition\n, but should not normally be an issue with unlimited approval. We recommend any users using the \napproval\n for a specific amount be aware of this particular issue and use caution when authorizing other contracts to perform transfers on their behalf.\nThere is a slight deviation in \ntransferFrom\n functionality: If the \nsrc == msg.sender\n the function does not require \napproval\n first and treats it as a normal \ntransfer\n from the \nmsg.sender\n to the \ndst\n.\nBuilt-in meta-transaction functionality of Dai\nThe Dai token provides offchain approval, which means that as an owner of an ETH address, you can sign a permission (using the permit() function) which basically grants allowance to another ETH address. The ETH address that you provide permission to can then take care of the execution of the transfer but has an allowance.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nN/a\nSmart Contract Modules - \nPrevious\nDai Module\nNext\n - Smart Contract Modules\nCore Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/dai-module/dai-detailed-documentation", "title": "Dai - Detailed Documentation"}}
{"page_content": "Chief - Detailed Documentation\nElecting a Chief contract via an approval voting system\nContract Name:\n chief.sol\nType/Category:\n Governance Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nDs-Chief\n smart contract provides a method to elect a \"chief\" contract via an approval voting system. This may be combined with another contract, such as \nDSAuthority\n, to elect a ruleset for a smart contract system.\nIn short, voters will lock up their voting tokens in order to give their votes some weight in the system. The voting is then done by continuous \napproval voting\n, where users receive IOU tokens when they lock their voting tokens up, which is useful for secondary governance mechanisms. The IOU tokens may not be exchanged for the locked tokens except by individuals who have actually locked funds in the contract itself, and only up to the amount they have locked.\nGovernance contract interactions with the system\n2. Contract Details\nGlossary (Chief)\n**DSChiefApprovals\n provides the following public properties:**\nslates\n: A mapping of \nbytes32\n to \naddress\n arrays. Represents sets of candidates. Weighted votes are given to slates.\nvotes\n: A mapping of voter addresses to the slate they have voted for.\napprovals\n: A mapping of candidate addresses to their \nuint\n weight.\ndeposits\n: A mapping of voter addresses to \nuint\n number of tokens locked.\nGOV\n: \nDSToken\n used for voting.\nIOU\n: \nDSToken\n issued in exchange for locking \nGOV\n tokens.\nhat\n: Contains the address of the current \"chief.\"\nMAX_YAYS\n: Maximum number of candidates a slate can hold.\nMost of the functions are decorated with the the \nnote\n modifier from \nds-note\n, meaning that they fire a standardized event when called. Additionally, one custom event is also provided:\nEtch(bytes32 indexed slate)\n: Fired when a slate is created.\n3. Key Mechanisms & Concepts\nThere are two contracts in ds-chief:\n1.\nDSChiefApprovals\n2.\nDSChief, which inherits from DSChiefApprovals.\nKey Functionalities (as defined in the smart contract)\nDSChiefApprovals\nDSChiefApprovals(DSToken GOV_, DSToken IOU_, uint MAX_YAYS_)\nThe constructor. Sets \nGOV\n, \nIOU\n, and \nMAX_YAYS\n.\nlock(uint wad)\nCharges the user \nwad\n \nGOV\n tokens, issues an equal amount of \nIOU\n tokens to the user, and adds \nwad\n weight to the candidates on the user's selected slate. Fires a \nLogLock\n event.\nfree(uint wad)\nCharges the user \nwad\n \nIOU\n tokens, issues an equal amount of \nGOV\n tokens to the user, and subtracts \nwad\n weight from the candidates on the user's selected slate. Fires a \nLogFree\n event.\netch(address[] yays) returns (bytes32 slate)\nSave a set of ordered addresses as a \nslate\n and return a unique identifier for it.\nvote(address[] yays) returns (bytes32 slate)\nSave a set of ordered addresses as a \nslate\n, moves the voter's weight from their current slate to the new slate, and returns the slate's identifier.\nvote(bytes32 slate)\nRemoves voter's weight from their current slate and adds it to the specified slate.\nlift(address whom)\nChecks the given address and promotes it to \ns/chief/hat\n if it has more weight than the current \ns/chief/hat\n.\nDSChief\nDSChief\n is a combination of \nDSRoles\n from the \nds-roles\n package and \nDSChiefApprovals\n. It can be used in conjunction with \nds-auth\n (as an authority object) to govern smart contract systems.\nPublic Functions\nDSChief(DSToken GOV_, DSToken IOU_, uint MAX_YAYS_)\nThe constructor. Sets \nGOV\n, \nIOU\n, and \nMAX_YAYS\n.\nsetOwner(address owner_)\nReverts the transaction. Overridden from \nDSAuth\n.\nsetAuthority(DSAuthority authority_)\nReverts the transaction. Overridden from \nDSAuth\n.\nisUserRoot(address who) constant returns (bool)\nReturns \ntrue\n if the given address is the chief.\nsetRootUser(address who, bool enabled)\nReverts the transaction. Overridden from \nDSRoles\n.\nDSRoles\nSee \nds-roles\n for inherited features.\n4. Gotchas (Potential source of user error)\nIn general, when we refer to the \n\"hat\"\n, it can be any address \u0432\u0496\u201d be it a single-use contract like ds-spell, a multi-use contract or an individual's wallet. Thus, ds-chief can work well as a method for selecting code for execution just as well as it can for realizing political processes.\nExample:\nThe \nds-chief\n could be used as a token-weighted voting system governing another set of smart contracts that uses the \nds-auth\n with \nds-roles\n. In a scenario such as this, \"candidates\" would consist of contracts changing the state of the smart contract set under governance. Such a contract being elected as \u0432\u0496\u049bhat\" would be granted all of the permissions to execute whatever changes are necessary. The \nds-chief\n could also be used within such a contract set in conjunction with a proxy contract, such as \nds-proxy\n or a name resolution system like ENS for the purpose of voting in new versions of contracts.\nUnderstanding the IOU Token\nThe purpose of the IOU token is to allow for the chaining of governance contracts. In other words, this allows you to have a number of \nDSChief\n or other similar contracts use the same governance token by means of accepting the IOU token of the \nDSChief\n contract before it is a governance token.\nExample:\nLet\u0432\u0496\u04b7s say there are three \nDSChief\n contracts (chiefA, chiefB, and chiefC) and a \nchiefA.GOV\n that is the MKR token. If we set \nchiefB.GOV\n to \nchiefA.IOU\n and \nchiefC.GOV\n to \nchiefB.IOU\n, this allows all three contracts to run using a common group of MKR.\nApproval Voting\nThis type of voting is when each voter selects which candidates they approve of, with the top n \"most approved\" candidates being then elected. Each voter can cast up to n + k votes, where k equals some non-zero positive integer. This way voters to move their approval from one candidate to another without needing to first withdraw support from the candidate being replaced. Without this in place, moving approval to a new candidate could result in a less-approved candidate moving momentarily into the set of the elected candidates. \nNote:\n In the case of \nds-chief\n, n is equal to 1.\nIn addition, the \nds-chief\n weighs votes according to the quantity of a voting token that has been chosen to lock up in the \nDSChief\n or the \nDSChiefApprovals\n contract. It's important to note that the voting token used in a \nds-chief\n deployment must be specified at the time of deployment and cannot be changed afterward.\nImplementations\nIf you are writing a front-end UI for this smart contract, please note that the address[] parameters that are passed to the \netch\n and \nvote\n functions must be byte-ordered sets.\nExample:\nUsing \n[0x0, 0x1, 0x2, ...]\n is valid but using \n[0x1, 0x0, ...]\n and \n[0x0, 0x0, 0x1, ...]\n is not. This ordering constraint allows the contract to cheaply ensure voters cannot multiply their weights by listing the same candidate on their slate multiple times.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nMKR users moving their votes from one spell to another\nOne of the biggest potential failure modes occurs when people are moving their votes from one spell to another. This opens up a gap/period of time when only a small amount of MKR is needed to lift a random hat.\nLift is not called on spells that have more MKR than the current hat\nThe only way a spell can get the hat is if \nlift\n is called on it. So, even if a spell gains much more MKR on it than the hat, if \nlift\n is never called on it, the hat will remain on a spell that no longer has the most MKR. This could lower the bar for the amount of MKR needed to pass something, potentially making the system less safe.\nStray spells without expiration\nDue to the continuous nature of voting, a spell will remain live in the system even if it was not approved to be the governing proposal. This means that MKR holders can continue to vote on the candidate and in times of lower voter participation there is potential for them to introduce a failure mode by voting for an unexpected and/or older candidate. This illustrates why increased voter participation is important and that a higher amount of MKR on the current governing proposal adds to the stability of the system.\nUnsafe states when migrating to a new chief contract\nWhen migrating to a new chief, authority must be transferred to the new contract and revoked from the old. This poses a small coordination problem as the new contract must already have enough MKR on its \nhat\n to be safe against governance attacks while the voters enacting the change itself must have enough MKR in the old chief to pass the proposal.\nPrevious\nPause - Detailed Documentation\nNext\n - Smart Contract Modules\nRates Module\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/governance-module/chief-detailed-documentation", "title": "Chief - Detailed Documentation"}}
{"page_content": "Pause - Detailed Documentation\nA delegatecall based proxy with an enforced delay\nContract Name:\n pause.sol\nType/Category:\n Governance Module\n\u200b\nAssociated MCD System Diagram\n\u200b\n\u200b\nContract Source\n\u200b\n1. Introduction (Summary)\nThe \nds-pause\n is a \ndelegatecall\n based proxy with an enforced delay. This allows authorized users to schedule function calls that can only be executed once a predetermined waiting period has elapsed. The configurable delay attribute sets the minimum wait time that will be used during the governance of the system.\n2. Contract Details:\nKey Functionalities (as defined in the smart contract)\nPlans\n A plan describes a single \ndelegatecall\n operation and a unix timestamp \neta\n before which it cannot be executed.\nA plan consists of:\nusr\n: address to delegatecall into\ntag\n: the expected codehash of usr\nfax\n: calldata to use\neta\n: first possible time of execution (as seconds since unix epoch)\nIt is important to note that each plan has a unique id, defined as a keccack256(abi.encode(usr, tag, fax, eta)).\nOperations\nPlans can be manipulated in the following ways:\nplot\n: schedule a plan\nexec\n: execute a scheduled plan\ndrop\n: cancel a scheduled plan\nThe \npause\n contract contains the \nDSPauseProxy\n contract in order to allow plan to be executed in an isolated storage context to protect the pause from malicious storage modification during plan execution.\n3. Key Mechanisms & Concepts\nThe \nds-pause\n was designed to be used as a component in the Maker Protocol\u2019s governance system in order to give affected parties time to respond to decisions. If those affected by governance decisions have e.g. exit or veto rights, then the pause can serve as an effective check on governance power.\n4. Gotchas (Potential source of user error)\nIdentity & Trust\nIn order to protect the internal storage of the pause from malicious writes during plan execution, we perform the \ndelegatecall\n operation in a separate contract with an isolated storage context (DSPauseProxy), where each pause has its own individual proxy.\nThis means that plans are executed with the identity of the \nproxy\n. Thus when integrating the pause into some auth scheme, you will want to trust the pause's proxy and not the pause itself.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nA break of any of the following would be classified as a critical issue:\nHigh level\nThere is no way to bypass the delay\nThe code executed by the delegatecall cannot directly modify storage on the pause\nThe pause will always retain ownership of it's proxy\nAdministrative\nauthority, owner, and delay can only be changed if an authorized user plots a plan to do so\nPlot\nA plan can only be plotted if its eta is after block.timestamp + delay\nA plan can only be plotted by authorized users\nExec\nA plan can only be executed if it has previously been plotted\nA plan can only be executed once it's eta has passed\nA plan can only be executed if its tag matches extcodehash(usr)\nA plan can only be executed once\nA plan can be executed by anyone\nDrop\nA plan can only be dropped by authorized users\nOther Failure Modes\nDSPause.delay\n - when the pause delay is set to the maximum, governance can no longer modify the system.\nDSPause.delay\n - when the pause delay is set to the minimum, it is easier to pass malicious governance actions.\nPrevious\nSpell - Detailed Documentation\nNext\nChief - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/governance-module/pause-detailed-documentation", "title": "Pause - Detailed Documentation"}}
{"page_content": "Spell - Detailed Documentation\nContract Name:\n spell.sol\nType/Category:\n Governance Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nA \nDSSpell\n is an un-owned object that performs one action or series of atomic actions (multiple transactions) one time only. This can be thought of as a one-off DSProxy with no owner (no DSAuth mix-in, it is not a DSThing).\nThis primitive is useful to express objects that do actions which shouldn't depend on \"sender\", like an upgrade to a contract system that needs to be given root permission. By convention, it is usually what is used to change SCD or MCD system parameters (where it is given auth via voting in \nds-chief\n).\n2. Contract Details\nThe \nspell.sol\n contract contains two main contracts: DSSPELL and DSSpellBook. DSSPELL is the core contract that, with call instructions set in the constructor, can actually perform the one-time action. DSSpellBook is a factory contract designed to make the creation of DSSPELLs easier.\nGlossary (Spell)\nwhom\n - is the address the spell is targeting, usually SAI_MOM in SCD.\nmana\n - is the amount of ETH you are sending, which in spells it is usually 0.\ndata\n - bytes memory calldata.\ndone\n - indicates that the spell has been called successfully.\n3. Key Mechanisms & Concepts\nhat\n - A spell comes into effect as the hat when someone calls the lift function. This is only possible when the spell in question has more MKR voted towards it than the current hat.\ncast\n - Once a spell has become the hat, it can be cast and its new variables will go into effect as part of the live Maker system. It is worth noting that a spell can only be cast once.\nlift\n - The process whereby a new spell replaces the old proposal.\nNote:\n the \nhat\n and \nlift\n have more to do with \nds-chief\n than \nds-spell\n but are important to mention here for context.\nImmutable Actions\nwhom\n, \nmana\n, and \ndata\n are set in the constructor, so the action a spell is to perform cannot be changed after the contract has been deployed.\n4. Gotchas (Potential source of user error)\nNote that the spell is only marked as \"done\" if the CALL it makes succeeds, meaning it did not end in an exceptional condition and it did not revert. Conversely, contracts that use return values instead of exceptions to signal errors could be successfully called without having the effect you might desire. \"Approving\" spells to take action on a system after the spell is deployed generally requires the system to use exception-based error handling to avoid griefing.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nspell\n - A spell may remain uncast if it did not reach the required amount of MKR in order to pass. If this occurs, the spell may remain available as a later target if enough MKR is voted towards it.\nlift\n - Although spells cannot be cast a second time, they can be lifted to become the hat more than once if enough MKR votes remain on that proposal. The proposals parameters will not go into effect, however any additional spell will need to have more than that amount of MKR voted towards it in order to become the new hat. See \nforum post\n for a description of this having once occurred.\ncast\n - If, when \ncast\n is called, the spell's one-time action fails, \ndone\n does not get flipped and the spell remains castable.\nSmart Contract Modules - \nPrevious\nGovernance Module\nNext\nPause - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/governance-module/spell-detailed-documentation", "title": "Spell - Detailed Documentation"}}
{"page_content": "Median - Detailed Documentation\nThe Maker Protocol's trusted reference price\nContract Name:\n median.sol\nType/Category:\n Oracles Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe median provides Maker's trusted reference price. In short, it works by maintaining a whitelist of price feed contracts which are authorized to post price updates. Every time a new list of prices is received, the median of these is computed and used to update the stored value. The median has permissioning logic which is what enables the addition and removal of whitelisted price feed addresses that are controlled via governance. The permissioning logic allows governance to set other parameters that control the Median's behavior\u0432\u0496\u201dfor example, the \nbar\n parameter is the minimum number of prices necessary to accept a new median value.\nA High-level overview diagram of the components that involve and interact with the median:\nNote:\n All arrows without labels are governance calls.\n2. Contract Details\nMedian (Glossary)\nKey Functionalities (as defined in the smart contract)\nread\n - Gets a non-zero price or fails.\npeek\n - Gets the price and validity.\npoke\n - Updates price from whitelisted providers.\nlift\n- Adds an address to the writers whitelist.\ndrop\n - Removes an address from the writers whitelist.\nsetBar\n - Sets the \nbar\n.\nkiss\n - Adds an address to the reader's whitelist.\ndiss\n - Removes an address from the readers whitelist.\nNote:\n \nread\n returns the \nvalue\n or fails if it's invalid & \npeek\n gives back the \nvalue\n and if the \nvalue\n is valid or not.\nOther\nwards(usr: address)\n - Auth mechanisms.\norcl(usr: address)\n - \nval\n writers whitelist / signers of the prices (whitelisted via governance / the authorized parties).\nbud(usr: address)\n - \nval\n readers whitelist.\nval\n - the price (private) must be read with \nread()\n or \npeek()\nage\n - the Block timestamp of last price \nval\n update.\nwat\n - the price oracles type (ex: ETHUSD) / tells us what the type of asset is.\nbar\n - the Minimum writers quorum for \npoke\n / min number of valid messages you need to have to update the price.\n3. Key Mechanisms & Concepts\nAs mentioned above, the \nmedian\n is the smart contract that provides Maker's trusted reference price. Authorization \n(auth)\n is a key component included in the mechanism of this contract and its interactions. For example, the price (\nval\n) is intentionally kept not public because the intention is to only read it from the two functions \nread\n and \npeek\n, which are whitelisted. This means that you need to be authorized, which is completed through the \nbud\n. The \nbud\n is modified to get whitelisted authorities to read it on-chain (permissioned), whereas, everything of off-chain is public.\nThe \npoke\n method is not under any kind of \nauth\n. This means that anybody can call it. This was designed for the purpose of getting Keepers to call this function and interact with Auctions. The only way to modify its state is if you call it and send it valid data. For example, let's say this oracle needs 15 different sources. This means that we would need it to send 15 different signatures. It will then proceed to go through each of them and validate that whoever sent the the data has been \nauth\n'd to do so. In the case of it being an authorized oracle, it will check if it signed the message with a timestamp that is greater than the last one. This is done for the purpose of ensuring that it is not a stale message. The next step is to check for order values, this requires that you send everything in an array that is formatted in ascending order. If not sent in the correct order (ascending), the median is not calculated correctly. This is because if you assume the prices are ordered, it would just grab the middle value which may not be sufficient or work. In order to check for uniqueness, we have implemented the use of a \nbloom\n filter. In short, a bloom filter is a data structure designed to tell us, rapidly and memory-efficiently, whether an element is present in a set. This use of the bloom filter helps with optimization. In order to whitelist signers, the first two characters of their addresses (the first \nbyte\n) have to be unique. For example, let's say that you have 15 different price signers, none of the first two characters of their addresses can be the same. This helps to filter that all 15 signers are different.\nNext, there are \nlift\n functions. These functions tell us who can sign messages. Multiple messages can be sent or it can just be one but they are put into the authorized oracle). However, there is currently nothing preventing someone from \nlift\n'ing two prices signers that start with the same address. This is something for example, that governance needs to be aware of (see an example of what a governance proposal would look like in this case in the \nGotchas\n section).\nDue to the mechanism design of how the oracles work, the \nquorum\n has to be an odd number. If it is an even number, it will not work. This was designed as an optimization (\nval = uint128(val_[val_.length >> 1]);\n); this code snippet outlines how it works, which is by taking the array of values (all the prices that each of the prices signers reported, ordered from 200-215) and then grabbing the one in the middle. This is done by taking the length of the array (15) and shifting it to the right by 1 (which is the same as dividing by 2). This ends up being 7.5 and then the EVM floors it to 7. If we were to accept even numbers this would be less efficient. This presents the issue that you should have a defined balance between how many you require and how many signers you actually have. For example, let's say the oracle needs 15 signatures, you need at least 17-18 signers because if you require 15 and you only have 15 and one of them goes down, you have no way of modifying the price, so you should always have a bit more. However, you should not have too many, as it could compromise the operation.\n4. Gotchas\nEmergency Oracles\nThey can shutdown the price feed but cannot bring it back up. Bringing the price feed back up requires governance to step in.\nPrice Freeze\nIf you void the oracles Ethereum module, the idea is that you cannot interact with any Vault that depends on that ilk.\nExample:\n ETHUSD shutdown (can still add collateral and pay back debt - increases safety) but you cannot do anything that increases risk (decreases safety - remove collateral, generate dai, etc.) because the system would not know if you would be undercollateralized.\nOracles Require a lot of Upkeep\nThey need to keep all relayers functioning.\nThe community would need to self-police (by looking at each price signer, etc.) if any of them needs to be replaced. They would need to make sure they are constantly being called every hour (for every hour, a transaction gets sent to the OSM, which means that a few transactions have already been sent to the median to update it as well. In addition, there would need to be a transaction sent to the \nspotter\n, as DSS operates in a pool-type method (doesn't update the system/write to it, you tell it to read it from the OSM).\nThere is nothing preventing from \nlift\n'ing two prices signers that start with the same address\nThe only thing that this prevents is that you cannot have more than 256 oracles but we don't expect to ever have that many, so it is a hard limit. However, Governance needs to be sure that whoever they are voting in anyone that they have already voting in before with the same two first characters.\nAn example of what a governance proposal would look like in this case:\nWe are adding a new oracle and are proposing (the Foundation) a list of signers (that have been used in the past) and we already have an oracle but want to add someone new (e.g. Dharma or dydx). We would say that they want to be price signers, so these are their addresses and we want to lift those two addresses. They would vote for that, and we would need to keep a list of the already existing addresses and they would need to create an address that doesn't conflict with the existing ones.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nBy design, there is currently no way right now to turn off the oracle (failure or returns false) if all the oracles come together and sign a price of zero. This would result in the price being invalid and would return false on \npeek\n, telling us to not trust the value.\nWe are currently researching (Oracles ETH module) that would invalidate the price but there is no way to do this in the median today. This is due to the separation of concerns that DSS does not read directly from median, it reads from the OSM, but this may end up changing.\nPrevious\nOracle Security Module (OSM) - Detailed Documentation\nNext\n - Smart Contract Modules\nMKR Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/oracle-module/median-detailed-documentation", "title": "Median - Detailed Documentation"}}
{"page_content": "Oracle Security Module (OSM) - Detailed Documentation\nContract Name:\n OSM\nType/Category:\n Oracles - Price Feed Module\n\u200b\nAssociated MCD System Diagram\n\u200b\n\u200b\nContract Source\n\u200b\n1. Introduction\nSummary\nThe OSM (named via acronym from \"Oracle Security Module\") ensures that new price values propagated from the Oracles are not taken up by the system until a specified delay has passed. Values are read from a designated \nDSValue\n contract (or any contract that has the \nread()\n and \npeek()\n interfaces) via the \npoke()\n method; the \nread()\n and \npeek()\n methods will give the current value of the price feed, and other contracts must be whitelisted in order to call these. An OSM contract can only read from a single price feed, so in practice one OSM contract must be deployed per collateral type.\n2. Contract Details - Glossary (OSM)\nStorage Layout\nstopped\n : flag (\nuint256\n) that disables price feed updates if non-zero\nsrc\n : \naddress\n of DSValue that the OSM will read from\nONE_HOUR\n : 3600 seconds (\nuint16(3600)\n)\nhop\n : time delay between \npoke\n calls (\nuint16\n); defaults to \nONE_HOUR\nzzz\n : time of last update (rounded down to nearest multiple of \nhop\n)\ncur\n : \nFeed\n struct that holds the current price value\nnxt\n : \nFeed\n struct that holds the next price value\nbud\n : mapping from \naddress\n to \nuint256\n; whitelists feed readers\nPublic Methods\nAdministrative Methods\nThese functions can only be called by authorized addresses (i.e. addresses \nusr\n such that \nwards[usr] == 1\n).\nrely\n/\ndeny\n : add or remove authorized users (via modifications to the \nwards\n mapping)\nstop()\n/\nstart()\n : toggle whether price feed can be updated (by changing the value of \nstopped\n)\nchange(address)\n : change data source for prices (by setting \nsrc\n)\nstep(uint16)\n : change interval between price updates (by setting \nhop\n)\nvoid()\n : similar to \nstop\n, except it also sets \ncur\n and \nnxt\n to a \nFeed\n struct with zero values\nkiss(address)\n/\ndiss(address)\n : add/remove authorized feed consumers (via modifications to the \nbuds\n mapping)\nFeed Reading Methods\nThese can only be called by whitelisted addresses (i.e. addresses \nusr\n such that \nbuds[usr] == 1\n):\npeek()\n : returns the current feed value and a boolean indicating whether it is valid\npeep()\n : returns the next feed value (i.e. the one that will become the current value upon the next \npoke()\n call), and a boolean indicating whether it is valid\nread()\n : returns the current feed value; reverts if it was not set by some valid mechanism\nFeed Updating Methods\npoke()\n : updates the current feed value and reads the next one\nFeed\n struct: a struct with two \nuint128\n members, \nval\n and \nhas\n. Used to store price feed data.\n3. Key Mechanisms & Concepts\nThe central mechanism of the OSM is to periodically feed a delayed price into the MCD system for a particular collateral type. For this to work properly, an external actor must regularly call the \npoke()\n method to update the current price and read the next price. The contract tracks the time of the last call to \npoke()\n in the \nzzz\n variable (rounded down to the nearest multiple of \nhop\n; see \nFailure Modes\n for more discussion of this), and will not allow \npoke()\n to be called again until \nblock.timestamp\n is at least \nzzz+hop\n. Values are read from a designated DSValue contract (its address is stored in \nsrc\n). The purpose of this delayed updating mechanism is to ensure that there is time to detect and react to an Oracle attack (e.g. setting a collateral's price to zero). Responses to this include calling \nstop()\n or \nvoid()\n, or triggering Emergency Shutdown.\nOther contracts, if whitelisted, may inspect the \ncur\n value via the \npeek()\n and \nread()\n methods (\npeek()\n returns an additional boolean indicating whether the value has actually been set; \nread()\n reverts if the value has not been set). The \nnxt\n value may be inspected via \npeep()\n.\nThe contract uses a dual-tier authorization scheme: addresses mapped to 1 in \nwards\n may start and stop, set the \nsrc\n, call \nvoid()\n, and add new readers; addresses mapped to 1 in \nbuds\n may call \npeek()\n, \npeep()\n, and \nread()\n.\n4. Gotchas (Potential Sources of User Error)\nConfusing \npeek()\n for \npeep()\n (or vice-versa)\nThe names of these methods differ by only a single character and in current linguistic usage, both \"peek\" and \"peep\" have essentially the same meaning. This makes it easy for a developer to confuse the two and call the wrong one. The effects of such an error are naturally context-dependent, but could e.g. completely invalidate the purpose of the OSM if the \npeep()\n is called where instead \npeek()\n should be used. A mnemonic to help distinguish them: \"since 'k' comes before 'p' in the English alphabet, the value returned by \npeek()\n comes before the value returned by \npeep()\n in chronological order\". Or: \"\npeek()\n returns the \nk\nurrent value\".\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\npoke()\n is not called promptly, allowing malicious prices to be swiftly uptaken\nFor several reasons, \npoke()\n is always callable as soon as \nblock.timestamp / hop\n increments, regardless of when the last \npoke()\n call occurred (because \nzzz\n is rounded down to the nearest multiple of \nhop\n). This means the contract does not actually guarantee that a time interval of at least \nhop\n seconds has passed since the last \npoke()\n call before the next one; rather this is only (approximately) guaranteed if the last \npoke()\n call occurred shortly after the previous increase of \nblock.timestamp / hop\n. Thus, a malicious price value can be acknowledged by the system in a time potentially much less than \nhop\n.\nThis was a deliberate design decision. The arguments that favoured it, roughly speaking, are:\nProviding a predictable time at which MKR holders should check for evidence of oracle attacks (in practice, \nhop\n is 1 hour, so checks must be performed at the top of the hour)\nAllowing all OSMs to be reliably poked at the same time in a single transaction\nThe fact that \npoke\n is public, and thus callable by anyone, helps mitigate concerns, though it does not eliminate them. For example, network congestion could prevent anyone from successfully calling \npoke()\n for a period of time. If an MKR holder observes that \npoke\n has not been promptly called, \nthe actions they can take include:\n1.\nCall \npoke()\n themselves and decide if the next value is malicious or not\n2.\nCall \nstop()\n or \nvoid()\n (the former if only \nnxt\n is malicious; the latter if the malicious value is already in \ncur\n)\n3.\nTrigger emergency shutdown (if the integrity of the overall system has already been compromised or if it is believed the rogue oracle(s) cannot be fixed in a reasonable length of time)\nIn the future, the contract's logic may be tweaked to further mitigate this (e.g. by \nonly\n allowing \npoke()\n calls in a short time window each \nhop\n period).\nAuthorization Attacks and Misconfigurations\nVarious damaging actions can be taken by authorized individuals or contracts, either maliciously or accidentally:\nRevoking access of core contracts to the methods that read values, causing mayhem as prices fail to update\nCompletely revoking all access to the contract\nChanging \nsrc\n to either a malicious contract or to something that lacks a \npeek()\n interface, causing transactions that \npoke()\n the affected OSM to revert\nCalling disruptive functions like \nstop\n and \nvoid\n inappropriately\nThe only solution to these issues is diligence and care regarding the \nwards\n of the OSM.\nSmart Contract Modules - \nPrevious\nOracle Module\nNext\nMedian - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/oracle-module/oracle-security-module-osm-detailed-documentation", "title": "Oracle Security Module (OSM) - Detailed Documentation"}}
{"page_content": "CDP Manager - Detailed Documentation\nManaging Vaults to be transferred between users\nContract Name:\n cdpManager.sol\nType/Category:\n Vault Management\n\u0420\u0452\u0406\nAssociated MCD System Diagram\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nContract Source\n\u0420\u0452\u0406\n\u0420\u0452\u0406\nEtherscan\n\u0420\u0452\u0406\n1. Introduction (Summary)\nSummary:\n The \nDssCdpManager\n (aka \nmanager\n) was created to enable a formalized process for Vaults to be transferred between owners, much like assets are transferred. It is recommended that all interactions with Vaults be done through the CDP Manager. Once unlocked collateral has been deposited into the Maker Protocol, users can make use of the following features:\nMulti Vault ownership and numerical identification (users can own N number of Vaults)\nVault transferability\nMCD System Diagram: Vault User and Vault Manager interaction diagram\nNote:\n The MCD system diagram above shows that the Vault user goes through the proxy in order to interact with the CDP Manager but it is also possible to directly use the CDP Manager contract.\n2. Contract Details\nKey Functionalities (as defined in the smart contract)\ncdpAllow(uint cdp, address usr, uint ok)\n: Allow/Disallow (\nok\n) a \nusr\n address to manage the \ncdp\n.\nurnAllow(address usr, uint ok)\n : Allow/Disallow (\nok\n) a \nusr\n address to interact with an urn for the purposes of either entering (\nsrc\n) or quitting (\ndst).\nopen(bytes32 ilk, address usr)\n: Opens a new Vault for \nusr\n to be used for an \nilk\n collateral type.\ngive(uint cdp, address dst)\n: Transfers \ncdp\n to \ndst\n.\nfrob(uint cdp, int dink, int dart)\n: Increments/decrements the \nink\n amount of collateral locked and increments/decrements the \nart\n amount of debt in the \ncdp\n depositing the generated DAI or collateral freed in the \ncdp\n address.\nfrob(uint cdp, address dst, int dink, int dart)\n: Increments/decrements the \nink\n amount of collateral locked and increments/decrements the \nart\n amount of debt in the \ncdp\n depositing the generated DAI or collateral freed into a \nspecified\n \ndst\n address.\nflux(bytes32 ilk, uint cdp, address dst, uint wad)\n: Moves \nwad\n (precision 18) amount of collateral \nilk\n from \ncdp\n to \ndst\n.\nflux(uint cdp, address dst, uint wad)\n: Moves \nwad\n amount of \ncdp\n collateral from \ncdp\n to \ndst\n.\nmove(uint cdp, address dst, uint rad)\n: Moves \nrad\n (precision 45) amount of DAI from \ncdp\n to \ndst\n.\nquit(uint cdp, address dst)\n: Moves the collateral locked and debt generated from \ncdp\n to \ndst\n.\nNote:\n \ndst\n refers to the destination address.\nStorage Layout\nvat\n : core contract address that holds the Vaults.\ncdpi\n: Auto incremental id.\nurns\n: Mapping \nCDPId => UrnHandler\nlist\n: Mapping \nCDPId => Prev & Next CDPIds\n (double linked list)\nowns\n: Mapping \nCDPId => Owner\nilks\n: Mapping \nCDPId => Ilk\n (collateral type)\nfirst\n : Mapping \nOwner => First CDPId\nlast\n: Mapping \nOwner => Last CDPId\ncount\n: Mapping \nOwner => Amount of CDPs\nallows\n: Mapping \nOwner => CDPId => Allowed Addr => True/False\n3. Key Mechanisms & Concepts\nSummary\nThe CDP Manager was created as a way to enable Vaults to be treated more like assets that can be exchanged. Originally, the \ndss\n core contracts did not have the functionality to enable transferring Vault positions. The CDP Manager was created to wrap this functionality and enable transferring between users.\nHigh-level Purpose\nThe \nmanager\n receives the \nvat\n address in its creation and acts as an interface contract between it and the users.\nThe \nmanager\n keeps an internal registry of \nid => owner\n and \nid => urn\n allowing for the \nowner\n to execute \nvat\n functions for their \nurn\n via the \nmanager\n.\nThe \nmanager\n keeps a double linked list structure that allows the retrieval of all the Vaults that an \nowner\n has via on-chain calls.\nIn short, this is what the \nGetCdps\n is for. This contract is a helper contract that allows the fetching of all the Vaults in just one call.\nCDP \nManager Usage Example (common path):\nA User executes \nopen\n and gets a \nCDPId\n in return.\nAfter this, the \nCDPId\n gets associated with an \nurn\n with \nmanager.urns(cdpId)\n and then \njoin\n's collateral to it.\nThe user can then execute \nfrob\n to choose which \ndst\n address they want to use to send the generated DAI to.\nIf the user executes \nfrob\n without \ndst\n then the generated DAI will remain in the Vault's \nurn\n. In this case, the user can \nmove\n it at a later point in time.\nNote that this is the same process for collateral that is freed after \nfrob\n (for the \nfrob\n function that doesn't require the \ndst\n address). The user can \nflux\n it to another address at a later time.\nIn the case where a user wants to abandon the \nmanager\n, they can use \nquit\n as a way to migrate their position of their Vault to another \ndst\n address.\n4. Gotchas (Potential source of user error)\nFor the developers who want to integrate with the \nmanager\n, they will need to understand that the Vault actions are still in the \nurn\n environment. Regardless of this, the \nmanager\n tries to abstract the \nurn\n usage by a \nCDPId\n. This means that developers will need to get the \nurn\n (\nurn = manager.urns(cdpId)\n) to allow the \njoin\ning of collateral to that Vault.\nAs the \nmanager\n assigns a specific \nilk\n per \nCDPId\n and doesn't allow others to use it for theirs, there is a second \nflux\n function which expects an \nilk\n parameter. This function has the simple purpose of taking out collateral that was wrongly sent to a Vault that can't handle it/is incompatible.\nFrob Function(s):\nWhen you \nfrob\n in the CDP manager, you generate new DAI in the \nvat\n via the CDP manager which is then deposited in the \nurn\n that the CDP manager manages. This process depends on which \nfrob\n function you use (there exist \ntwo\n \nfrob\n functions). In short, one allows a destination address and the other doesn\u0420\u0452\u040et require it.\nIf you use the \nfrob\n function that has the destiny (\ndst\n) address, you are saying that you can send any Dai generated or collateral that has been freed. The second \nfrob\n function is meant for leaving the collateral in the \nurn\n address because the \nurn\n is owned by the CDP manager. In this case, you would need to manually use the \nflux\n or \nmove\n functions to get the DAI or collateral out. These functions (\nflux\n and \nmove\n) may be more beneficial for a developer working with the proxy function, as it allows for more flexibility. For example, by using these functions you can move a specific amount of collateral and can use the other functions to do it. Overall, it can make working with it a little more flexible on specific developer needs.\nAs mentioned above in the summary, the \ndss\n core contracts originally did not have the functionality to enable the transfer of Vault positions. Since then, the core contracts have also implemented a native transfer functionality called \nfork\n which allows the transferring of a Vault to another address. However, there is a restriction, which is that the address owner that will be receiving the Vault needs to provide authorization that they do in fact want to receive it. This was created for the situation when a user is transferring the collateral that is locked as well as the debt generated. If you are simply moving collateral to another address, there is no issue but in the case that you are also transferring the debt generated, there is a chance of putting a perfectly safe Vault in a risky position. This makes the contract functionality a little more restrictive. Therefore, the CDP manager is a good option to keep a simple way of transferring Vaults and recognizing them via a numeric ID.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nPotential Issues around Chain Reorganization\nWhen \nopen\n is executed, a new \nurn\n is created and a \ncdpId\n is assigned to it for a specific \nowner\n. If the user uses \njoin\n to add collateral to the \nurn\n immediately after the transaction is mined, there is a chance that a reorganization of the chain occurs. This would result in the user losing the ownership of that \ncdpId\n/\nurn\n pair, therefore losing their collateral. However, this issue can only arise when avoiding the use of the \nproxy functions\n via a \nprofile proxy\n as the user will \nopen\n the \ncdp\n and \njoin\n collateral in the same transaction.\nPrevious\nVote Proxy - Detailed Documentation\nNext\nDSR Manager - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/proxy-module/cdp-manager-detailed-documentation", "title": "CDP Manager - Detailed Documentation"}}
{"page_content": "DSR Manager - Detailed Documentation\nThe simplest way to integrate DSR in smart contracts\nThe \nDsrManager\n provides an easy to use smart contract that allows service providers to deposit/withdraw dai into the DSR contract \npot\n, and activate/deactivate the Dai Savings Rate to start earning savings on a pool of dai in a single function call. To understand the DsrManager, it is necessary to have an understanding of the \npot\n first. The DSR is set by Maker Governance, and will typically be less than the base stability fee to remain sustainable. The purpose of DSR is to offer another incentive for holding Dai.\nDeployment Details\nMainnet: \n0x373238337Bfe1146fb49989fc222523f83081dDb\n\u0432\u0496\u04e2\nKovan: \n0x7f5d60432DE4840a3E7AE7218f7D6b7A2412683a\n\u0432\u0496\u04e2\nRopsten: \n0x74ddba71e98d26ceb071a7f3287260eda8daa045\n\u0432\u0496\u04e2\nContract Details\nMath\nwad\n - some quantity of tokens, as a fixed point integer with 18 decimal places.\nray\n - a fixed point integer, with 27 decimal places.\nrad\n - a fixed point integer, with 45 decimal places.\nmul(uint, uint)\n, \nrmul(uint, uint)\n, \nadd(uint, uint)\n & \nsub(uint, uint)\n - will revert on overflow or underflow\nRdiv\n - Divide two \nray\ns and return a new \nray\n. Always rounds down. A \nray\n is a decimal number with 27 digits of precision that is being represented as an integer.\nRdivup\n - Divide two \nray\ns and return a new \nray\n. Always rounds up. A \nray\n is a decimal number with 27 digits of precision that is being represented as an integer.\nStorage\npot\n - stores the contract address of the main Dai Savings Rate contract \npot\n.\ndai\n - stores the contract address of dai.\ndaiJoin\n - stores the contract address of the Dai token adapter.\nsupply\n - the supply of Dai in the DsrManager.\npieOf\n - \nmapping (addresses=>uint256)\n mapping of user addresses and normalized Dai balances (\namount of dai / chi\n) deposited into \npot\n.\npie\n - stores the address' \npot\n balance.\nchi\n - the rate accumulator. This is the always increasing value which decides how much dai is given when \ndrip()\n is called.\nvat\n - an address that conforms to a \nVatLike\n interface.\nrho\n - the last time that \ndrip\n is called.\nFunctions and mechanics\ndaiBalance(address usr) returns (uint wad)\nCalculates and returns the Dai balance of the specified address usr in the DsrManager contract. (Existing Dai balance + accrued dsr)\njoin(address dst, uint wad)\nuint wad\n this parameter specifies the amount of Dai that you want to join to the pot. The \nwad\n amount of Dai must be present in the account of \nmsg.sender\n.\naddress \ndst\n specifies a destination address for the deposited dai in the pot. Allows a hot wallet address (\nmsg.sender\n) to deposit dai into the pot and transfer ownership of that dai to a cold wallet (or any other address for that matter)\nThe normalized balance \npie\n is calculated by dividing wad with the rate acumulator \nchi\n.\nthe \ndst\n's \npieOf\n amount is updated to include the \npie\n.\nThe total supply amount is also updated by adding the \npie\n.\nwad\n amount of dai is transferred to the DsrManager contract\nThe DsrManager contract joins \nwad\n amount of dai into the MCD system through the dai token adapter \ndaiJoin\n.\nThe DsrManager contract \njoin\ns \npie\n amount of dai to the \npot\n.\nexit(address dst, uint wad)\nexit()\n essentially functions as the exact opposite of \njoin()\n.\nuint wad\n this parameter is based on the amount of dai that you want to \nexit\n the \npot\n.\naddress \ndst\n specifies a destination address for the retrieved dai from the \npot\n. Allows a cold wallet address (\nmsg.sender\n) to retrieve dai from the \npot\n and transfer ownership of that dai to a hot wallet (or any other address for that matter)\nThe normalized balance \npie\n is calculated by dividing wad with the rate acumulator \nchi\n.\nThe \nmsg.sender\n\u0432\u0496\u04b7s \npieOf\n amount is updated by subtracting the \npie\n.\nThe total supply amount is also updated by subtracting the \npie\n.\nThe contract calls exit on the \npot\n contract.\nIt calculates the amount of dai to retrieve by multiplying \npie\n with \nchi\n.\nThen exits the dai from the dai token adapter \ndaiJoin\n to the destination address \ndst\n.\nexitAll(address dst)\nexitAll()\n functions like the \nexit\n function, except it simply looks into the mapping \npieOf\n, to determine how much dai the \nmsg.sender\n has, and \nexit\ns the entire amount of dai, instead of a specified amount.\nGotchas / Integration Concerns\nIn order to use the \njoin\n function, you need to \napprove\n the contract to transfer Dai from your wallet. You need to call \napprove\n on the Dai token, specifying the \nDsrManager\n contract and the amount that the contract should be able to pull (can be set to \n-1\n, if you want to set an unlimited approval)\nPrevious\nCDP Manager - Detailed Documentation\nNext\n - Smart Contract Modules\nFlash Mint Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/proxy-module/dsr-manager-detailed-documentation", "title": "DSR Manager - Detailed Documentation"}}
{"page_content": "Proxy Actions - Detailed Documentation\nA generalized wrapper for the Maker Protocol\nContract Name:\n DssProxyActions.sol\nType/Category:\n Proxy Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\nProxy Actions \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nProxy Actions End \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nProxy Actions DSR\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe Proxy Actions contract is a generalized wrapper for the Maker Protocol. It's basically a set of proxy functions for MCD (using dss-cdp-manager). The contract\u0432\u0496\u04b7s purpose is to be used via a personal ds-proxy and can be compared to the original Sag-Proxy as it offers the ability to execute a sequence of actions atomically.\n2. Contract Details\nGlossary (Proxy Actions)\nmanager\n - enables a formalized process for CDPs to be transferred between owners.\nilk\n - a collateral type.\nusr\n - user address.\ncdp\n - Collateralized Debt Position (now, known as \nVault\n).\ndst\n - refers to the destination address.\nwad\n - quantity of tokens, usually as a fixed point integer with 10^18 decimal places.\nrad\n - a fixed point integer, with 10^45 decimal places.\ndink\n - change in collateral.\ndart\n - change in debt.\nethJoin\n - allows native Ether to be used with the system.\ngemJoin\n - allows standard ERC20 tokens to be deposited for use with the system.\ndaiJoin\n - allows users to withdraw their Dai from the system into a standard ERC20 token.\nKey Functionalities (as defined in the smart contract)\nDssProxyActions\nopen()\n: creates an \nUrnHandler\n (\ncdp\n) for the address \nusr\n (for a specific \nilk\n) and allows the user to manage it via the internal registry of the \nmanager\n.\ngive()\n: transfers the ownership of the \ncdp\n to the \nusr\n address in the \nmanager\n registry.\ngiveToProxy()\n: transfers the ownership of \ncdp\n to the proxy of \nusr\n address (via \nproxyRegistry\n) in the \nmanager\n registry.\ncdpAllow()\n: allows/denies \nusr\n address to manage the \ncdp\n.\nurnAllow()\n: allows/denies \nusr\n address to manage the \nmsg.sender\n address as \ndst\n for \nquit\n.\nflux()\n: moves \nwad\n amount of collateral from \ncdp\n address to \ndst\n address.\nmove()\n: moves \nrad\n amount of DAI from \ncdp\n address to \ndst\n address.\nfrob()\n: executes \nfrob\n to \ncdp\n address assigning the collateral freed and/or DAI drawn to the same address.\nquit()\n: moves \ncdp\n collateral balance and debt to \ndst\n address.\nenter()\n: moves \nsrc\n collateral balance and debt to \ncdp\n.\nshift()\n: moves \ncdpSrc\n collateral balance and debt to \ncdpDst\n.\nlockETH()\n: deposits \nmsg.value\n amount of ETH in \nethJoin\n adapter and executes \nfrob\n to \ncdp\n increasing the locked value.\nsafeLockETH()\n: same than \nlockETH\n but requiring \nowner == cdp owner\n.\nlockGem()\n: deposits \nwad\n amount of collateral in \ngemJoin\n adapter and executes \nfrob\n to \ncdp\n increasing the locked value. Gets funds from \nmsg.sender\n if \ntransferFrom == true\n.\nsafeLockGem()\n: same than \nlockGem\n but requiring \nowner == cdp owner\n.\nfreeETH()\n: executes \nfrob\n to \ncdp\n decreasing locked collateral and withdraws \nwad\n amount of ETH from \nethJoin\n adapter.\nfreeGem()\n: executes \nfrob\n to \ncdp\n decreasing locked collateral and withdraws \nwad\n amount of collateral from \ngemJoin\n adapter.\ndraw()\n: updates collateral fee rate, executes \nfrob\n to \ncdp\n increasing debt and exits \nwad\n amount of DAI token (minting it) from \ndaiJoin\n adapter.\nwipe()\n: joins \nwad\n amount of DAI token to \ndaiJoin\n adapter (burning it) and executes \nfrob\n to \ncdp\n for decreasing debt.\nsafeWipe()\n: same as \nwipe\n but requiring \nowner == cdp owner\n.\nwipeAll()\n: joins all the necessary amount of DAI token to \ndaiJoin\n adapter (burning it) and executes \nfrob\n to \ncdp\n setting the debt to zero.\nsafeWipeAll()\n: same as \nwipeAll\n but requiring \nowner == cdp owner\n.\nlockETHAndDraw()\n: combines \nlockETH\n and \ndraw\n.\nopenLockETHAndDraw()\n: combines \nopen\n, \nlockETH\n and \ndraw\n.\nlockGemAndDraw()\n: combines \nlockGem\n and \ndraw\n.\nopenLockGemAndDraw()\n: combines \nopen\n, \nlockGem\n and \ndraw\n.\nwipeAndFreeETH()\n: combines \nwipe\n and \nfreeETH\n.\nwipeAllAndFreeETH()\n: combines \nwipeAll\n and \nfreeETH\n.\nwipeAndFreeGem()\n: combines \nwipe\n and \nfreeGem\n.\nwipeAllAndFreeGem()\n: combines \nwipeAll\n and \nfreeGem\n.\nDssProxyActionsFlip\nexitETH()\n: exits \nwad\n amount of ETH from \nethJoin\n adapter. This is received in the \ncdp\n urn after the liquidation auction is over.\nexitGem()\n: exits \nwad\n amount of collateral from \ngemJoin\n adapter. This is received in the \ncdp\n urn after the liquidation auction is over.\nDssProxyActionsEnd\nfreeETH()\n: once the system is caged, this recovers the remaining ETH from \ncdp\n (pays the remaining debt if exists).\nfreeGem()\n: once the system is caged, this recovers the remaining token from \ncdp\n (pays remaining debt if exists).\npack()\n: once the system is caged, this packs \nwad\n amount of DAI to be ready for cashing.\ncashETH()\n: once the system is caged, this cashes \nwad\n amount of previously packed DAI and returns the equivalent in ETH.\ncashGem()\n: once the system is caged, this cashes \nwad\n amount of previously packed DAI and returns the equivalent in gem token.\nDssProxyActionsDsr\njoin()\n: joins \nwad\n amount of DAI token to \ndaiJoin\n adapter (burning it) and moves the balance to \npot\n for DAI Saving Rates.\nexit()\n: retrieves \nwad\n amount of DAI from \npot\n and exits DAI token from \ndaiJoin\n adapter (minting it).\nexitAll()\n: performs the same actions as \nexit\n but for all of the available amount.\n3. Key Mechanisms & Concepts\nThe \ndss-proxy-actions\n was designed to be used by the Ds-Proxy, which is owned individually by users to interact more easily with the Maker Protocol. Note that it is not intended to be used directly (this will be covered later). The \ndss-proxy-actions\n contract was developed to serve as a library for user's ds proxies. In general, the ds proxy receives two parameters:\nProxy library address\nIn this case, the dss proxy actions library\nCall data\nFunctions and parameters you want to execute\nReference the ds-proxy for more information \nhere.\n\u0432\u0496\u04e2\nDSProxy Summary (as it relates to the dss-proxy-actions contract)\nThe ds-proxy contact's purpose is to execute transactions and sequences of transactions by proxy. The contract allows code execution using a persistent identity. This can be very useful to execute a sequence of atomic actions. Since the owner of the proxy can be changed, this allows for dynamic ownership models, e.g. a multisig.\nIn the later example, we will see how the \nexecute function\n works by using the proxy to execute calldata _data on contract _code.\nThe functions parameters are:\naddress _target\nbytes memory _data\nFor the address-target you pass in, that will be the library you want to use, in this case the proxy actions library.\nFor the Memory data you pass in, that will be the call data of what exactly you want to execute.\nEx:\n Want to open a Vault; then the bytes memory data you will pass in will be an ABI encoder that executes open function with certain parameters.\nNote:\n This is used for both SCD and MCD.\nProxy Action Usage Example (How a proxy call can look like)\nproxy.execute(dssProxyActions, abi.encodeWithSignature(\"open(address,bytes32,address)\", address(manager), bytes32(\"ETH-A\"), address(0x123)))\nYour ds-proxy is only for you, so we create it for a wallet, so each wallet has its own ds proxy that nobody else should be able to execute with that proxy.\nIn MCD, the Vaults will not be owned by your wallet but by your ds proxy, which allows you to execute any function via the ds proxy. Such as performing actions within your Vaults and/or group a lot of actions within one transaction.\nThe execution looks something like this:\nProxy execute (call to the Ethereum blockchain) where the first parameter is the contract you are using for the library (in this case, dss proxy actions). Not that this is something the frontend will do for you. \nExample:\n When you want to open a Vault, it will send the transaction to the proxy to execute the execute function, and will then pass in the dss proxy action address and the second parameter that will be passed is the function itself that your ds proxy needs to execute from the dss proxy actions. In this case, we want to execute the open function from dss proxy action - so your proxy will delegate calling the open function from the dss proxy actions library. We need to do it this way because the second parameter is the bytes call data format parameter, so this function we ABI Encode with signature open. So, we pass the signature and then the actual parameters we want to pass to this function. In this case, the manager, the first param of the open function, the Collateral type, and the address you want to create the Vault for (In this case, the address is 0x123)\nNote:\n UI decides which proxy action the user will use.\n4. \nGotchas\nUsing dss-proxy-actions directly can result in the loss of control over your Vault\nIf you open a new Vault via the dss proxy actions (centralized) without a ds proxy you would be creating a Vault that is owned by the dss proxy actions that anyone could call publicly. It would be owned by the dss proxy actions contract and anyone could execute actions on your Vault. Therefore, there is significant risk if you directly use the dss proxy actions.\nWhen interacting with the dss-proxy-actions you need a certain allowance to get Dai or MKR funds from the user's wallet. You need allowance from your wallet to the ds-proxy (not dss-proxy-actions). Because, when you execute the dss-proxy actions, you are actually performing that action in the environment of your ds-proxy, which is delegating calls or importing the function from the proxy actions and not executing them directly.\n5. \nFailure Modes\nDs proxy is a general purpose proxy\nThis means that as a user of the ds-proxy, you can execute whatever you want whether that be the Dss-proxy-actions or any other piece of code. Users are therefore responsible for what they are executing and thus, need to have trust in the UI they are using (similar to any other transaction you are executing from your wallet).\nIn terms of failure modes, this means you can execute a malicious proxy action as well as a direct action that could potentially send your ETH to a random address. To be extra cautious, you should check your wallets call data and/or audit what your wallet does as they could potentially present users with some unwanted random call data and execute unwanted actions.\nOverall, this point is to say that there is always a risk when using a ds proxy.\nSmart Contract Modules - \nPrevious\nProxy Module\nNext\nVote Proxy - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/proxy-module/proxy-actions-detailed-documentation", "title": "Proxy Actions - Detailed Documentation"}}
{"page_content": "Vote Proxy - Detailed Documentation\nAllowing MKR users to vote with a hot or cold wallet using a proxy voting identity\nContract Name:\n VoteProxy.sol\nType/Category:\n Proxy Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nVoteProxy\n contract allows for MKR users to vote with a hot or cold wallet using a proxy voting identity instead of interacting directly with the chief. In addition to supporting two different voting mechanisms, the vote proxy also minimizes the time that MKR owners need to have their wallet(s) online.\n2. Contract Details\nVote Proxy (Glossary)\napprovals\n: A mapping of candidate addresses to their \nuint\n weight.\nslate\n - A mapping of \nbytes32\n to \naddress\n arrays. Represents sets of candidates. Weighted votes are given to slates.\nvotes\n: A mapping of voter addresses to the slate they have voted for.\nGOV\n: \nDSToken\n used for voting.\nIOU\n: \nDSToken\n issued in exchange for locking \nGOV\n tokens.\n3. Key Mechanisms & Concepts\nThe \nVoteProxy\n contract enables MKR owners to vote with the full weight of the MKR they own, for both for Governance and Executive votes. As mentioned above, this process also reduces the risk for MKR users when voting with a cold wallet. This is done by allowing the MKR owner to designate a \u0432\u0496\u04a3hot wallet\u0432\u0496\u049b which is used to transfer MKR to the proxy and can only be used for voting on Governance and Executive votes. The \u0432\u0496\u04a3hot wallet\u0432\u0496\u049b can then be used to lock MKR in the voting system and draw it back to their cold wallet.\nKey Functionalities (as defined in the smart contract)\nauth\n - Checks to confirm that the sender must be a Cold or Hot Wallet.\nlock\n -\n Charges the user \nwad\n MKR tokens, issues an equal amount of IOU tokens to the VoteProxy, and adds \nwad\n weight to the candidates on the user's selected slate.\nfree\n -\n Charges the user \nwad\n IOU tokens, issues an equal amount of MKR tokens to the user, and subtracts \nwad\n weight from the candidates on the user's selected slate.\nvote\n - Saves a set of ordered addresses as a slate, moves the voter's weight from their current slate to the new slate, and returns the slate's identifier.\nvote(bytes32 slate)\n - Removes voter's weight from their current slate and adds it to the specified slate.\n4. Gotchas (Potential source of user error)\nOne-time proxy setup cost\nAs a new proxy contract user, you will need to set it up before you can use it for future voting. The price of the setup will depend on the current Ethereum gas price but will ultimately make voting easier and safer for users.\nAny MKR moved/transferred from a user's vote proxy during a Polling vote, will be subtracted/removed from any existing poll that a user has voted on. For your vote to count, you must ensure the MKR is in your wallet when the poll ends.\nNote:\n For the users who don't want to use the \nVoteProxy\n, they can now vote directly with a single wallet, by depositing directly into Chief and then voting with their wallet.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nThe loss of private keys for both the hot and cold wallet will prevent you from voting.\nPrevious\nProxy Actions - Detailed Documentation\nNext\nCDP Manager - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/proxy-module/vote-proxy-detailed-documentation", "title": "Vote Proxy - Detailed Documentation"}}
{"page_content": "Jug - Detailed Documentation\nAccumulation of Stability Fees for Collateral Types\nContract Name:\n Jug\nType/Category: \nDSS \u0432\u0496\u201d> Rates Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction\nSummary\nThe primary function of the Jug smart contract is to accumulate stability fees for a particular collateral type whenever its \ndrip()\n method is called. This effectively updates the accumulated debt for all Vaults of that collateral type as well as the total accumulated debt as tracked by the Vat (global) and the amount of Dai surplus (represented as the amount of Dai owned by the \nVow\n).\n2. Contract Details\nStructs\nIlk\n : contains two \nuint256\n values\u0432\u0496\u201d\nduty\n, the collateral-specific risk premium, and \nrho\n, the timestamp of the last fee update\nVatLike\n : mock contract to make Vat interfaces callable from code without an explicit dependency on the Vat contract itself\nStorage Layout\nwards\n : \nmapping(address => uint)\n that indicates which addresses may call administrative functions\nilks\n : \nmapping (bytes32 => Ilk)\n that stores an \nIlk\n struct for each collateral type\nvat\n : a \nVatLike\n that points the the system's \nVat\n contract\nvow\n : the \naddress\n of the Vow contract\nbase\n : a \nuint256\n that specifies a fee applying to all collateral types\nPublic Methods\nAdministrative Methods\nThese methods require \nwards[msg.sender] == 1\n (i.e. only authorized users may call them).\nrely\n/\ndeny\n : add or remove authorized users (via modifications to the \nwards\n mapping)\ninit(bytes32)\n : start stability fee collection for a particular collateral type\nfile(bytes32, bytes32, uint)\n : set \nduty\n for a particular collateral type\nfile(bytes32, data)\n : set the \nbase\n value\nfile(bytes32, address)\n : set the \nvow\n value\nFee Collection Methods\ndrip(bytes32)\n : collect stability fees for a given collateral type\n3. Key Mechanisms & Concepts\ndrip\ndrip(bytes32 ilk)\n performs stability fee collection for a specific collateral type when it is called (note that it is a public function and may be called by anyone). \ndrip\n does essentially three things:\n1.\ncalculates the change in the rate parameter for the collateral type specified by \nilk\n based on the time elapsed since the last update and the current instantaneous rate (\nbase + duty\n);\n2.\ncalls \nVat.fold\n to update the collateral's \nrate\n, total tracked debt, and Vow surplus;\n3.\nupdates \nilks[ilk].rho\n to be equal to the current timestamp.\nThe change in the rate is calculated as:\n\u041e\u201d\nr\na\nt\ne\n=\n(\nb\na\ns\ne\n+\nd\nu\nt\ny\n)\nn\no\nw\n\u0432\u04b2\u2019\nr\nh\no\n\u0432\u04e2\u2026\nr\na\nt\ne\n\u0432\u04b2\u2019\nr\na\nt\ne\n\\Delta rate = (base+duty)^{now-rho} \\cdot rate- rate\n\u041e\u201d\nr\na\nt\ne\n=\n(\nba\nse\n+\nd\nu\nt\ny\n)\nn\no\nw\n\u0432\u04b2\u2019\nr\nh\no\n\u0432\u04e2\u2026\nr\na\nt\ne\n\u0432\u04b2\u2019\nr\na\nt\ne\nwhere \"now\" represents the current time, \"rate\" is \nVat.ilks[ilk].rate\n, \"base\" is \nJug.base\n, \"rho\" is \nJug.ilks[ilk].rho\n, and \"duty\" is \nJug.ilks[ilk].duty\n. The function reverts if any sub-calculation results in under- or overflow. Refer to the Vat documentation for more detail on \nfold\n.\nrpow\nrpow(uint x, uint n, uint b)\n, used for exponentiation in \ndrip\n, is a fixed-point arithmetic function that raises \nx\n to the power \nn\n. It is implemented in Solidity assembly as a repeated squaring algorithm. \nx\n and the returned value are to be interpreted as fixed-point integers with scaling factor \nb\n. For example, if \nb == 100\n, this specifies two decimal digits of precision and the normal decimal value 2.1 would be represented as 210; \nrpow(210, 2, 100)\n returns 441 (the two-decimal digit fixed-point representation of 2.1^2 = 4.41). In the current implementation, 10^27 is passed for \nb\n, making \nx\n and the \nrpow\n result both of type \nray\n in standard MCD fixed-point terminology. \nrpow\n's formal invariants include \"no overflow\" as well as constraints on gas usage.\nParameters Can Only Be Set By Governance\nJug stores some sensitive parameters, particularly the base rate and collateral-specific risk premiums that determine the overall stability fee rate for each collateral type. Its built-in authorization mechanisms need to allow only authorized MakerDAO governance contracts/actors to set these values. See \"Failure Modes\" for a description of what can go wrong if parameters are set to unsafe values.\n4. Gotchas (Potential Sources of User Error)\nIlk Initialization\ninit(bytes32 ilk)\n must called when a new collateral is added (setting \nduty\n via \nfile()\n is not sufficient)\u0432\u0496\u201dotherwise \nrho\n will be uninitialized and fees will accumulate based on a start date of January 1st, 1970 (start of Unix epoch).\nbase + Ilk.duty\n imbalance in \ndrip()\nA call to \ndrip(bytes32 ilk)\nwill add the \nbase\n rate to the \nIlk.duty\n rate. The rate is a calculated compounded rate, so \nrate(base + duty) != rate(base) + rate(duty)\n. This means that if base is set, the duty will need to be set factoring the existing compounding factor in base, otherwise the result will be outside of the rate tolerance. Updates to the \nbase\n value will require all of the \nilks\n to be updated as well. \n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nTragedy of the Commons\nIf \ndrip()\n is called very infrequently for some collateral types (due, for example, to low overall system usage or extremely stable collateral types that have essentially zero liquidation risk), then the system will fail to collect fees on Vaults opened and closed between \ndrip()\n calls. As the system achieves scale, this becomes less of a concern, as both Keepers and MKR holders are have an incentive to regularly call drip (the former to trigger liquidation auctions, the latter to ensure that surplus accumulates to decrease MKR supply); however, a hypothetical asset with very low volatility yet high risk premium might still see infrequent drip calls at scale (there is not at present a real-world example of this\u0432\u0496\u201dthe most realistic possibility is \nbase\n being large, elevating rates for all collateral types).\nMalicious or Careless Parameter Setting\nVarious parameters of Jug may be set to values that damage the system. While this can occur by accident, the greatest concern is malicious attacks, especially by an entity that somehow becomes authorized to make calls directly to Jug's administrative methods, bypassing governance. Setting \nduty\n (for at least one ilk) or \nbase\n too low can lead to Dai oversupply; setting either one too high can trigger excess liquidations and therefore unjust loss of collateral. Setting a value for \nvow\n other than the true Vow's address can cause surplus to be lost or stolen.\nPrevious\nPot - Detailed Documentation\nNext\n - Smart Contract Modules\nProxy Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/rates-module/jug-detailed-documentation", "title": "Jug - Detailed Documentation"}}
{"page_content": "Pot - Detailed Documentation\nThe Dai Savings Rate\nContract Name:\n pot.sol\nType/Category:\n DSS \u2014> Rates Module\n\u200b\nAssociated MCD System Diagram\n\u200b\n\u200b\nContract Source\n\u200b\n\u200b\nEtherscan\n\u200b\n1. Introduction (Summary)\nThe Pot is the core of the\nDai Savings Rate\n. It allows users to deposit \ndai\n and activate the Dai Savings Rate and earning savings on their \ndai\n. The DSR is set by Maker Governance, and will typically be less than the base stability fee to remain sustainable. The purpose of Pot is to offer another incentive for holding Dai.\n2. Contract Details\nMath\nmul(uint, uint)\n, \nrmul(uint, uint)\n, \nadd(uint, uint)\n& \nsub(uint, uint)\n - will revert on overflow or underflow\nrpow(uint x, uint n, uint base)\n, used for exponentiation in \ndrip\n, is a fixed-point arithmetic function that raises \nx\n to the power \nn\n. It is implemented in assembly as a repeated squaring algorithm. \nx\n (and the result) are to be interpreted as fixed-point integers with scaling factor \nbase\n. For example, if \nbase == 100\n, this specifies two decimal digits of precision and the normal decimal value 2.1 would be represented as 210; \nrpow(210, 2, 100)\n should return 441 (the two-decimal digit fixed-point representation of 2.1^2 = 4.41). In the current implementation, 10^27 is passed for \nbase\n, making \nx\n and the \nrpow\n result both of type \nray\n in standard MCD fixed-point terminology. \nrpow\n\u2019s formal invariants include \u201cno overflow\u201d as well as constraints on gas usage.\nAuth\nwards\n are allowed to call protected functions (Administration)\nStorage\npie\n - stores the address' \nPot\n balance.\nPie\n - stores the total balance in the \nPot\n.\ndsr\n - the \ndai savings rate\n. It starts as \n1\n (\nONE = 10^27\n), but can be updated by governance.\nchi\n - the rate accumulator. This is the always increasing value which decides how much \ndai\n - given when \ndrip()\n is called.\nvat\n - an address that conforms to a \nVatLike\n interface. It is set during the constructor and \ncannot be changed\n.\nvow\n - an address that conforms to a \nVowLike\n interface. Not set in constructor. Must be set by governance.\nrho\n - the last time that drip is called.\nThe values of \ndsr\n and \nvow\n can be changed by an authorized address in the contract (i.e. Maker Governance). The values of \nchi\n, \npie\n, \nPie\n, and \nrho\n are updated internally in the contract and cannot be changed manually.\n3. Key Mechanisms & Concepts\ndrip()\nCalculates the most recent \nchi\n and pulls \ndai\n from the \nvow\n (by increasing the \nVow\n's \nSin\n).\nA user should always make sure that this has been called before calling the \nexit()\n function.\ndrip has to be called before a user \njoin\ns and it is in their interest to call it again before they \nexit\n, but there isn't a set rule for how often drip is called.\njoin(uint wad)\nuint wad\n this parameter is based on the amount of dai (since \nwad\n = \ndai\n/ \nchi\n ) that you want to \njoin\n to the \npot\n. The \nwad * chi\n must be present in the \nvat\n and owned by the \nmsg.sender\n.\nthe \nmsg.sender\n's \npie\n amount is updated to include the \nwad\n.\nthe total \nPie\n amount is also updated to include the \nwad\n.\nexit(uint wad)\nexit()\n essentially functions as the exact opposite of \njoin()\n.\nuint wad\n this parameter is based on the amount of dai that you want to \nexit\n the \npot\n. The \nwad * chi\n must be present in the \nvat\n and owned by the \npot\n and must be less than \nmsg.sender\n's \npie\n balance.\nThe \nmsg.senders\n \npie\n amount is updated by subtracting the \nwad\n.\nThe total \nPie\n amount is also updated by subtracting the \nwad\n.\nAdministration\nVarious file function signatures for administering \nPot\n:\nSetting new dsr (\nfile(bytes32, uint256)\n)\nSetting new vow (\nfile(bytes32, address)\n)\nUsage\nThe primary usage will be for \naddresses\n to store their \ndai\n in the \npot\n to accumulate interest over time\n4. Gotchas / Integration Concerns\nThe \ndsr\n is set (globally) through the governance system. It can be set to any number > 0%. This includes the possibility of it being set to a number that would cause the DSR to accumulate faster than the collective Stability Fees, thereby accruing system debt and eventually causing MKR to be minted.\nIf \ndrip()\n has not been called recently before an address calls \nexit()\n they will not get the full amount they have earned over the time of their deposit.\nIf a user wants to \njoin\n or \nexit\n 1 DAI into/from the Pot, they should send a \nwad\n = to \n1 / chi\n as the amount moved from their balance will be \n1 * chi\n (for an example of this, see \nDSS-Proxy-Actions\n\u200b\n5. Failure Modes and Impact\nCoding Error\nA bug in the \nPot\n could lead to locking of \ndai\n if the \nexit()\n function or the underlying \nvat.suck()\n or \nvat.move()\n functions were to have bugs.\nGovernance\nThe \ndsr\n rate initially can be set through the Chief. Governance will be able to change the DSR based on the rules that the DS-Chief employs (which would include a Pause for actions).\nOne serious risk is if governance chooses to set the \ndsr\n to an extremely high rate, this could cause the system's fees to be far too high. Furthermore, if governance allows the \ndsr\n to (significantly) exceed the system fees, it would cause debt to accrue and increase the Flop auctions.\nSmart Contract Modules - \nPrevious\nRates Module\nNext\nJug - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/rates-module/pot-detailed-documentation", "title": "Pot - Detailed Documentation"}}
{"page_content": "Emergency Shutdown for Partners\nHow to prepare for ES as a partner\nFor a quick overview of Emergency Shutdown within the Maker Protocol and the process to follow as an integration partner, please download and read the ES Partner Integration Slide Deck (PDF) below.\nEmergency Shutdown for Integration Partners .pdf\n556KB\nPDF\nES Partner Integration\nSmart Contract Modules - \nPrevious\nMaker Protocol Emergency Shutdown\nNext\nThe Emergency Shutdown Process for Multi-Collateral Dai (MCD)\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/shutdown/emergency-shutdown-for-partners", "title": "Emergency Shutdown for Partners"}}
{"page_content": "ESM - Detailed Documentation\nThe ESM is the trigger system for the shutdown of the Maker Protocol\nContract Name:\n esm.sol\nType/Category:\n Emergency Shutdown Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe Emergency Shutdown Module (ESM) is a contract with the ability to call \nEnd.cage()\n to trigger the Shutdown of the Maker Protocol.\n2. Contract Details\nESM (Glossary)\nKey Functionalities (as defined in the smart contract)\nrely\n - Grant an address admin powers\ndeny\n - Revoke admin powers from an address\nfile\n - Allow admin to update threshold \nmin\n and address of \nend\ncage\n - Permanently disable the shutdown module\nfire\n - Trigger shutdown by calling \nEnd.cage\ndenyProxy\n - Following the wards rely/deny pattern, calls deny on a given contract\njoin\n - Deposit MKR to the shutdown module\nburn\n - Burn any MKR deposited into the shutdown module\nOther\ngem\n - MKR Token contract [address]\nwards(admin: address)\n - Whether an address has admin powers [address: uint]\nsum(usr: address)\n - MKR join balance by user [address: uint]\nSum\n - Total MKR deposited [uint]\nmin\n - Minimum MKR amount required for \nfire\n and \ndenyProxy\n [uint]\nend\n - The End contract [address]\nlive\n - Whether the contract is live (not caged) [uint]\n3. Key Mechanisms & Concepts\nMKR holders that wish to trigger Shutdown must \njoin\n MKR into the ESM. When the ESM's internal \nSum\n variable is equal to or greater than the minimum threshold (\nmin\n), the ESM's \nfire()\n and \ndenyProxy()\n methods may be called by anyone. The \nfire()\n method, in turn, calls \nEnd.cage()\n, which starts the Shutdown process.\nThe ESM is intended to be used in a few potential scenarios:\nTo mitigate malicious governance\nTo prevent the exploitation of a critical bug (for example one that allows collateral to be stolen)\nIn the case of a malicious governance attack, the joiners will have no expectation of recovering their funds (as that would require a malicious majority to pass the required vote), and their only option is to set up an alternative fork in which the majority's funds are slashed and their funds are restored.\nIn other cases, the remaining MKR holders may choose to refund the ESM joiners by minting new tokens.\nNote:\n Governance can disarm the ESM by calling \ncage()\n (this is distinct from \nEnd.cage()\n).\n4. Gotchas (Potential Source of User Error)\nUnrecoverable of Funds\nIt is important for users to keep in mind that joining MKR into the ESM is irreversible\u0432\u0496\u201dthey lose it forever, regardless of whether they successfully trigger Shutdown. While it is possible that the remaining MKR holders may vote to mint new tokens for those that lose them triggering the ESM, there is no guarantee of this.\nGame Theory of Funding and Firing the ESM\nAn entity wishing to trigger the ESM but possessing insufficient MKR to do so independently must proceed with caution. The entity could simply send MKR to the ESM to signal its desire and hope others join in; this, however, is poor strategy. Governance, whether honest or malicious, will see this, and likely move to de-authorize the ESM before the tipping point can be reached. It is clear why malicious governance would do so, but honest governance might act in a similar fashion\u0432\u0496\u201de.g. to prevent the system from being shut down by trolls or simply to maintain a constant threshold for ESM activation. (Honest governance, or even deceptive malicious governance, would be expected to then replace the ESM.) If governance succeeds in this, the entity has simply lost MKR without accomplishing anything.\nIf an entity with insufficient MKR wishes to trigger the ESM, it is better off first coordinating with others either off-chain or ideally via a trustless smart contract.. If a smart contract is used, it would be best if it employed zero-knowledge cryptography and other privacy-preserving techniques (such as transaction relayers) to obscure information such as the current amount of MKR committed and the addresses of those in support.\nIf an entity thinks others will join in before governance can react (e.g. if the delay for governance actions is very long), it is still possible that directly sending insufficient MKR to the ESM may work, but it carries a high degree of risk. Governance could even collude with miners to prevent \ncage\n calls, etc if they suspect an ESM triggering is being organized and wish to prevent it.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nAuthorization Misconfigurations\nThe ESM itself does not have an isolated failure mode, but if the other parts of the system do not have proper authorization configurations (e.g. the End contract does not authorize the ESM to call \ncage()\n), then the ESM's \nfire()\n method may be unable to trigger the Shutdown process even if sufficient MKR has been committed to the contract.\nPrevious\nEnd - Detailed Documentation\nNext\n - Glossary\nMCD Glossaries\nLast modified \n1yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/shutdown/emergency-shutdown-module", "title": "ESM - Detailed Documentation"}}
{"page_content": "End - Detailed Documentation\nShutdown\nContract Name:\n end.sol\nType/Category:\n DSS\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nEnd\n's purpose is to coordinate Shutdown. In short, Shutdown closes down the system and reimburses Dai holders. This process can occur during upgrades (Dai iterations), as well as for security reasons in the event that implementation flaws arise in both in the code and in the design.\n2. Contract Details\nGlossary (Shutdown)\nKey Functionalities (as defined in the smart contract)\ncage\n - Locks the system and initiates shutdown. This is done by freezing the user-facing actions, canceling \nflap\n and \nflop\n auctions, locking the rest of the system's contracts, disabling certain governance actions that could interfere with the settlement process, and starting the cool-down period.\ncage(ilk)\n - Tags the Ilk prices / Sets the final price for an ilk (\ntag\n).\nskim\n - Settles a Vault at the tagged price / Cancels owed Dai from the Vault\nfree\n - Remove (remaining) collateral from a settled Vault. This occurs only after there is no debt in the Vault.\nthaw\n - Fixes the Dai supply after all Skims / Fixes the total outstanding supply of stablecoin.\nflow\n - Calculates the fixed price for an ilk, possibly adjusting the \ncage\n price with surplus/deficit.\npack\n - Locks Dai ahead of Cash / Puts some stablecoin into a \nbag\n in preparation for \ncash\n.\ncash\n - Exchange \npack\ned Dai for collateral / Exchange some Dai from \nbag\n for a given \ngem\n, share proportional to \nbag\n size.\nfile\n - The Governance configuration\u0432\u0496\u201dsets various parameter values.\nskip\n - optionally cancel live auctions.\nOther\nwards(usr: address)\n - Auth Mechanism\nvat\n - Vat contract\ncat\n - Cat contract\nvow\n - Vow contract\nspot\n - Spotter contract\nlive\n - Cage flag\n\"Live\" contracts have \nlive\n = 1, indicating the system is running normally. Thus, when \ncage()\n is invoked, it sets the flag to 0. This includes the \nEnd\n contract, which means that \ncage()\n can only be invoked once and the subsequent functions cannot be invoked until we are \"dead\" and in the End process\nilk\n - A collateral type\nwhen\n - Time of cage / the time of settlement.\nwait\n - Processing cooldown duration / the length of processing cooldown.\ndebt\n - Outstanding Dai after processing / outstanding stablecoin supply, after system surplus/deficit has been absorbed.\ntag\n - Cage price / price per collateral type at time of settlement.\ngap\n - Collateral shortfall / shortfall per collateral considering undercollateralised Vaults.\nArt\n - Total debt per Ilk/outstanding stablecoin debt.\nfix\n - Final cash price / the cash price for an ilk (amount per stablecoin).\nbag(usr: address)\n - Dai packed for \ncash\n / nontransferable stablecoins ready to exchange for collateral.\nout\n - Cash out / the amount of already exchanged stablecoin for a given address.\nskip\n - Optionally cancel live auctions.\nwad\n - Some quantity of tokens, usually as a fixed point integer with 10^18 decimal places.\nurn\n - A specific Vault.\ntend\n - To make a bid, increasing the bid size.\nbid\n - The quantity being offered for the \nlot\n.\nlot\n - The quantity up for auction.\ndent\n - To make a bid, decreasing the lot size.\n3. Key Mechanisms & Concepts\nNote: The Vault owner must wait for skim to free collateral since it requires art == 0.\nCage (Summary)\nThe \ncage\n is the most complex mechanism within the Maker Protocol. This is because the \ncage\n must alter the behavior of almost every component of the system as well as perform under a variety of possible undercollateralization regimes. Listed below are a number of key properties, such as Dai and Vault parity, or the lack of race conditions, which are \ndesirable (nice-to-have)\n properties of Shutdown, and are not, in fact, all satisfied by the real-world implementation of Shutdown.\nDai Parity\n - Assuming there is enough collateral in the system, it is the sum of the values of each collateral redeemed from 1 Dai equal to the target price (i.e., $1.00 ), as judged by the collateral price used by \ncage\n.\nVault Parity -\n Where each Vault is settled at the collateral price during the time of global settlement. For example, the value of the collateral left in every Vault after \ncage\n will be the equity value of the Vault before \ncage\n, as judged by the collateral price used by \ncage\n, or zero, whichever is greater.\nDai no-race condition\n - Where every Dai holder will be able to redeem the same quantity of each type of collateral, regardless of when they interact with the contract. This is the most important property, as it ensures fairness for all Dai holders.\nNear-immediate Dai redemption\n - where all Dai can be redeemed for collateral immediately after \ncage\n.\nNear-immediate Vault redemption\n - Where all free collateral can be retrieved immediately after \ncage\n .\nNo off-chain calculations\n - where the system does not require the \ncage\n authority to supply any off-chain calculated values. For example, it can rely entirely on the last OSM price feed values.\nCurrent Implementation Properties of Shutdown\nDai no-race condition \n- every dai holder will be able to redeem the same quantity of collateral, regardless of when they interact with the contract. \nVault Parity \n- Vault Owners are prioritized and are allowed to redeem their excess collateral before Dai holders. \nAt the time of Emergency Shutdown (ES), individual Vaults, entire collateral types, or the Maker protocol can be undercollateralized, which is when the value of debt exceeds the value of collateral (\"negative equity\"). \nMaker's current implementation favors Vaults owners in all cases by allowing them to free their entire amount of excess collateral. Thus, in the low likelihood event that Vaults become undercollateralized, the Dai holders receive a \"haircut\" to their claim on collateral. In other words, Dai holders\u0432\u0496\u04b7 claim may be less than a dollar\u0432\u0496\u04b7s worth of collateral.\nImmediate Vault redemption\n - After ES is initiated, Vault owners are allowed to free their collateral immediately, provided that they execute all contract calls atomically.\nNo off-chain calculations\n - The system does not require the cage authority to supply any off-chain calculated values (e.g. it can rely entirely on the last OSM feed prices). \nVow Buffer Assistance\n - After ES is initiated, any surplus (and bad debt) in the buffer acts as a reward (and penalty) distributed pro-rata to all Dai Holders. e.g. if 10% of total system debt is in the form of net surplus in the Vow, then Dai holders receive 10% more collateral.\nDai Redemption vs. Vault Redemption Discussion\nSince in some edge cases it will not be possible to satisfy all desirable properties at once, a choice must be made about which to prioritize. For example, in the presence of Vaults that have become less than 100% collateralized, a choice must be made between prioritizing Dai holders and Vault holders. If Vault holders are prioritized, those with over-collateralized Vaults keep their excess collateral, while Dai holders receive less than $1 of value per Dai. If Dai holders are prioritized, some collateral must be taken from over-collateralized Vaults to ensure Dai holders receive as close to $1 per Dai as possible. When choosing between Dai vs. Vault priority, Vault priority was chosen because we want to first prioritize Vault holders, meaning that even with a processing period for auction settlement, all Vault holders above their Liquidation Ratio (LR) should be allowed to retrieve their over-collateralization (This is accomplished by calling \nskim\n first on the Vault to remove the debt and the backing collateral and then calling \nfree\n to release the remaining collateral from the Vault).\nAuction Settlement\nThere is a time delay in Shutdown that is configurable by governance. The time delay must expire before any cashing can take place. The general guidance is that it should be long enough to ensure all auctions either finish or get skipped, but there is no guarantee of this in the code. Note that anyone can cancel a \nflip\n auction at any time by calling \nskip(ilk, auction-id)\n after the \nilk\n has been \ncage\nd (with \ncage(ilk)\n). Flap and flop auctions are frozen by the initial \ncage()\n. Both Flap and Flop auctions can be \nyank\ned to return the bids to the last bidder.\nIt\u0432\u0496\u04b7s important to note that auction cancellation is not an immediate process as ecosystem participants must call \nskip\n for flip auctions or call \nyank\n directly for flap and flop auctions. If no one calls these functions, the auctions will not be canceled.\nThe Shutdown Mechanism (9 Crucial Steps)\nAs mentioned above, the \nEnd\n's purpose is to coordinate the Shutdown of the system. This is an involved and stateful process that takes place over the nine following main steps.\n1. \ncage()\n :\nThe process begins with freezing the system and locking the prices down for each collateral type (\nilk\n). This is done by freezing the following user entry points:\nHalt the ability to deposit collateral and draw Dai from Vaults\nFlap/Flop Auctions\nDai Savings Rate (DSR)\nGovernance entry points like rely/deny and file\nNext, the system will stop all of the current flop/flap auctions allowing individual auctions to be cancelled with calls to \nyank\n on the respective auction contract. One reason these auctions get frozen and canceled is because the shutdown process was designed to pass along the system surplus or system debt to Dai holders. Additionally, there are no guarantees regarding the value of MKR during a shutdown, so mechanisms that rely on MKR's market value cannot be relied upon, which means there is no reason to keep running the auctions that impact MKR supply. More specifically, the reason for \nflop\n and \nflap\n auctions getting canceled is as follows:\nflap\n auctions will no longer serve their purpose. This is because, after a shutdown, the surplus is designed to be allocated to Dai holders. Thus, canceling \nflap\n auctions during shutdown allows the system to return the surplus Dai back to the \nVow\n\u0432\u0496\u04b7s balance and ultimately back to Dai holders.\nflop\n auctions also stop serving their purpose. This is because the bad debt is passed as a haircut (lower-than-market-value placed on an asset being used as collateral in a Vault) back to Dai holders if there is no other system surplus available.\nAs for \nflip\n auctions, they are not immediately canceled (but can be canceled by any user) because they are still tied to the valuable collateral in the system. Collateral auctions continue to run and Keepers can continue to bid on them, and if not, the auctions can be \nskipped\n.\nDespite the fact that auctions can continue to run, this does not guarantee that all of the remaining Vaults are overcollaterlized. There is also nothing that can prevent the undercollateralized and unbitten Vaults from existing at the moment \ncage()\n is called.\nDuring this time, \ncat.bite\n cannot be called as the function requires \nlive == 1\n, disabling liquidations after shutdown. Additionally, after the End begins, all vaults must be \nskim\nmed and then \nfree\nd.\nOverall, this results in flip auctions being able to continue during Shutdown or by having them reversed by a user by using \nskip()\n (similar logic to \nflap\n auctions). If an auction is skipped, the bids are returned to bidders and collateral is returned to the original Vault (with the liquidation penalty applied in the form of increased debt).\nOther notes regarding\n \nflip\n:\nEnd calls \nyank\n on the Flipper.\nyank\n closes a \ntend\n-phase (allows bids to be made, thereby increasing the \nbid\n size) of the auction by returning the guy's Dai bid and moving the Gems from the Flipper to the End.\ndent\n phase auctions (allows bids to be made, decreasing the \nlot\n size) continue to the \ndeal\n phase as they have already raised the necessary Dai and are already in the process of returning Gems to the original Vault holder.\nNotes:\nMKR could still have value if the same token is tied to another deployment of the system. Note that the system makes no assumptions about the economic value of MKR post-Shutdown.\nIt is important to note that on-auction debt and surplus are canceled and balances are transferred to the \nEnd\n contract. The last step in this process is to begin the cooldown period.\n2. \ncage(ilk)\n :\nThe \ncage(ilk)\n works by setting the \ncage\n price for each \nilk\n. It does this by reading off of the price feed. This is required as we must first process the system state before it is possible to calculate the final Dai/collateral price. In particular, we need to determine \ntwo\n things:\n(a)\n The \ngap\n, which is the collateral shortfall per collateral type by considering under-collateralized Vaults. (\nb)\n The \ndebt\n, which is the outstanding Dai supply after including the system surplus/deficit.\nWe first determine \n(a)\n by processing all Vaults with the \nskim\n function described below. Next, you can see how \n(b)\n unfolds below.\n3. \nskim(ilk, urn)\nThe \nskim(ilk)\n function works to cancel all of the owed DAI from the Vault. Any excess collateral remains within the Vault(s) for the owner(s) to claim. Then, the backing collateral is taken.\nWe then determine debt \n(b)\n by processing the ongoing Dai generation processes of the auctions. This is done to ensure that the auctions will not generate any further Dai income. This guarantees that ongoing auctions will not change the total debt of the system. This includes the two-way auction (\nFlip\n) model not allowing for any more Dai to be generated. This means that the Dai generation comes from \ntend\n auctions. Thus, if everything is in \ndent\n we know the generation is over. This occurs when all auctions are in the reverse (dent) phase. In addition to ensuring that the auctions will not generate any further Dai, the Dai Savings Rate (\npot.drip\n) must also be shut off during the End so that the total debt does not change.\nExample:\nIn terms of user scenarios, this means that the process begins with users starting to bid more and more Dai until reaching the debt. Next, they start offering less and less collateral.\nThe auctions that are in the second phase (\ndent\n - reverse auctions) no longer affect any more of the total debt, as the Dai was already recovered. Lastly, for the auctions in the first phase, they can be canceled and return the collateral and debt to the Vault.\nThere are two methods of ensuring this:\n1.\nBy using \nwait\n; or\n2.\nBy using \nskip\n.\n4. \nwait\n or \nskip\n1.\nwait\n sets the cooldown period. The time duration of \nwait\n only needs to be long enough to be able to \nskim\n all of the undercollateralized Vaults and \nskip\n all \ntend\n-phase auctions. This means that it can, in fact, be quite short (for example 5 minutes). However, due to the possibility of scenarios such as network congestion occurring, it may be set longer. \n2.\nWhen using \nskip\n, it will cancel all ongoing auctions and seize the collateral. This allows for faster processing of the auctions at the expense of more processing calls. This option allows Dai holders to retrieve their collateral much faster. The \nskip(ilk, id)\n will then proceed to cancel each of the individual flip auctions in the forward phase (\ntend\n) and retrieve all of the collateral and return Dai to the bidder. After this occurs, the reverse phase (\ndent\n) auctions can continue as they normally would, by performing either \nwait\n or \nskip\n.\nNote that both of these options are available in this implementation, with \nskip\n being enabled on a per-auction basis. When a Vault has been processed and has no debt remaining, the remaining collateral can be removed.\n5. \nfree(ilk)\n :\nThe \nfree(ilk)\n method will then remove the collateral from the caller's Vault. After \nskim\n has been called, \nfree(ilk)\n allows the owner to call as they need. It will remove all of the collateral remaining after step \n3,\n basically, all of the collateral that was not backing the debt. If you did not have debt in your Vault at the time of the \nEnd\n you do not need to do step \n3\n and can proceed directly to this step to free your collateral.\n6. \nthaw()\nAfter the processing period has elapsed, the calculation of the final price for each collateral type is possible using the \nthaw\n function. The assumption is that all under-collateralized Vaults are processed and all auctions have unwound. The purpose of \nthaw\n is to fix the total outstanding supply of Dai. Note that it may also require extra Vault processing to cover the \nvow\n surplus. The \nvat.dai(vow) == 0\n requirement is what guarantees that the vow surplus has been taken into account, which means that before you can \nthaw\n, you must \nskim\n as many Vaults as needed in order to cancel any Dai surplus in the vow. Canceling Dai surplus is done by calling \nvow.heal\n before \nthaw\n.\n7. \nflow(ilk)\nThe \nflow(ilk)\n function will calculate the cash price for a given ilk (\nfix\n) and adjusts the \nfix\n in the case of deficit/surplus. At this point in the mechanism, we have computed the final price for each collateral type and Dai holders can now turn their Dai into collateral. Each unit of Dai can claim a fixed basket of collateral. Dai holders must first \npack\n some Dai into a \nbag\n. Once packed, Dai cannot be unpacked and is not transferable. More Dai can be added to a bag later.\n8. \npack(wad)\nThe \npack(wad)\n will place Dai into a bag in preparation for \ncash\n, which dispenses collateral to \nbag\n holders. The bigger the \nbag\n, the more collateral can be released.\n9. \ncash(ilk, wad)\nLastly, we use \ncash(ilk, wad)\n to exchange some of the Dai from your \nbag\n for gems from a specific ilk. Note that the number of gems will be limited by how much packed Dai you have (how big your \nbag\n is).\n4. Gotchas (Potential source of user error)\nKeepers\nWe expect Keepers to buy up Dai from smallholders in order to claim collateral.\nThis is because a majority of Dai holders are uncertain on how to do perform specific actions during the \nEnd\n process. Due to this fact, we depend on third parties to buy up post-cage Dai to use for reclaiming large portions of Dai. Overall, there will be large amounts of Dai leftover in the system.\nNote regarding \ncash\nAt the end of the Global Settlement process, users will get a share of each collateral type. This will require them to call \ncash\n through each ilk in the system to completely cash out their Dai.\nExample:\n Users will need to call \ncash(ilk, wad)\n to redeem the proportional amount of the specified collateral that corresponds to the amount of Dai that was \npack\n\u0432\u0496\u04b7 ed, where the \npack\n function is used to aid with the redeeming of the different collaterals in different transactions. For example, let\u0432\u0496\u04b7s say you have 1000 Dai. You first \npack\n for the respective collateral types (\nilks\n), then for each \ncash\n call, you will redeem what the 1000 Dai represents from the total Dai supply. In return, you will get the same proportion of that same collateral that was locked for all Dai holders. Therefore, the best approach a Dai holder can take is to \ncash\n every collateral type (\nilk\n).\nAn additional thing to note is that if any \nilks\n are undercollateralized, Dai holders will end up taking a bit of a cut as a result. This is because other \nilks\n will not be used to \"cover for\" an underwater collateral type.\nDOS Attack\nIn order to prevent a DOS attack, whatever entity calls the \nthaw\n function should ensure that \nVow.heal()\n is called within the same transaction.\nExample:\n An attacker can send small amounts of Dai in the \nvat\n to the \nvow\n. This would prevent \nthaw\n from being called and thus, End from progressing. To prevent this, we would call \nheal\n to clear out that excess Dai and proceed with \nthaw\n.\nGovernance\nIt is important to set the correct \nwait\n period. If you set an incorrect \nwait\n/cooldown period (if this is set early on) then auctions are later extended and this is not reset.\nIt is important to note that the main problem to point out here is that if the \nwait\n allows \nthaw\n to be called too early, all the \nFlip\n auctions may not have completed and the system may have an incorrect accounting of total \ndebt\n.\nOther\nThe Cooldown period's purpose is so that auctions can be \nskip\nped and \nskim\n applies to all Vaults (not just the undercollateralized ones).\nOnce the time period between global settlement and the cool-down period has passed, Dai holders are exposed to the ability to redeem their Dai for collateral.\nTherefore the \nwait\n value should not be too large, so governance should advise for this at least.\nVault (Skim/End) Keeper - is a tool to skim underwater Vaults if not all undercollateralized Vaults are accounted for. This Keeper could be used by Maker Stakeholders such as large Dai holders/custodians, MKR governors, Redemption keepers and more.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nSince \nEnd\n will read the Collateral price from the \npip\n, this can result in the collateral price being only as accurate as the last recorded price. If \npip\n returns a bad price due to oracles getting hacked, the \nEnd\n will be affected.\nFor example:\n Calling Global Settlement because an oracle is getting attacked, we must make sure the oracles attack won\u0432\u0496\u04b7t affect the Global Settlement price because \nEnd\n reads the price off of the \npip\n (for reference, this occurs on \nline 261\n of \nend.sol\n).\nIf a bad price is queued up in the OSM, we need to make sure to fix the \ntag\n before the price is called on Global Settlement.\nExample Scenario:\n If a bad price goes through the \nmedian\n, it takes approximately 30 min for the OSM, and then the Global Settlement process takes over an hour to work. Therefore, by the time it triggers, you will have a bad price in the \npip\n and this will cause the system to fail.\nSaving this from happening depends on how quickly you react when it comes to an oracles attack as well as overall \ngovernance\n decisions.\nWe do not believe Global Settlement is a viable solution to bad Oracles. They impact the system too quickly for Global Settlement to help.\nAn Oracle attack can be caused by two main events:\nLow prices, which makes liquidations easy.\nDuring Global Settlement, setting fake low prices would allow Dai holders to get too much collateral for their Dai, making this attack profitable.\nHigh prices, which helps with buying a lot of Dai.\nWhen paired with a subsequent Global Settlement, this could be used to steal a lot / all of the collateral as that Dai would then be used to cash out.\nExample:\n If a user is able to push up the price of a collateral type, it would allow them to mint a larger amount of Dai, resulting in a larger share of the Dai pool. Thus, they could claim a larger proportional share of the collateral whether it was of one type or a slice of all types. They could then readjust the manipulated prices before that collateral slice was fixed in the \nEnd\n.\nCritical Failure Modes\nEnd.wait\n when set to maximum can result in it not being possible to call \nthaw\n and therefore resulting in the Shutdown not being able to proceed.\nEnd.wait\n, when set to the minimum, can result in \nthaw\n being called before all auctions have finished, resulting in debt being calculated incorrectly and ultimately setting a wrong collateral price.\nWhen \nEnd.cage\n is called, all Dai holders are left holding an unstable asset in place of their desired stable asset. This could result in a market price crash across all collateral due to liquidations & sell-offs.\nCatastrophic Scenario:\n \nEnd.vat\n / \nEnd.vow\n / \nEnd.cat\n / \nEnd.spot\n - when set to attacker (\naddress\n: set to attacker-controlled address), can cause shutdown to fail. This is unfixable. For this scenario to occur, the malicious entity (governance or otherwise) would need to be \nauth\n'ed on the \nEnd\n.\nPrevious\nThe Emergency Shutdown Process for Multi-Collateral Dai (MCD)\nNext\nESM - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/shutdown/end-detailed-documentation", "title": "End - Detailed Documentation"}}
{"page_content": "The Emergency Shutdown Process for Multi-Collateral Dai (MCD)\nIntroduction to the Emergency Shutdown Process\nThe Maker Protocol, which powers Multi-Collateral Dai (Dai), backs and stabilizes the value of Dai to a Target Price of 1 US Dollar, translating to a 1:1 US Dollar soft peg. The stabilization mechanism is handled through an autonomous system of smart contracts, a dynamic combination of Vaults, and appropriately incentivized external actors, such as Keepers.\n\u0432\u0496\u04e2\nKeepers\n play a critical role in maintaining the health of the system and Dai stability. In March 2020, the Maker Foundation \nunderlined\n the need for a more developed Keeper ecosystem. An increase in Keeper participation would ultimately improve the health and function of the Maker Protocol. For more information on how to get a Keeper up and running, see this\n guide\n.\nThe Maker Protocol has an \nEmergency Shutdown (ES)\n procedure that can be triggered as a last resort to protect the system and its users against a serious threat or to facilitate a Protocol upgrade.\nOverview of the Emergency Shutdown Process\nSummary\nEmergency Shutdown is intended to be triggered in the case of a system upgrade or serious emergencies, such as long-term market irrationality, a hack, or a security breach. When triggered, ES stops and shuts down the Maker Protocol while ensuring that all users, both Dai holders, and Vault users, receive the net value of assets they are entitled to under the Protocol\u0432\u0496\u04b7s smart contract logic. However, the value of Collateral that Dai holders can redeem may vary, depending on the system surplus or deficit at the time of ES. It is, therefore, possible that Dai holders will receive less or more than 1 USD worth of Collateral for 1 Dai.\nThe process of initiating ES is decentralized and controlled by MKR voters, who can trigger it by depositing MKR into the\n Emergency Shutdown Module (ESM)\n, a contract with the ability to call \nEnd.cage\n or by an Executive Vote. In the case of the ESM method, 50,000 MKR must be deposited into the ESM to trigger ES. Additionally, once users deposit MKR into the ESM, it is immediately burned. Whether through the ESM or Executive Vote method, when Cage is called, it must alter the behavior of almost every component of the system, as well as perform under a variety of possible undercollateralization scenarios.\nThe Implementation Properties of Emergency Shutdown\nDai no-race condition\n: Every Dai holder will be able to redeem the same relative quantity of collateral proportional to their Dai holdings, regardless of when they interact with the contract.\nVault Parity\n: Vault Owners are prioritized, allowing them to withdraw their excess Collateral before Dai holders are able to access Collateral.\nAt the time of ES, individual Vaults, entire collateral types, or the Maker Protocol can be undercollateralized, which is when the value of debt exceeds the value of the Collateral (\"negative equity\"). Thus, the value of Collateral that Dai holders can redeem may vary, depending on the system surplus or deficit at the time of ES. It is, therefore, possible that Dai holders will receive less or more than 1 USD worth of Collateral for 1 Dai.\nImmediate Vault redemption\n: After ES is initiated, Vault owners are allowed to free their Collateral immediately, provided that they execute all contract calls atomically.\nNo off-chain calculations\n: The system does not require the cage authority to supply any off-chain calculated values (i.e., it can rely entirely on the last OSM feed prices).\nVow Buffer Assistance\n: After ES is initiated, any surplus or bad debt in the buffer acts as a reward or penalty distributed pro-rata to all Dai holders. For example, if 10% of total system debt is in the form of net surplus in the Vow, then Dai holders receive 10% more Collateral.\nDai and Collateral Redemption During Emergency Shutdown\nEmergency Shutdown Process for Vault Owners\nVault owners can retrieve excess Collateral from their Vaults immediately after the initialization of ES. They can do this via Vault frontends, such as \nOasis Borrow\n, that have ES support implemented, or via command-line tools.\nEmergency Shutdown Process for Dai Holders\nDai holders can, after a waiting period (for processing) determined by MKR voters, barter their Dai for a relative pro-rata share of all types of Collateral in the system. The amount of Collateral that can be claimed during this period is determined by the Maker Oracles at the time ES is triggered. It's important to note that Dai holders will always receive the same relative pro-rata amount of Collateral from the system, whether their claims are among the first or last to be processed. The Maker Foundation will initially offer a web page for this purpose to make the process easier for Dai holders.\nWhy Emergency Shutdown Prioritizes Vault Owners Over Dai Holders\nThe prioritization of Vault Owners over Dai Holders during ES can be broken down into three main points: \n1.\nOvercollateralized Vaults do not subsidize the Maker Protocol for undercollateralized Vaults during the current operation of the system, so it's consistent for ES to have the same behavior. The main difference is that a potential haircut is transferred from MKR holders to DAI holders, as no assumptions can be made about the value of MKR after a shutdown.\n2.\n Giving priority to Vault owners to recover their excess Collateral (if their Vault is not undercollateralized) incentivizes them to maintain overcollateralization. This is important because the incentive remains even if an ES seems likely, which ultimately makes the Protocol more resilient.\n3.\nStability fees accrued pre-ES are not waived by ES. Vault owners may accept higher fees if they know they are protected from the collateralization levels of others, potentially resulting in a higher surplus during ES scenarios as well as allowing for a higher DSR during normal operation.\nAuction Settlement During Emergency Shutdown\nThere is a time delay in the Emergency Shutdown that is determined by governance. The delay must expire before any exchange of Dai for Collateral can take place. The general guidance is that the delay should be long enough to ensure all auctions either finish or get skipped; but, there is no guarantee of this in the code. Importantly, anyone can cancel a collateral (Flip) auction at any time, whereas Surplus (Flap) and Debt (Flop) auctions are frozen by the initial calling of \nCage\n. Both Flap and Flop auctions can be called to return the bids to the last bidder.\nNote also that auction cancellation is not an immediate process, as ecosystem participants must cancel all ongoing collateral auctions to appropriate the Collateral and return it to the collateral pool. This allows for faster processing of the auctions at the expense of more processing calls. As for the surplus and debt auctions, they must also be called. If no one calls these functions, the auctions will not be canceled.\nEmergency Shutdown Intentions \nEmergency Shutdown may take two \nmain forms. For one, ES may be triggered, and the system is terminated without a future plan for redeployment. This allows users to claim excess Collateral or claim Collateral from their Dai.\nOn the other hand, Emergency Shutdown may be initiated with a Redeployment Scenario. \nThis\n \nsituation may arise when the system has been triggered into a shutdown event. Still, MKR token holders, or a third party, have decided to redeploy the system with necessary changes to rerun the system. This will allow users to open new Vaults and have a new Dai token while claiming Collateral from the old system.\nHow Emergency Shutdown Affects Users \nDuring an Emergency Shutdown, each of the various Maker Ecosystem Stakeholders should act accordingly:  \nDai Holders\nIf your wallet has the viable interface to claim Collateral or migrate your Dai, or it has a Dapp browser built into it, you may use the \nmigration portal\n to claim Collateral and/or migrate. If your wallet does \nnot\n support the above functionality, you must transfer your Dai to a new wallet that enables the functionality before proceeding to use the \nmigration portal\n.\nVault Owners\nIf you use \nOasis.app/borrow\n to manage your Vault, proceed to the \nmigration portal\n and follow the outlined emergency redemption process.\nIf you are a user of a third-party interface, such as \nDefiSaver\n or \nInstaDapp\n, verify that they have Emergency Shutdown Interfaces built-in before proceeding. If so, use their interface to claim the excess Collateral or migrate to a newly deployed system. If the third-party provider does not have the redemption process built-in, transfer to the \nmigration portal\n if possible.\nMKR Holders\nMKR holders may vote on polls and executive votes as it relates to the Emergency Shutdown triggering process. This is done in the Emergency Shutdown Module (ESM) frontend or directly through the \nES CLI\n. Additionally, MKR holders may also vote as it relates to a future redeployment of the Maker Protocol on the \nGovernance Portal\n.\nCentralized Exchange or Custodial Wallet\nIn the case of Emergency Shutdown, service providers may follow the actions recommended below.\nRecommended Procedure\nAlert users to the current situation and provide guidance on the right action(s) to take. Depending on the ES scenario, Shutdown, or redeployment, advise them to act accordingly.\nGive users options to withdraw their Dai/MKR from the exchange, or inform them that the exchange/wallet will handle the Emergency Shutdown process on their behalf.\nScenario: Shutdown\nChoose one of the following options:\nOption 1: \nLet users withdraw Dai and MKR from the platform, and then guide them to the \nmigration portal\n for the redemption process.\nOption 2:\n Claim Dai equivalent in Collateral on behalf of users using the \nmigration portal\n.\nChoose one of the following:\nDistribute Collateral to users.\nGet withdrawal address from users for collateral types not supported on the exchange.\nKeep the Collateral (to sell off, for example) and update user internal fiat balances to reflect their entitled amount.\nScenario: Redeployment\nMigrate Dai holdings to new Dai token on behalf of users using the \nmigration portal\n.\nAlternatively, carry out-migration by interacting directly with the migration contracts using CLI tools. See \nthis guide\n.\nIf applicable, migrate MKR token holdings on behalf of users using the \nmigration portal\n\u0432\u0496\u04e2\nUpdate token address(es) in your system.\nNon-Custodial Wallet\nIn case of Emergency Shutdown, non-custodial wallet providers should alert your user base about ES and provide public links for more information. You may follow the recommended procedures listed below in the case of Emergency Shutdown.\nRecommended Procedure\nScenario: Shutdown\nRedirect users to the \nmigration portal\n to claim their Dai equivalent in Collateral, or create an interface to handle the process locally.\nScenario: Redeployment\nInform users to migrate their Dai on the \nmigration portal\n, or create an internal interface to handle the process locally.\nAdd featured support for new token(s).\nDecentralized Exchanges (DEXs)\nAs a decentralized exchange, you can inform users with a banner about the current status of the Maker Protocol and direct them toward relevant communication channels to find out more. \nYou may choose one of the two following options to allow your users to carry out the ES redemption process:\nDirect them to the \nmigration portal\n, where they can start the claiming process for their Dai.\nBuild an interface to handle the ES process on your platform, inform your users, and have them act accordingly.\nRecommended Procedure:\nScenario: Shutdown\nInform users to claim equivalent value of Dai in Collateral on the \nmigration portal\n or create an interface to handle the process locally.\nScenario: Redeployment\nInform users to migrate their Dai to the new Dai (and MKR if applicable) on the \nmigration portal\n, or create an interface to handle the process on your platform.\nAdd new token(s) to the exchange.\nDapp Browsers\nAs a dapp browser, please make sure to alert your user base about ES and provide links to more information (e.g.,\n blog.makerdao.com\n or\n makerdao.com\n). In case of either an emergency system shutdown or system redeployment after ES is triggered, redirect your users to the \nmigration portal\n to claim their Collateral.\nVault Integrators\nAs a Vault integrator, it is very important that you integrate with Maker Protocol contracts (more specifically, end.sol). This crucial integration will allow you to quickly create a reactive logic that will handle the post-ES process for your users. If you are a custodial service, such as a centralized exchange, please inform your users in advance about your plan on handling the Emergency Shutdown event. You may follow the recommended procedures listed below in the case of Emergency Shutdown.\nRecommended Procedure\nScenario: Shutdown\nClaim users\u0432\u0496\u04b7 funds through the \nmigration portal\n or by direct interaction with the migration contracts, and make them available in their accounts.\nScenario: Redeployment\nMigrate users\u0432\u0496\u04b7 funds to a new redeployed system using the \nmigration portal\n or by interacting directly with the migration contracts.\nAs a \nnon-custodial Vault integrator\n, please make sure to integrate with the Maker Protocol contracts (end.sol). This allows you to be notified at the exact moment the Shutdown has been triggered. Otherwise, it is suggested that you inform your users on how they can free Collateral in Vaults. This can either be done in the non-custodial Vault integrator\u0432\u0496\u04b7s UI or you can direct them to \nOasis.app/borrow\n if the users need to migrate their Vault. If you do decide to use your own services, you will need a UI that allows users to withdraw their Vaults from a proxy contract so it shows up on the \nmigration portal\n. Direct your users there. Alternatively, you may create an interface that will help users migrate their Dai in case of a new redeployment, or allow users to claim their Collateral in case of an only shutdown scenario.\nDecentralized Applications (Dapps)\nDapps are suggested to integrate with Maker Protocol contracts (end.sol), which effectively provides a notification system that shows if Emergency Shutdown has been triggered. In terms of preparation, when ES has been triggered, have the following ready for your users:\nA UI interface that alerts and informs users about the event.\nIf your Dapp uses a proxy, you will need to enable users to exit from the proxy in order to use the migration app/portal. \nProvide official communication channels for more information as well as a link to the \nmigration portal\n for Dai and Vault redemption.\nCustodial Services\nIf you control access to the smart contracts backing your Dapp, it is suggested to allow your users to retrieve Dai or access their Vaults from their personal wallet as well as direct them to the \nmigration portal\n for the ES redemption process. Alternatively, you may claim Dai collateral or claim excess Collateral from Vaults on behalf of your users at the\n migration portal\n, and proceed to distribute it to your users, ensuring that they successfully retrieve it.\nNon-Custodial Services\nIf you don\u0432\u0496\u04b7t control the smart contracts backing your Dapp directly, then you may direct your users to the \nmigration portal\n for Dai and Vault redemption. Alternatively, you may create an interface that allows your users to claim a Dai equivalent in Collateral, or claim excess Collateral from Vaults in case of a system shutdown. Additionally, if there's a redeployment of the system, migrate Dai to the new redeployed system and/or claim excess Collateral from Vaults.\nMarket Makers\nAs a market maker during ES, you may provide liquidity in the market so that Dai holders can exchange their Dai for other assets. After there is no market to cover, you can act as a Dai holder and start migrating Dai to new Dai in case of system redeployment or claim equivalent Dai collateral in case of a system-wide shutdown.\nDetailed Description of the Emergency Shutdown Mechanism for MCD\nThis is an involved and stateful process that involves the following 9 steps.\n1. Locking the System and Initiating Shutdown of the Maker Protocol (aka Caging the System)\nLocking the prices down for each collateral type is done by freezing the following user entry points:\nVault creation\nSurplus/Debt Auctions\nDai Savings Rate (DSR)\nGovernance entry points\nNext, the system will stop all of the current debt/surplus auctions, allowing individual auctions to be canceled by calling a function that moves the first phase of a collateral auction to the \nEnd. \nThis process is completed by retrieving the Collateral and repaying Dai to the highest bidder of the respective auction contract. One reason these auctions are frozen and canceled is that the Emergency Shutdown process is designed to pass along the system surplus or system debt to Dai holders. In general, there are no guarantees regarding the value of MKR during a Shutdown and the mechanisms that typically rely on MKR's market value cannot be relied upon, ultimately resulting in there being no reason to keep running the auctions that impact MKR supply. More specifically, the reasons debt and surplus auctions get canceled are as follows:\nSurplus auctions no longer serve their purpose. This is because, after a shutdown, the surplus is designed to be allocated to Dai holders. Thus, canceling surplus auctions during Shutdown allows the system to return the surplus Dai back to the Settlement engines balance and ultimately back to Dai holders.\nDebt auctions also stop serving their purpose. This is because the bad debt is passed as a haircut (lower-than-market-value placed on an asset being used as Collateral in a Vault) back to Dai holders if there is no other system surplus available.\nAs for collateral auctions, they are not immediately canceled (but can be canceled by any user) because they are still tied to the valuable Collateral in the system. Collateral auctions continue to run, and Keepers can continue to bid on them. If there are no bidders, the live auctions can also be canceled.\nDespite the fact that auctions can continue to run, this does not guarantee that all of the remaining Vaults are overcollateralized. There is also nothing to prevent the undercollateralized and unbitten Vaults from existing at the moment \ncage \nis called.\nDuring this time, the function that adds the debt (total Dai wanted from the auction) cannot be called, as the function requires the system to be running normally, disabling liquidations after Shutdown. Additionally, after the \nEnd \nbegins, all Vaults must be settled at the tagged price, and then the remaining Collateral from a settled Vault must be removed.\nOverall, this results in collateral auctions being able to continue during Shutdown or by having them reversed by a user by canceling live auctions (similar logic to the surplus auctions). If an auction is canceled, the bids are returned to bidders, and Collateral is returned to the original Vault (with the liquidation penalty applied in the form of increased debt).\nNotes regarding collateral auctions:\nEnd moves the first phase of collateral auctions to the End by retrieving the Collateral and repaying Dai to the highest bidder.\nThe second phase of auctions allows bids to be made, while decreasing the quantity up for auction. During this phase, completed auctions are settled as they have already raised the necessary Dai and are already in the process of returning the Collateral to the original Vault holder.\nOther Notes:\nMKR could still have value if the current MKR token is tied to another deployment of the system. Note that the system makes no assumptions about the economic value of MKR post-Shutdown.\nIt is important to note that on-auction debt and surplus are canceled, and balances are transferred to the End contract. The last step in this process is to begin the cooldown period.\n2. Setting the Final Prices for the Collateral Types in the Maker Protocol\nThis process is completed by setting the system shutdown price for each collateral type. The final prices are determined by reading the price feeds from the Maker Oracles. This is required, as the system must first process the system state before it is possible to calculate the final Dai/collateral price. In particular, we need to determine two things:\n(a) The shortfall per collateral type considering undercollateralized Vaults.\n(b) The total quantity of Dai issued (total debt), which is the outstanding Dai supply after including the system surplus/deficit.\nFirstly, this is determined (a) by processing all Vaults with a function that cancels owed Dai from the Vault (described below). Next, (b) unfolds as described below.\n3. Settling Vaults at the Final Price by Canceling Owed Dai\nNext, the system will allow for the canceling of all the owed Dai from the Vault(s) in the system. Any excess collateral remains within the Vault(s) for the owner(s) to claim. Then, the backing collateral is taken.\nNext, the debt is determined \n(b)\n by processing the ongoing Dai generation operations of the auctions. Processing the ongoing Dai generation ensures that the auctions will not generate any further Dai income. This guarantees that ongoing auctions will not change the total debt of the system, which also includes the two-way auction (collateral auction) model not allowing for any more Dai to be generated. Due to this, the Dai generation comes from the first phase of collateral auctions. Thus, if everything is in the second phase of an auction (bidding on the decreasing quantity up for auction), we know the generation is over. Generation is over when all auctions are in the reverse/second phase. In addition to ensuring that the auctions will not generate any further Dai, the Dai Savings Rate (DSR) must also be shut off during the End so that the total debt does not change.\nExample:\nIn terms of user scenarios, the process begins with users bidding more and more Dai until the debt is covered. Next, they start offering less and less Collateral.\nThe auctions that are in the second phase (reverse auctions) no longer affect any more of the total debt, as the Dai was already recovered. Lastly, for the auctions in the first phase, they can be canceled, and the Collateral and debt returned to the Vault.\nOne of two methods can ensure that Collateral and debt are returned to the Vault:\n1.\nThe processing cooldown duration (length of the debt queue); or\n2.\nBy canceling live auctions.\n4. Using the Cooldown Period or Canceling Live Auctions\n1.\nSet the cooldown period. \nThe duration of the cooldown period only needs to be long enough to cancel owed Dai from the undercollateralized Vaults, and cancel the live first phase auctions. This means that it can, in fact, be quite short (i.e., 5 minutes). However, due to the possibility of scenarios such as network congestion occurring, it may be set longer.\n2.\nCanceling a live auction\n will cancel all ongoing auctions and seize the Collateral. This allows for faster processing of the auctions at the expense of more processing calls. This option allows Dai holders to retrieve their Collateral much faster. The next procedure is to cancel each of the individual Collateral (Flip) auctions in the forward first phase auctions and retrieve all of the Collateral and return Dai to the bidder. After this occurs, the second phase\u0432\u0496\u201dreverse auctions\u0432\u0496\u201dcan continue as they usually would, by setting the cooldown period or canceling the live auctions.\nNote that both of these options are available in this implementation, with the canceling of the live auctions being enabled on a per-auction basis. When a Vault has been processed and has no debt remaining, the remaining Collateral can be removed.\n5. Removing the Remaining Collateral from a Settled Vault (Only After There is no Debt in the Vault)\nNext, the system will remove the Collateral from the Vault. After the Vaults have been settled at the set final price and the owed Dai from the Vault has been canceled, the Vault owner can call this process as needed. It will remove all of the Collateral remaining after step\n 3\n\u0432\u0496\u201dbasically, all of the Collateral that was not backing the debt. If the user did not have debt in a Vault at the time of the End, he can bypass steps\n 3 and 4\n and can proceed directly to this step to free his Collateral.\n6. Stabilizing the Total Outstanding Supply of Dai\nAfter the processing period has elapsed, the calculation of the final price for each collateral type is possible using the thaw function. The assumption is that all under-collateralized Vaults are processed, and all auctions have unwound. The purpose of this function is to stabilize the total outstanding supply of Dai. Note that it may also require extra Vault processing to cover the system's surplus. Checking that the amount of Dai surplus in the core Vault engine is 0 is a requirement during this phase. This requirement is what guarantees that the system surplus has been taken into account. Furthermore, this means that before you can stabilize the total outstanding supply of Dai, you must cancel the owed Dai from as many Vaults as needed to cancel any Dai surplus in the Vow. Canceling Dai surplus is done by canceling out the surplus and debt in the system's balance sheet before you can stabilize the total outstanding supply of Dai.\n7. Calculating the Fixed Price for a Collateral Type, Possibly Adjusting the Final Collateral Price with Surplus/Deficit\nIn this step, the calculation of the exchange price for a given collateral type is determined, as well as the potential adjustment of that final exchange price in the case of deficit/surplus. At this point in the mechanism, the final price for each collateral type has been computed; Dai holders can now turn their Dai into Collateral. Each unit of Dai can claim a fixed basket of Collateral. Dai holders must first lock their Dai so that they can be ready to exchange it for Collateral. Once the Dai is locked, it cannot be unlocked and is not transferable. More Dai can be locked later, as well.\n8. Locking Dai and Exchanging it for Collateral\nThis step is when Collateral is dispensed to the Dai holders who have already locked their Dai in to be exchanged. The larger the amount of Dai locked in, the more Collateral can be released to the Dai holders.\n9. Exchanging the Locked Dai for Collateral (Proportional to the Amount Locked)\nLastly, the system will allow the exchange of some of the Dai that has been locked for specific collateral types. Note that the number of collateral tokens will be limited by how much locked Dai users have.\nGetting Support \nRocket Chat Channels\n\u0432\u0496\u04e2\nChat.makerdao.com\n. Support channels include but are not limited to:\n#general \n#dev\n#governance-and-risk\n#help\n\u0432\u0496\u04e2\nForum.Makerdao.com \n \n\u0432\u0496\u04e2\nGovernance\n \n\u0432\u0496\u04e2\nRisk\n\u0432\u0496\u04e2\nOther Resources and Documentation \n\u0432\u0496\u04e2\nIntroduction to Emergency Shutdown Blog post\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEnd Documentation \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEmergency Shutdown Module Documentation \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEmergency Shutdown Guide - MCD\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEmergency Shutdown CLI \n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nDai and Collateral Redemption during Emergency Shutdown CLI\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nCage Keeper\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEmergency Shutdown FAQ\n\u0432\u0496\u04e2\nPrevious\nEmergency Shutdown for Partners\nNext\nEnd - Detailed Documentation\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/shutdown/the-emergency-shutdown-process-for-multi-collateral-dai-mcd", "title": "The Emergency Shutdown Process for Multi-Collateral Dai (MCD)"}}
{"page_content": "Flapper - Detailed Documentation\nThe Maker Protocol's Surplus Auction House\nContract Name:\n flap.sol\nType/Category:\n DSS \u0432\u0496\u201d> System Stabilizer Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nSummary:\n Flapper is a Surplus Auction. These auctions are used to auction off a fixed amount of the surplus Dai in the system for MKR. This surplus Dai will come from the \nStability Fees\n that are accumulated from Vaults. In this auction type, bidders compete with increasing amounts of MKR. Once the auction has ended, the Dai auctioned off is sent to the winning bidder. The system then burns the MKR received from the winning bid.\nFlap Interactions with the Maker Protocol\n2. Contract Details\nFlapper (Glossary)\nFlap\n - surplus auction (selling stablecoins for MKR) [contract]\nwards [usr: address]\n - \nrely\n/\ndeny\n/\nauth\n Auth Mechanisms [uint]\nBid\n - State of a specific Auction[Bid]\nbid\n - quantity being offered for the \nlot\n (MKR) [uint]\nlot\n - lot amount (DAI) [uint]\nguy\n - high bidder [address]\ntic\n - Bid expiry [uint48]\nend\n - when the auction will finish [uint48]\nbids (id: uint)\n - storage of all \nBid\ns by \nid\n [mapping]\nvat\n - storage of the Vat's address [address]\nttl\n - bid lifetime / max bid duration (default: 3 hours) [uint48]\nlot\n - lot amount (DAI) [uint]\nbeg\n - minimum bid increase (default: 5%) [uint]\ntau\n - maximum auction duration (default: 2 days) [uint48]\nkick\n - start an auction / put up a new DAI \nlot\n for auction [function]\ntend\n - make a bid, thus increasing the bid size / submit an MKR bid (increasing \nbid\n) [function]\ndeal\n - claim a winning bid / settling a completed auction [function]\ngem\n - MKR Token [address]\nkicks\n - total auction count [uint]\nlive\n - cage flag [uint]\nfile\n - used by governance to set \nbeg\n, \nttl\n, and \ntau\n [function]\nyank\n - is used during Global Settlement to move \ntend\n phase auctions to the \nEnd\n by retrieving the collateral and repaying DAI to the highest bidder. [function]\ntick()\n \n-\n resets the \nend\n value if there has been 0 bids and the original \nend\n has passed.\nParameters Set By Governance\nThe Maker Governance voters determine the surplus limit. The surplus auction is triggered when the system has an amount of Dai above that set limit.\nParameters Set through \nfile\n:\nbeg\nttl\ntau\nNote:\n MKR governance also determines the \nVow.bump\n which sets the \nBid.lot\n for each Flap auction and the \nVow.hump\n which determines the surplus buffer.\nAuthorizations\nauth\n - check whether an address can call this method [modifier function]\nrely\n - allow an address to call auth'ed methods [function]\ndeny\n - disallow an address from calling auth'ed methods [function]\n3. Key Mechanisms & Concepts\nThe mechanism begins with the MKR holders (Maker Governance Voters) of the system. MKR holders will specify the amount of surplus allowed in the system through the voting system. Once they come to an agreement on what it should be set to, surplus auctions are triggered when the system has a surplus of DAI above the amount decided during the vote. System surplus is determined in the \nVow\n when the \nVow\n has \nno system debt\n and has accumulated enough DAI to \nexceed the Surplus auction size (\nbump\n) plus the buffer (\nhump\n)\n\u0432\u0496\u04e2\nIn order to determine whether the system has a net surplus, both the income and debt in the system must be reconciled. In short, any user can do this by sending the \nheal transaction\n to the system contract named the \"Vow\". Provided there is a net surplus in the system, the surplus auction will begin when any user sends the \nflap\n transaction to the \nVow contract\n.\nOnce the auction has begun, a fixed amount (\nlot\n) of DAI is put up for sale. Bidders then complete for a fixed \nlot\n amount of DAI with increasing \nbid\n amounts of MKR. In other words, this means that bidders will keep placing MKR bid amounts in increments greater than the minimum bid increase amount that has been set (this is the \nbeg\n in action).\nThe surplus auction officially ends when the bid duration ends (\nttl\n) without another bid getting placed \nOR\n when auction duration (\ntau\n) has been reached. At auction end, the MKR received for the surplus DAI is then sent to be burnt thereby contracting the overall MKR supply.\nA diagram detailing the interactions a user has with Flapper and the Vow.\n4. Gotchas (Potential source of user error)\nKeepers\nIn the context of running a keeper (more info \nhere\n) in order to perform bids within an auction, a primary failure mode could occur when a keeper specifies an unprofitable price for MKR.\nThis failure mode is due to the fact that there is nothing the system can do to stop a user from paying significantly more than the fair market value for the token in an auction (this goes for all auction types, \nflip\n, \nflop\n, and \nflap\n).\nKeepers that are performing badly in a \nflap\n auction run the risk of overpaying MKR for the DAI as there is no upper limit to the \nbid\n size other than their MKR balance.\nBid Increments During an Auction\nDuring \ntend\n, \nbid\n amounts will increase by a \nbeg\n percentage with each new \ntend\n. The bidder must know the auction's \nid\n, specify the right amount of \nlot\n for the auction, bid at least \nbeg\n % more than the last bid and must have a sufficient MKR balance.\nOne risk is \"front-running\" or malicious miners. In this scenario, an honest keeper's bid of [Past-bid + \nbeg\n%] would get committed after the dishonest keeper's bid for the same, thereby preventing the honest keeper's bid from being accepted and forcing them to rebid with a higher price ((Past-bid + beg) + beg)). The dishonest keeper would need to pay higher gas fees to try to get a miner to put their transaction in first or collude with a miner to ensure their transaction is first. This could become especially important as the bid reaches the current market rate for MKR<>DAI.\nQuick\n \nExample\n:\nThe \nbeg\n could be set to 3%, meaning if the current bidder has placed a bid of 1 MKR, then the next bid must be at least 1.03 MKR. Overall, the purpose of the bid increment system is to incentivize early bidding and make the auction process move quickly.\nPlacing Bids Incorrectly\nBidders send MKR tokens from their addresses to the system/specific auction. If one bid is beat by another, the losing bid is refunded back to that bidder\u0432\u0496\u04b7s address. It\u0432\u0496\u04b7s important to note, however, that once a bid is submitted, there is no way to cancel it. The only possible way to have that bid returned is if it is outbid (or if the system goes into Global Settlement).\nIllustration of the bidding flow:\n1.\nVow \nkick\n's a new Flap Auction.\n2.\nBidder 1 sends a bid (MKR) that increases the \nbid\n above the initial 0 value set during the \nkick\n. Bidder 1's MKR balance is decreased and the Flap's balance is increased by the bid size. \nbid.guy\n is reset from the Vow address to Bidder 1's and \nbid.tic\n is reset to \nnow + ttl\n.\n3.\nNext, Bidder 2 makes a bid that increases Bidder 1's bid by at least \nbeg\n. Bidder 2's MKR balance is decreased and Bidder 1's balance is increased by Bidder 1's \nbid\n. The difference between Bidder 2's and Bidder 1's \nbid\n is sent from Bidder 2 to the Flap.\n4.\nBidder 1 then makes a bid that increases Bidder 2's \nbid\n by at least \nbeg\n. Bidder 1's MKR balance is decreased and Bidder 2's MKR balance is increased by Bidder 2's \nbid\n. The amount Bidder 1 increased the bid is then sent from Bidder 1 to the Flap.\n5.\nBidder 2, as well as all the other bidders participating within the auction, decide it is no longer worth it to continue to bid higher \nbid\ns, so they stop making bids. Once the \nBid.tic\n expires, Bidder 1 calls \ndeal\n and the surplus DAI tokens are sent to the winning bidder's address (Bidder 1) in the \nVat\n and the system then burns the MKR received from the winning bidder. \ngem.burn(address(this), bids[id].bid)\n.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\n1. See \nSystem Stabilizer Module Documentation\n\u0432\u0496\u04e2\n2. Other Failure Modes\nResulting from when MKR is burned\nThere is the possibility where a situation arises where the MKR token makes the transaction revert (e.g. gets stopped or the Vow's permission to call burn() is revoked). In a case like this, deal can't succeed until someone fixes the issue with the MKR token. In the case of stoppage, this could include the deploying of a new MKR token. This new deployment could be completed by any individual using the MCD System but governance would need to add it to the system. Next, it would need to replace the old surplus and debt auctions with the new ones using the new MKR token. Lastly, it is crucial to enable the possibility to vote with the new version as well.\nWhen there is massive surplus\nThis would result in many Flap auctions occurring as the surplus over \nbump\n + \nhump\n is always auctioned off in \nbump\n increments. However, auctions run concurrently, so this would \"flood the keeper market\" and possibly result in too few bids being placed on any auction. This could happen through keepers not bidding on multiple auctions at once, which would result in network congestion because all keepers are trying to bid on all of the auctions. This could also lead to possible keeper collusion (if the capital pool is large enough, they may be more willing to work together to split it evenly at the system's expense).\nSmart Contract Modules - \nPrevious\nSystem Stabilizer Module\nNext\nFlopper - Detailed Documentation\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/system-stabilizer-module/flap-detailed-documentation", "title": "Flapper - Detailed Documentation"}}
{"page_content": "Flopper - Detailed Documentation\nThe Maker Protocol's Debt Auction House\nContract Name:\n flop.sol\nType/Category:\n DSS \u0432\u0410\u0424> System Stabilizer Module\n\u0432\u0410\u041b\nAssociated MCD System Diagram\n\u0432\u0410\u041b\n\u0432\u0410\u041b\nContract Source\n\u0432\u0410\u041b\n\u0432\u0410\u041b\nEtherscan\n\u0432\u0410\u041b\n1. Introduction (Summary)\nSummary:\n Debt Auctions are used to recapitalize the system by auctioning off MKR for a fixed amount of DAI. In this process, bidders compete by offering to accept decreasing amounts of MKR for the DAI they will end up paying.\nFlop Interactions with the Maker Protocol\n2. Contract Details\nFlopper (Glossary)\nflop\n: debt auction (covering debt by inflating MKR and selling for stablecoins)\nlot\n: quantity up for auction / gems for sale (MKR)\nguy\n: high bidder (address)\ngal\n: recipient of auction income / receives dai income (this is the Vow contract)\nttl\n: bid lifetime (Max bid duration / single bid lifetime)\nbeg\n: minimum bid decrease\npad\n: Increase for \nlot\n size during \ntick\n (default to 50%)\ntau\n: maximum auction duration\nend\n: when the auction will finish / max auction duration\nkick\n: start an auction / Put up a new MKR \nbid\n for auction\ndent\n: make a bid, decreasing the lot size (Submit a fixed DAI \nbid\n with decreasing \nlot\n size)\ndeal\n: claim a winning bid / settles a completed auction\nvat\n - the Vat's address\ngem\n- MKR Token (address)\nkicks\n - Total auction count, used to track auction \nid\ns\nlive\n - Cage flag\nwards [usr: address]\n, \nrely\n/\ndeny\n/\nauth\n - Auth mechanisms\nBid\n - State of a specific Auction {\nbid\n, \nlot\n, \nguy\n, \ntic\n, \nend\n}\nbid\n - Bid amount inDAI / DAI paid\ntic\n - Bid expiry\ntick\n - restarts an auction\nParameters Set By Governance\nThe Maker Governance voters determine the debt limit. The Debt auction is triggered when the system has DAI debt above that limit.\nMaker Governance sets the \nVow.dump\n which determines the starting \nlot\n for an auction as well as the \npad\n which determines how much that \nlot\n can increase during \ntick\n.\nThe contracts that are \nauth\n'ed to call \nkick()\n (should only be \nVow\n) and \nfile()\n to change \nbeg\n, \nttl\n, \ntau\n (should only be governance contracts).\nInformational Note:\n The \ncage\n sets the Flop to not be live anymore and the \nyank\n is used during Global Settlement in order to return a bid to the bidder since the \ndent\n and \ndeal\n can no longer be called.\n3. Key Mechanisms & Concepts\nThe Flop Auction process begins with Maker Governance voters determining the system debt limit (\nVow.sump\n). Debt Auctions are then triggered when the system has Dai debt that has passed that specified debt limit.\nIn order to determine whether the system has net debt, the surplus, accrued stability fees, and debt must be reconciled. Any user can do this by sending the \nheal\n transaction to the system contract named \nVow.sol\n. Provided there is sufficient debt (i.e. debt after healing > \nVow.sump\n), any user can send a \nVow.flop\n transaction to trigger a debt auction.\nThe \nFlop\n is a reverse auction, where keepers bid on how little MKR they are willing to accept for the fixed Dai amount they have to pay at auction settlement. The bidders will basically compete with decreasing \nlot\n amounts of MKR for a fixed \nbid\n amount of Dai. Once \nkick\ned, the \nbid\n is set to the flop auction bid size (\nVow.sump\n) and \nlot\n is set to a sufficiently large number (\nVow.dump\n). The auction will end when the latest bid duration (\nttl\n) has passed \nOR\n when the auction duration (\ntau\n) has been reached. The payback process begins when the first bid is placed. The first bid will pay back the system debt and each subsequent bid will pay back the previous (no longer winning) bidder. When the auction is over, the process ends by cleaning up the bid and minting MKR for the winning bidder.\nIf the auction expires without receiving any bids, anyone can restart the auction by calling \ntick(uint auction_id)\n. This will do two things:\n1.\nIt resets \nbids[id].end\n to \nnow + tau\n2.\nIt resets \nbids[id].lot\n to \nbids[id].lot * pad / ONE\nA diagram detailing the interactions a user has with Flopper and the Vow\nBidding Requirements during an auction\nDuring an auction, \nlot\n amounts will decrease by a percentage with each new \ndent\n decreasing the \nlot\n by the \nbeg\n for the same \nbid\n of Dai. For example, the \nbeg\n could be set to 5%, meaning if the current bidder has a \nlot\n of 10 (MKR) for a \nbid\n of 100 (Dai), then the next bid must pass at most a \nlot\n of 9.5 (MKR) for a \nbid\n of 100 (Dai).\nPlacing Bids\nWhen a bid is beaten out by another bidder, the new winner's internal DAI balance is used to refund the previous winning bidder. Once placed, bids \ncannot\n be canceled.\nExample \nbidding flow:\n1.\nVow \nkick\ns a new Flop Auction.\n2.\nBidder 1 makes a bid that decreases the \nlot\n size by \nbeg\n from the initial amount. Bidder 1's DAI balance in the Vat is decreased by \nbid\n and the Vow's DAI balance in the Vat is increased by \nbid\n.\n3.\nBidder 2 makes a bid that decreases Bidder 1's \nlot\n by \nbeg\n. Bidder 2's DAI balance in the Vat is decreased by \nbid\n and Bidder 1's DAI balance in the Vat is increased by \nbid\n (thereby refunding Bidder 1 for their now-losing bid).\n4.\nBidder 1 makes a bid that decreases Bidder 2's \nlot\n by \nbeg\n. Bidder 1's DAI = \nVat.dai[bidder1]\n - \nbid\n; Bidder 2's DAI = \nVat.dai[bidder2]\n + \nbid\n.\n5.\nBidder 2 (and all the other bidders within the auction) decide it is no longer worth it to continue to accept lower \nlot\ns, so they stop bidding. Once the \nBid.tic\n expires, Bidder 1 calls \ndeal\n and new MKR tokens are minted to their address (\nMKR token contract.balances(Bidder1)\n = \nMKR.balances(Bidder1)\n + \nlot\n).\nNote:\n During a Flop auction, the \nbeg\n is actually the minimum decrease amount. In \ndent\n the new bid has to have a \nlot\n * \nbeg\n that is less than or equal to the current \nlot\n size. Since the theory of the Flop auction is that a bidder\u0432\u0410\u0429s offer is to take fewer and fewer MKR tokens (\nlot\n) for the same amount of dai (\nbid\n) then the \nbeg\n is the amount each bid's offer should decrease by.\n4. Gotchas (Potential Source of User Error)\nKeepers\nIn the context of running a keeper (more info \nhere\n) to perform bids within an auction, a primary failure mode would occur when a keeper specifies an unprofitable price for MKR.\nThis failure mode is due to the fact that there is nothing the system can do stop a user from paying significantly more than the fair market value for the token in an auction (this goes for all auction types, \nflip\n, \nflop\n, and \nflap\n).\nThis means, in the case of Flop, that since the Dai amount is fixed for the entire auction, the risk to the keeper is that they would make a \"winning\" bid that pays the bid amount in Dai but does not receive any MKR (\nlot\n == 0). Subsequent executions of this bad strategy would be limited by the amount of Dai (not MKR) in their vat balance.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\n1.\nFlopper\n has the potential to issue an excessively huge amount of MKR and despite the mitigation efforts (the addition of the \ndump\n and \npad\n parameters), if \ndump\n is not set correctly by governance, the huge issuance of MKR could still occur.\n2.\nSee \nSystem Stabilizer Module Documentation\n.\nPrevious\nFlapper - Detailed Documentation\nNext\nVow - Detailed Documentation\nLast modified \n2yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/system-stabilizer-module/flop-detailed-documentation", "title": "Flopper - Detailed Documentation"}}
{"page_content": "Vow - Detailed Documentation\nThe Maker Protocol's Balance Sheet\nContract Name:\n vow.sol\nType/Category:\n DSS \u0432\u0496\u201d> System Stabilizer Module\n\u0432\u0496\u04e2\nAssociated MCD System Diagram\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nContract Source\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\nEtherscan\n\u0432\u0496\u04e2\n1. Introduction (Summary)\nThe \nVow\n contract represents the Maker Protocol's balance sheet. In particular, the \nVow\n acts as the recipient of both the system surplus and system debt. Its main functions are to cover deficits via debt (\nFlop\n) auctions and discharge surpluses via surplus (\nFlap\n) auctions.\nVow.sol Contract Interaction\nPictured:\nInter-contract calls necessary for the module function\nNot pictured:\ncage\n calls from \nVow\n to \nFlap\n and \nFlop\nAuction and user auction interactions\nGovernance calls / interactions\n2. Contract Details\nVow (Glossary)\nsin\n: the system debt queue.\nSin\n: the total amount of debt in the queue.\nAsh\n: the total amount of on-auction debt.\nwait\n: length of the debt queue\nsump\n: debt auction bid size, i.e. the fixed debt quantity to be covered by any one debt auction\ndump\n: debt auction lot size, i.e. the starting amount of MKR offered to cover the \nlot\n/\nsump\nbump\n: surplus auction lot size, i.e. the fixed surplus quantity to be sold by any one surplus auction\nhump\n: surplus buffer, must be exceeded before surplus auctions are possible\nOther terms included in the above diagram:\nmove\n: transfers stablecoin between users.\nkick\n: starts an auction.\nLiquidations Manager\nFess\n - Pushes bad debt to the auctions queue (add debt to the queue).\nFlog\n - Release queued debt for auction (realize debt from the queue).\nHeal\n - \nvow\n calls \nheal\n on the \nvat\n contract to cancel out surplus and debt. (Optimize debt buffer (\nvat.heal\n)).\nKiss\n - Cancels out surplus and on-auction debt. Release on-auction debt and Heal (\nvat.heal\n).\nFlap\n - Trigger a surplus auction (\nflapper.kick\n)\nFlop\n - Trigger a deficit auction (\nflopper.kick\n)\nAuthorization\nThe \nvow\n contract calls \nkick\n on \nflop\n and \nflap\n to start an auction (debt and surplus auctions, respectively).\nFlopper\n (Debt auctions) - If the deficit is not covered in the forward auction portion of the \nflip\n auction, then debt auctions are used for getting rid of the Vow\u0432\u0496\u04b7s \ndebt\n by auctioning off MKR for a fixed amount of Dai. Once the auction ends, the \nFlop\nper will then send the received Dai to the \nVow\n in order to cancel its debt. Lastly, the \nFlop\nper will mint the MKR for the winning bidder.\nFlapper\n (Surplus auctions) - These are used for getting rid of the \nVow\n\u0432\u0496\u04b7s \nsurplus\n by auctioning off a fixed amount of internal Dai for MKR. Once the auction ends, the \nFlap\nper burns the winning MKR bid and sends internal Dai to the winning bidder.\nSystem \nData\nSystem config\nVow.wait\n - Flop delay \nVow.sump\n - Flop fixed bid size\nVow.dump\n - Flop starting lot size \nVow.bump\n - Flap fixed lot size \nVow.hump\n- Surplus buffer\nDebt (\nSIN) Queue\nWhen a Vault is liquidated (\nbite\n - \ndocumentation\n), the seized debt is put in a queue for an auction in a \nVow\n (labeled as \nsin[timestamp]\n- the system debt unit). This occurs at the block timestamp of the \nbite\n action. It can be released for auction via \nflog\n (\nflog\n releases queued debt for the auction) once the allotted \nVow.wait\n (the flop delay) time has expired.\nThe \nSin\n is stored when it's in the debt queue, but the debt available to auction isn't explicitly stored anywhere. This is because the debt that is eligible for auction is derived by comparing the \nSin\n (i.e. debt on the holding queue) with the dai balance of the \nVow\n as recorded in \nVat.dai[Vow]\n. For instance, if \nVat.sin[Vow]\n is greater than the sum of \nVow.Sin\n and the \nAsh\n (debt currently on auction), then the difference may be eligible for a \nFlop\n auction.\nNotes:\nIn the case of when a \ncat.bite\n / \nvow.fess\n is executed, the debt \ntab\n is added to \nsin[now]\n and \nSin\n, which blocks that \ntab\n amount to be sent to the \nflop\n auction and all of the DAI is recovered with a \nflip\n auction. In theory, unblocking the \ntab\n amount in the \nSin\n shouldn't be necessary, but in practice it actually is. If this debt is not unblocked, then when we have a real need to send a \nflop\n auction, we might have a big \nSin\n that blocks it. To summarize, this means that each registry of \nsin[era]\n that has an amount > 0 should be \nflog\n'ed before kicking a \nflop\n auction (this is because in order to kick the whole thing, you need every register to be 0, otherwise, it would be blocking debt).\nEach \nsin[era]\n isn\u0432\u0496\u04b7t required to be a single \nbite\n, it will group all the \nbite\n\u0432\u0496\u04b7s that are in the same Ethereum block together.\nThe \nauction-keeper\n will \nflog\n every \nera\n with positive \nSin\n if the \nwoe\n+ \nSin\n >= \nsump\n, where \nwoe\n = \nvat.sin[vow]\n - \nvow.Sin\n - \nvow.Ash\n.\n Where the components within \nvat.sin(vow)\n - \nvow.Sin\n - \nvow.Ash\n are defined as:\nvat.sin(vow)\n- total bad debt\nvow.Sin\n - debt blocked\nvow.Ash\n - debt in auctions\nVow.sin\n records individual portions of debt (marked with a timestamp). These are not directly auctioned off, but cleared when \nflog\n is called.\nIf the \nSin\n is not covered by holding a \nflip\n auction within the designated wait time (\ntau\n), the \nSin\n \u0432\u0496\u04a3matures\u0432\u0496\u049b and gets marked as bad debt to the \nVow\n. This bad debt can be covered through a debt auction (\nflop\n) when it exceeds a minimum value (the \nlot\n size). In short, the time between the debt being added to the \nsin[]\n queue and becoming \"mature\" (when it \nflog\ns off the queue and is eligible for \nFlop\n auction) is the amount of time that \nFlip\n auction has to clear that debt. This is due to the fact that when a \nFlip\n auction receives DAI, it decreases the \nVow\n's DAI balance in the \nVat\n.\nNote:\n In this case, there is a risk that a circumstance can occur where the \nVow.wait\n is different than the \nFlip.tau\n. The main risk being related to \nwait\n < \ntau\n, which would result in debt auctions running before the associated seized-collateral auctions could complete.\nOverall \nSin\n can affect the system in the following way:\n1.\nThere can be separate \nVow\ns each with their own \nsin\ns\n2.\nIn the case of an upgrade, if we remove a \nVow\n that has \nsin\n, this can create untracked bad debt in the system.\nAccounting\nVow.Sin\n - This calculates the total queued debt in the system. \nVow.Ash\n- This calculates the total on-auction debt.\n3. Key Mechanisms & Concepts\nIt is important to note that the Maker Protocol will deviate from its equilibrium. This occurs when it receives system debt and system surplus through the collateral auctions and Vault stability fee accumulation. The \nVow\n contract contains the logic to trigger both the debt (\nflop\n) and surplus (\nflap\n) auctions, which work to correct the system\u0432\u0496\u04b7s monetary imbalances.\nSummary\nSystem Debt:\n In the case where Vaults are bitten (liquidated), their debt is taken on by the \nVow\n contract as a \nSin\n (the system debt unit). The \nSin\n amount is then placed in the \nSin\n queue. \nNote:\n When the \nSin\n is not covered by a \nflip\n auction (within the dedicated \nwait\n time, the \nSin\n is considered to have bad debt to the \nVow\n. This bad debt is then covered through a debt auction (\nflop\n) when it exceeds a minimum value (the \nlot\n size).\nSystem Surplus:\n Occurs from stability fee accumulation, resulting in additional internal Dai in the \nVow\n. This surplus is then discharged through a surplus auction (\nflap\n).\n4. Gotchas (Potential source of user error)\nWhen the \nVow\n is upgraded, there are multiple references to it that must be updated at the same time (\nEnd\n, \nJug\n, \nPot\n).\nThe \nVow\n is the only user with a non-zero \nSin\n balance (not a \nvat\n invariant as there can be multiple \nVow\ns).\nIlk storage is split across the \nVat\n, \nJug\n, \nPot\n and \nVow\n modules. The \ncat\n also stores the liquidation penalty and maximum auction size.\nA portion of the Stability Fee is allocated for the Dai Savings Rate (DSR) by increasing the amount of \nSin\n in the \nVow\n at every \nPot.drip( )\n call.\nSetting an incorrect value for \nvow\n can cause the surplus to be lost or stolen.\n5. Failure Modes (Bounds on Operating Conditions & External Risk Factors)\nVault Liquidation\nA failure mode could arise when no actors call \nkiss\n, \nflog\n or \nheal\n to reconcile/queue the debt.\nAuctions\nA failure mode could arise if a user does not call \nflap\nor \nflop\n to kick off auctions.\nVow.wait\n, when set too high (\nwait\n is too long), the \nflop\n auctions can no longer occur. This provides a risk of undercollateralization.\nVow.wait\n, when set too low, can cause too many \nflop\n auctions, while preventing \nflap\n auctions from occurring.\nVow.bump\n, when set too high, can result in no \nflap\n auctions being possible. Thus, if no \nflap\n auction takes place, there will be no MKR bidding as part of that process and, accordingly, no automated MKR burn as a result of a successful auction.\nVow.bump\n, when set too low, results in \nflap\n auctions not being profitable for participants (\nlot\n size is worth less than gas cost). Thus, no MKR will be bid during a \nflap\n auction and, as a result, there will be no automated MKR burn.\nVow.sump\n, when set too high, no \nflop\n auctions are possible. This results in the system not being able to recover from an undercollateralized state.\nVow.sump\n, when set too low, \nflop\n auctions are not profitable for participants (where the \nlot\n size is worth less than gas cost). This results in MKR inflation due to automated MKR minting.\nVow.dump\n, when set too high, \nflop\n auctions risk not being able to close or mint a large amount of MKR, creating a risk of MKR dilution and the possibility of a governance attack.\nVow.dump\n, when set too low, \nflop\n auctions have to be \nkick\ned many times before they will be interesting to keepers.\nVow.hump\n, when set too high, the \nflap\n auctions would never occur. If a \nflap\n auction does not occur, there is no sale of surplus, and thus, no burning of bid MKR.\nVow.hump\n, if set too low, can cause surplus to be auctioned off via \nflap\n auctions before it is used to cancel \nsin\n from liquidations, necessitating \nflop\n auctions and making the system run inefficiently.\nPrevious\nFlopper - Detailed Documentation\nNext\n - Smart Contract Modules\nOracle Module\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/smart-contract-modules/system-stabilizer-module/vow-detailed-documentation", "title": "Vow - Detailed Documentation"}}
{"page_content": "Adding a new service\nSummary\nYou can take advantage of the pluggable architecture of this library by choosing different implementations for services, and/or adding new service roles altogether. A service is just a Javascript class that inherits from either \nPublicService\n, \nPrivateService\n, or \nLocalService\n, and contains public method(s).\nIt can depend on other services through our built-in \ndependency injection framework\n, and can also be configured through the Maker config file / config options.\nSteps to add a new service\nThe information below is written for developers who want to add to dai.js, but you can also add services through the use of \nplugins\n.\nHere are the steps to add a new service called ExampleService:\n(1) In the src directory, create an ExampleService.js file in one of the subdirectories.\n(2) In src/config/DefaultServiceProvider.js, import ExampleService.js and add it to the _services array\n(3) Create a class called ExampleService in ExampleService.js\n(4) The service must extend one of:\nPrivateService - requires both a network connection and authentication\nPublicService - requires just a network connection\nLocalService - requires neither\nSee the Service Lifecycle section below for more info\n(5) In the constructor, call the parent class's constructor with the following arguments:\nThe name of the service. This is how the service can be referenced by other services\nAn array of the names of services to depend on\n(6) Add the necessary public methods\n//example code in ExampleService.js for steps 3-6\nimport\n PublicService \nfrom\n \n'../core/PublicService'\n;\n\u0432\u0496\u04e2\nexport\n \ndefault\n \nclass\n \nExampleService\n \nextends\n \nPublicService\n \n{\n \nconstructor\n \n(\nname\n=\n'example'\n)\n \n{\n \nsuper\n(\nname\n,\n \n[\n'log'\n]);\n \n}\n\u0432\u0496\u04e2\n \ntest\n(){\n \nthis\n.\nget\n(\n'log'\n).\ninfo\n(\n'test'\n);\n \n}\n(7) If your service will be used to replace a default service (the full list of default service roles can be found in src/config/ConfigFactory), then skip this step. Otherwise, you'll need to add your new service role (e.g. \"example\") to the ServiceRoles array in src/config/ConfigFactory.\n(8) Create a corresponding ExampleService.spec.js file in the test directory. Write a test in the test file that creates a Maker object using your service.\n//example code in ExampleService.spec.js for step 8\nimport\n Maker \nfrom\n \n'../../src/index'\n;\n\u0432\u0496\u04e2\n//step 8: a new service role ('example') is used\ntest\n(\n'test 1'\n,\n \nasync\n \n()\n \n=>\n \n{\n \nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\nexample\n:\n \n\"ExampleService\"\n});\n \nconst\n exampleService \n=\n customMaker\n.\nservice\n(\n'example'\n);\n  exampleService\n.\ntest\n();\n \n//logs \"test\"\n});\n\u0432\u0496\u04e2\n//step 8: a custom service replaces a default service (Web3)\ntest\n(\n'test 2'\n,\n \nasync\n \n()\n \n=>\n \n{\n \nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\nweb3\n:\n \n\"MyCustomWeb3Service\"\n});\n \nconst\n mycustomWeb3Service \n=\n maker\n.\nservice\n(\n'web3'\n);\n});\n(9) (Optional) Implement the relevant service lifecycle functions (initialize(), connect(), and authenticate()). See the Service Lifecycle section below for more info\n(10) (Optional) Allow for configuration. Service-specific settings can be passed into a service by the Maker config file or config options. These service-specific settings can then be accessed from inside a service as the parameter passed into the initialize function (see the Service Lifecycle section below)\n//step 10: in ExampleService.spec.js\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\n \nexample\n:\n \n[\n\"ExampleService\"\n,\n \n{\n \nexampleSetting\n:\n \n\"this is a configuration setting\"\n \n}]\n});\n\u0432\u0496\u04e2\n//step 10: accessing configuration settings in ExampleService.js\ninitialize\n(\nsettings\n)\n \n{\n \nif\n(\nsettings\n.\nexampleSetting\n){\n \nthis\n.\nget\n(\n'log'\n).\ninfo\n(\nsettings\n.\nexampleSetting\n);\n \n}\n}\nService Lifecycle\nThe three kinds of services mentioned in step 4 above follow the following state machine diagrams in the picture below.\nTo specify what initializing, connecting and authenticating entails, implement the initialize(), connect(), and authenticate() functions in the service itself. This will be called while the service's manager brings the service to the corresponding state.\n//example initialize() function in ExampleService.js\n \ninitialize\n(\nsettings\n)\n \n{\n \nthis\n.\nget\n(\n'log'\n).\ninfo\n(\n'ExampleService is initializing...'\n);\n \nthis\n.\n_setSettings\n(\nsettings\n);\n \n}\nA service will not finish initializing/connecting/authenticating until all of its dependent services have completed the same state (if applicable - for example a LocalService is considered authenticated/connected in addition to initialized, if it has finished initializing). The example code here shows how to wait for the service to be in a certain state.\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n(\n'http'\n,\n \n{\nexample\n:\n \n\"ExampleService\"\n});\nconst\n exampleService \n=\n customMaker\n.\nservice\n(\n'example'\n);\n\u0432\u0496\u04e2\n//wait for example service and its dependencies to initialize\nawait\n exampleService\n.\nmanager\n().\ninitialize\n();\n\u0432\u0496\u04e2\n//wait for example service and its dependencies to connect\nawait\n exampleService\n.\nmanager\n().\nconnect\n();\n\u0432\u0496\u04e2\n//wait for example service and its dependencies to authenticate\nawait\n exampleService\n.\nmanager\n().\nauthenticate\n();\n\u0432\u0496\u04e2\n//can also use callback syntax\nexampleService\n.\nmanager\n().\nonConnected\n(()\n=>\n{\n \n/*executed after connected*/\n});\n\u0432\u0496\u04e2\n//wait for all services used by the maker object to authenticate\nmaker\n.\nauthenticate\n();\nAdding Custom Events\nOne way to add an event is to \u0432\u0496\u04a3register\u0432\u0496\u049b a function that gets called on each new block, using the event service's registerPollEvents() function. For example, here is some code from the price service. this.getEthPrice() will be called on each new block, and if the state has changed from the last call, a price/ETH_USD event will be emitted with the payload { price: [new_price] }.\nAnother way to an add an event is to manually emit an event using the event service's emit function. For example, when the Web3Service initializes, it emits an event that contains info about the provider.\nNote that calling registerPollEvents and emit() directly on the event service like in the previous two examples will register events on the \"default\" event emitter instance. However, you can create a new event emitter instance for your new service. For example, the CDP object defines it's own event emitter, as can be seen here, by calling the event service's buildEmitter() function.\n//in PriceService.js\nthis\n.\nget\n(\n'event'\n).\nregisterPollEvents\n({\n \n'price/ETH_USD'\n:\n \n{\n \nprice\n:\n \n()\n \n=>\n \nthis\n.\ngetEthPrice\n()\n \n}\n \n});\n\u0432\u0496\u04e2\n//in Web3Service.js\nthis\n.\nget\n(\n'event'\n).\nemit\n(\n'web3/INITIALIZED'\n,\n \n{\n \nprovider\n:\n \n{\n \n...\nsettings\n.\nprovider \n}\n});\n\u0432\u0496\u04e2\n//in the constructor in the Cdp.js\nthis\n.\n_emitterInstance \n=\n \nthis\n.\n_cdpService\n.\nget\n(\n'event'\n).\nbuildEmitter\n();\nthis\n.\non \n=\n \nthis\n.\n_emitterInstance\n.\non\n;\nthis\n.\n_emitterInstance\n.\nregisterPollEvents\n({\n \nCOLLATERAL\n:\n \n{\n \nUSD\n:\n \n()\n \n=>\n \nthis\n.\ngetCollateralValueInUSD\n(),\n \nETH\n:\n \n()\n \n=>\n \nthis\n.\ngetCollateralValueInEth\n()\n \n},\n \nDEBT\n:\n \n{\n \ndai\n:\n \n()\n \n=>\n \nthis\n.\ngetDebtValueInDai\n()\n \n}\n});\nPrevious\nUsing multiple accounts\nNext\nSingle-Collateral Sai\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration/adding-a-new-service", "title": "Adding a new service"}}
{"page_content": "Events\nSummary\nThe event pipeline allows developers to easily create real-time applications by letting them listen for important state changes and lifecycle events.\nWildcards\nAn event name passed to any event emitter method can contain a wildcard (the \n*\ncharacter). A wildcard may appear as \nfoo/*\n, \nfoo/bar/*\n, or simply \n*\n.\n*\n matches one sub-level.\ne.g. \nprice/*\n will trigger on both \nprice/USD_ETH\n and \nprice/MKR_USD\n but not \nprice/MKR_USD/foo\n.\n**\n matches all sub-levels.\ne.g. \nprice/**\n will trigger on \nprice/USD_ETH\n, \nprice/MKR_USD\n, and \nprice/MKR_USD/foo\n.\nEvent Object\nTriggered events will receive the object shown on the right.\n<event_type>\n - the name of the event\n<event_payload>\n - the new state data sent with the event\n<event_sequence_number>\n - a sequentially increasing index\n<latest_block_when_emitted>\n - the current block at the time of the emit\n{\n \ntype\n:\n \n<\nevent_type\n>\n,\n \npayload\n:\n \n<\nevent_payload\n>\n,\n \n/* if applicable */\n \nindex\n:\n \n<\nevent_sequence_number\n>\n,\n \nblock\n:\n \n<\nlatest_block_when_emitted\n>\n}\nMaker Object\nPrice\nEvent Name\nPayload\nprice/ETH_USD\n{ price }\nprice/MKR_USD\n{ price }\nprice/WETH_PETH\n{ ratio }\nmaker\n.\non\n(\n'price/ETH_USD'\n,\n \neventObj\n \n=>\n \n{\n \nconst\n \n{\n price \n}\n \n=\n eventObj\n.\npayload\n;\n    console\n.\nlog\n(\n'ETH price changed to'\n,\n price\n);\n})\nWeb3\nEvent Name\nPayload\nweb3/INITIALIZED\n{ provider: { type, url } }\nweb3/CONNECTED\n{ api, network, node }\nweb3/AUTHENTICATED\n{ account }\nweb3/DEAUTHENTICATED\n{ }\nweb3/DISCONNECTED\n{ }\nmaker\n.\non\n(\n'web3/AUTHENTICATED'\n,\n \neventObj\n \n=>\n \n{\n \nconst\n \n{\n account \n}\n \n=\n eventObj\n.\npayload\n;\n    console\n.\nlog\n(\n'web3 authenticated with account'\n,\n account\n);\n})\nCDP Object\nEvent Name\nPayload\nCOLLATERAL\n{ USD, ETH }\nDEBT\n{ dai }\ncdp\n.\non\n(\n'DEBT'\n,\n \neventObj\n \n=>\n \n{\n \nconst\n \n{\n dai \n}\n \n=\n eventObj\n.\npayload\n;\n    console\n.\nlog\n(\n'Your cdp now has a dai debt of'\n,\n dai\n);\n})\nPrevious\nDSProxy\nNext\nUsing multiple accounts\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration/events", "title": "Events"}}
{"page_content": "Transaction manager\nThe \ntransactionManager\n service is used to track a transaction's status as it propagates through the blockchain.\nMethods in Dai.js that start transactions are asynchronous, so they return promises. These promises can be passed as arguments to the transaction manager to set up callbacks when transactions change their status to \npending\n, \nmined\n, \nconfirmed\n or \nerror\n.\nconst\n txMgr \n=\n maker\n.\nservice\n(\n'transactionManager'\n);\n// instance of transactionManager\nconst\n open \n=\n maker\n.\nservice\n(\n'cdp'\n).\nopenCdp\n();\n// open is a promise--note the absence of `await`\nPass the promise to \ntransactionManager.listen\n with callbacks, as shown below.\ntxMgr\n.\nlisten\n(\nopen\n,\n \n{\n \npending\n:\n \ntx\n \n=>\n \n{\n \n// do something when tx is pending\n \n},\n \nmined\n:\n \ntx\n \n=>\n \n{\n \n// do something when tx is mined\n \n},\n \nconfirmed\n:\n \ntx\n \n=>\n \n{\n \n// do something when tx is confirmed       \n \n},\n \nerror\n:\n \ntx\n \n=>\n \n{\n \n// do someting when tx fails\n \n}\n});\n\u200b\nawait\n txMgr\n.\nconfirm\n(\nopen\n);\n \n// 'confirmed' callback will fire after 5 blocks\nNote that the \nconfirmed\n event will not fire unless \ntransactionManager.confirm\n is called. This async function waits a number of blocks (default 5) after the transaction has been mined to resolve. To change this globally, set the \nconfirmedBlockCount\n attribute in Maker \noptions\n. To change it for just one call, pass the number of blocks to wait as the second argument:\nawait\n txMgr\n.\nconfirm\n(\nopen\n,\n \n3\n);\nTransaction Metadata\nThere are functions such as \nlockEth()\n which are composed of several internal transactions. These can be more accurately tracked by accessing \ntx.metadata\nin the callback which contains both the \ncontract\n and the \nmethod\n the internal transactions were created from.\nTransaction Object Methods\nA \nTransactionObject\n also has a few methods to provide further details on the transaction:\nhash\n : transaction hash\nfees()\n : amount of ether spent on gas\ntimeStamp()\n : timestamp of when transaction was mined\ntimeStampSubmitted()\n : timestamp of when transaction was submitted to the network\nconst\n lock \n=\n cdp\n.\nlockEth\n(\n1\n);\ntxMgr\n.\nlisten\n(\nlock\n,\n \n{\n \npending\n:\n \ntx\n \n=>\n \n{\n \nconst\n \n{\ncontract\n,\n method\n}\n \n=\n tx\n.\nmetadata\n;\n \nif\n(\ncontract \n===\n \n'WETH'\n \n&&\n method \n===\n \n'deposit'\n)\n \n{\n      console\n.\nlog\n(\ntx\n.\nhash\n);\n \n// print hash for WETH.deposit\n \n}\n \n}\n})\nPrevious\nAdvanced\nNext\nDSProxy\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration/transactions", "title": "Transaction manager"}}
{"page_content": "DSProxy\nconst\n service \n=\n maker\n.\nservice\n(\n'proxy'\n);\nSummary\nThe \nDSProxyService\n includes all the functionality necessary for interacting with both types of proxy contracts used in Maker products: \nprofile proxies\n and \nforwarding proxies\n.\nForwarding proxies are simple contracts that aggregate function calls in the body of a single method. These are used in the \nCDP Portal\n and \nOasis Direct\n in order to allow users to execute multiple transactions atomically, which is both safer and more user-friendly than implementing several steps as discrete transactions.\n// Forwarding proxy\n\u0442\u0410\u041b\nfunction lockAndDraw(address tub_, bytes32 cup, uint wad) public payable {\n  lock(tub_, cup);\n  draw(tub_, cup, wad);\n}\nForwarding proxies are meant to be as simple as possible, so they lack some features that could be important if they are to be used as interfaces for more complex smart contract logic. This problem can be solved by using profile proxies (i.e. copies of \nDSProxy\n) to execute the functionality defined in the forwarding proxies.\nThe first time an account is used to interact with any Maker application, the user will be prompted to deploy a profile proxy. This copy of DSProxy can be used in any product, including dai.js, by way of a universal \nproxy registry\n. Then, the calldata from any function in the forwarding proxy can be passed to DSProxy's \nexecute()\nmethod, which runs the provided code in the context of the profile proxy.\n// Calling the forwarding proxy with dai.js\n\u0442\u0410\u041b\nfunction\n \nlockAndDraw\n(\ntubContractAddress\n,\n cdpId\n,\n daiAmount\n,\n ethAmount\n)\n \n{\n \nconst\n saiProxy \n=\n maker\n.\nservice\n(\n'smartContract'\n).\ngetContractByName\n(\n'SAI_PROXY'\n);\n\u0442\u0410\u041b\n \nreturn\n saiProxy\n.\nlockAndDraw\n(\n    tubContractAddress\n,\n    cdpId\n,\n    daiAmount\n,\n \n{\n \nvalue\n:\n ethAmount\n,\n \ndsProxy\n:\n \ntrue\n \n}\n \n);\n}\nThis makes it possible for users' token allowances to persist from one Maker application to another, and it allows users to \nrecover any funds\n mistakenly sent to the proxy's address. Many of the functions in \nDSProxyService\n will only be relevant to \npower users\n. All that is strictly required to automatically generate a function's calldata and find the correct profile proxy is the inclusion of \n{ dsProxy: true }\n in the options object for any transaction \u0442\u0410\u0424 provided the user has already deployed a profile proxy. If that's not certain, it may also be necessary to query the registry to determine if a user already owns a proxy, and to \nbuild\n one if they do not.\ncurrentProxy()\nParams:\n None\nReturns:\n promise (resolves to address \nor\n \nnull\n)\nIf the \ncurrentAccount\n (according the \nWeb3Service\n) has already deployed a DSProxy, \ncurrentProxy()\n returns its address. If not, it returns \nnull\n. It will update automatically in the event that the active account is changed. This function should be used to check whether a user has a proxy before attempting to build one.\nasync\n \nfunction\n \ngetProxy\n()\n \n{\n \nreturn\n maker\n.\nservice\n(\n'proxy'\n).\ncurrentProxy\n();\n}\nbuild()\nParams:\n None\nReturns:\n \nTransactionObject\nbuild\n will deploy a copy of DSProxy owned by the current account. \nThis transaction will revert if the current account already owns a profile proxy.\n By default, \nbuild()\n returns after the transaction is mined.\nasync\n \nfunction\n \nbuildProxy\n()\n \n{\n \nconst\n proxyService \n=\n maker\n.\nservice\n(\n'proxy'\n);\n \nif\n \n(\n!\nproxyService\n.\ncurrentProxy\n())\n \n{\n \nreturn\n proxyService\n.\nbuild\n();\n \n}\n}\nensureProxy()\nThis convenience function will either return an existing proxy or create one.\nconst\n proxyAddress \n=\n \nawait\n maker\n.\nservice\n(\n'proxy'\n).\nensureProxy\n();\ngetProxyAddress()\nParams:\n Address (optional)\nReturns:\n promise (resolves to contract address)\ngetProxyAddress\n will query the proxy registry for the profile proxy address associated with a given account. If no address is provided as a parameter, the function will return the address of the proxy owned by the \ncurrentAccount\n.\nconst\n proxy \n=\n \nawait\n maker\n.\nservice\n(\n'proxy'\n).\ngetProxyAddress\n(\n'0x...'\n);\ngetOwner()\nParams:\n Address\nReturns:\n promise (resolves to address)\ngetOwner\n will query the proxy registry for the owner of a provided instance of DSProxy.\nconst\n owner \n=\n \nawait\n maker\n.\nservice\n(\n'proxy'\n).\ngetOwner\n(\n'0x...'\n);\nsetOwner()\nParams:\n Address of new owner, DSProxy address (optional)\nReturns:\n \nTransactionObject\nsetOwner\n can be used to give a profile proxy to a new owner. The address of the recipient account must be specified, but the DSProxy address will default to \ncurrentProxy\n if the second parameter is excluded.\nawait\n maker\n.\nservice\n(\n'proxy'\n).\nsetOwner\n(\nnewOwner\n,\n proxyAddress\n);\nPrevious\nTransaction manager\nNext\nEvents\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration/using-ds-proxy", "title": "DSProxy"}}
{"page_content": "Using multiple accounts\nSummary\nDai.js supports the use of multiple accounts (i.e. private keys) with a single Maker instance. Accounts can be specified in the  options for \nMaker.create\n or with the \naddAccount\n method.\nCall \nuseAccount\n to switch to using an account by its name, or \nuseAccountWithAddress\n to switch to using an account by its address, and subsequent calls will use that account as the transaction signer.\nWhen the Maker instance is first created, it will use the account named \ndefault\n if it exists, or the first account in the list otherwise.\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n({\n \nurl\n:\n \n'http://localhost:2000'\n,\n \naccounts\n:\n \n{\n \nother\n:\n \n{\ntype\n:\n privateKey\n,\n \nkey\n:\n someOtherKey\n},\n \ndefault\n:\n \n{\ntype\n:\n privateKey\n,\n \nkey\n:\n myKey\n}\n \n}\n});\n\u0432\u0496\u04e2\nawait\n maker\n.\naddAccount\n(\n'yetAnother'\n,\n \n{\ntype\n:\n privateKey\n,\n \nkey\n:\n thirdKey\n});\n\u0432\u0496\u04e2\nconst\n cdp1 \n=\n \nawait\n maker\n.\nopenCdp\n();\n \n// owned by \"default\"\n\u0432\u0496\u04e2\nmaker\n.\nuseAccount\n(\n'other'\n);\nconst\n cdp2 \n=\n \nawait\n maker\n.\nopenCdp\n();\n \n// owned by \"other\"\n\u0432\u0496\u04e2\nmaker\n.\nuseAccount\n(\n'yetAnother'\n);\nconst\n cdp3 \n=\n \nawait\n maker\n.\nopenCdp\n();\n \n// owned by \"yetAnother\"\n\u0432\u0496\u04e2\nawait\n maker\n.\naddAccount\n({\ntype\n:\n privateKey\n,\n \nkey\n:\n fourthAccount\n.\nkey\n});\n \n// the name argument is optional\nmaker\n.\nuseAccountWithAddress\n(\nfourthAccount\n.\naddress\n);\nconst\n cdp4 \n=\n \nawait\n maker\n.\nopenCdp\n();\n \n//owned by the fourth account\nYou can check the current account with \ncurrentAccount\n and \ncurrentAddress\n:\n>\n maker\n.\ncurrentAccount\n()\n{\n \nname\n:\n \n'other'\n,\n \ntype\n:\n \n'privateKey'\n,\n \naddress\n:\n \n'0xfff...'\n \n}\n>\n maker\n.\ncurrentAddress\n()\n'0xfff...'\nAccount types\nIn addition to the \nprivateKey\n account type, there are two other built-in types:\nprovider\n: Get the first account from the provider (e.g. the value from \ngetAccounts\n).\nbrowser\n: Get the first account from the provider in the browser (e.g. MetaMask), even if the Maker instance is configured to use a different provider.\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n({\n \nurl\n:\n \n'http://localhost:2000'\n,\n \naccounts\n:\n \n{\n \n// this will be the first account from the provider at\n \n// localhost:2000\n \nfirst\n:\n \n{\ntype\n:\n \n'provider'\n},\n\u0432\u0496\u04e2\n \n// this will be the current account in MetaMask, and it\n \n// will send its transactions through MetaMask\n \nsecond\n:\n \n{\ntype\n:\n \n'browser'\n},\n\u0432\u0496\u04e2\n \n// this account will send its transactions through the\n \n// provider at localhost:2000\n \nthird\n:\n \n{\ntype\n:\n \n'privateKey'\n,\n \nkey\n:\n myPrivateKey\n}\n \n}\n})\nHardware wallets\nPlugins can add additional account types. There are currently two such plugins for hardware wallet support:\n\u0432\u0496\u04e2\ndai-plugin-trezor-web\n\u0432\u0496\u04e2\n\u0432\u0496\u04e2\ndai-plugin-ledger-web\n\u0432\u0496\u04e2\nimport\n TrezorPlugin \nfrom\n \n'@makerdao/dai-plugin-trezor-web'\n;\nimport\n LedgerPlugin \nfrom\n \n'@makerdao/dai-plugin-ledger-web'\n;\n\u0432\u0496\u04e2\nconst\n maker \n=\n \nawait\n Maker\n.\ncreate\n({\n \nplugins\n:\n \n[\n    TrezorPlugin\n,\n    LedgerPlugin\n,\n \n],\n \naccounts\n:\n \n{\n \n// default derivation path is \"44'/60'/0'/0/0\"\n \nmyTrezor\n:\n \n{\ntype\n:\n \n'trezor'\n,\n \npath\n:\n derivationPath1\n},\n \nmyLedger\n:\n \n{\ntype\n:\n \n'ledger'\n,\n \npath\n:\n derivationPath2\n}\n \n}\n});\nDemo\nInstall the \nmultiple accounts demo app\n to see this functionality in action.\nPrevious\nEvents\nNext\nAdding a new service\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/advanced-configuration/using-multiple-accounts", "title": "Using multiple accounts"}}
{"page_content": "Plugins\nDai.js supports plugins, which allow a developer to add functionality (hardware wallet support, exchange support, etc.) for specific needs without increasing the size and dependency list of the core library.\nAvailable Plugins\n1.\n\u200b\nTrezor Plugin\n for using Trezor with dai.js in a browser environment.\n2.\n\u200b\nLedger Plugin\n for using Ledger in a browser environment.\n3.\n\u200b\nGovernance Plugin\n for working with the governance contracts.\n4.\n\u200b\neth2dai Instant Plugin\n for atomic trading on maker OTC (Oasis).\n5.\n\u200b\nMaker OTC Plugin\n for interacting with the maker OTC contract (Oasis).\n6.\n\u200b\nMCD Plugin\n for interacting with the multi-collateral dai contracts.\n7.\n\u200b\nSCD Plugin\n for interacting with the single-collateral dai contracts.\nBuilding your own plugin\nCheck out the \nDai Plugin Template\n.\nPrevious\nConfiguration\nNext\nVault manager\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/maker/plugins", "title": "Plugins"}}
{"page_content": "Collateralized Debt Position\n\u0440\u04b9\u2019\u040eNote that this page applies only to Single-Collateral Sai.\nAfter \nopening a new CDP\n or \ngetting an existing one\n, you can use the returned \ncdp\n object to call functions on it.\nProperties\nid\nThis is the ID of the CDP object. You can pass this ID to \nMaker.getCdp\n.\nMethods\ngetDebtValue\nParams:\n \ncurrency unit\n (optional)\nReturns:\n promise (resolves to the amount of outstanding debt)\ncdp.getDebtValue()\n returns the amount of debt that has been borrowed against the collateral in the CDP. By default it returns the amount of Dai as a \ncurrency unit\n, but can return the equivalent in USD if the first argument is \nMaker.USD\n.\nconst\n daiDebt \n=\n \nawait\n cdp\n.\ngetDebtValue\n();\nconst\n usdDebt \n=\n \nawait\n cdp\n.\ngetDebtValue\n(\nMaker\n.\nUSD\n);\ngetGovernanceFee\nParams:\n \ncurrency unit\n (optional)\nReturns:\n promise (resolves to the value of the accrued governance fee in USD)\ncdp.getGovernanceFee()\n returns the value of the accrued governance fee. By default it returns the amount of MKR as a \ncurrency unit\n, but can return the equivalent in USD if the first argument is \nMaker.USD\n.\nNote:\n this is often referred to as the \nStability Fee\n, even though technically the \nStability Fee\n is the fee that is paid in Dai, and the \nGovernance Fee\n is the fee that is paid in MKR. But since fees are only paid in MKR in Single-Collateral Dai, and only paid in Dai in Multi-Collateral Dai, the fee in Single-Collateral Dai is often referred to as the \nStability Fee\n to be consistent with the term that will be used in Multi-Collateral Dai and to avoid unduly confusing regular users.\nconst\n mkrFee \n=\n \nawait\n cdp\n.\ngetGovernanceFee\n();\nconst\n usdFee \n=\n \nawait\n cdp\n.\ngetGovernanceFee\n(\nMaker\n.\nUSD\n);\ngetCollateralizationRatio\nParams:\n none\nReturns:\n promise (resolves to the collateralization ratio)\ncdp.getCollateralizationRatio()\n returns the USD value of the collateral in the CDP divided by the USD value of the Dai debt for the CDP, e.g. \n2.5\n.\nconst\n ratio \n=\n \nawait\n cdp\n.\ngetCollateralizationRatio\n();\ngetLiquidationPrice\nParams:\n none\nReturns:\n promise (resolves to the liquidation price)\ncdp.getLiquidationPrice()\n returns the price of Ether in USD that causes the CDP to become unsafe (able to be liquidated), all other factors constant. It returns a \nUSD_ETH\n \nprice unit\n.\n \nconst\n ratio \n=\n \nawait\n cdp\n.\ngetLiquidationPrice\n();\ngetCollateralValue\nParams:\n \ncurrency unit\n (optional)\nReturns:\n promise (resolves to collateral amount)\ncdp.getCollateralValue()\n returns the value of the collateral in the CDP. By default it returns the amount of ETH as a \ncurrency unit\n, but can return the equivalent in PETH or USD depending on the first argument.\nconst\n ethCollateral \n=\n \nawait\n cdp\n.\ngetCollateralValue\n();\nconst\n pethCollateral \n=\n \nawait\n cdp\n.\ngetCollateralValue\n(\nMaker\n.\nPETH\n);\nconst\n usdCollateral \n=\n \nawait\n cdp\n.\ngetCollateralValue\n(\nMaker\n.\nUSD\n);\nisSafe\nParams:\n none\nReturns:\n promise (resolves to boolean)\ncdp.isSafe()\n returns true if the cdp is safe, that is, if the USD value of its collateral is greater than or equal to USD value of the its debt multiplied by the liquidation ratio.\nconst\n ratio \n=\n \nawait\n cdp\n.\nisSafe\n();\nenoughMkrToWipe\nParams:\n amount of Sai to wipe\nReturns:\n promise (resolves to boolean)\ncdp.enoughMkrToWipe(dai)\n returns true if the current account owns enough MKR to wipe the specified amount of Sai from the CDP.\nconst\n enoughMkrToWipe \n=\n \nawait\n cdp\n.\nenoughMkrToWipe\n(\n10000000000000000000\n,\n \nSAI\n.\nwei\n);\nlockEth\nParams:\n amount to lock in the CDP, in units defined by the price service.\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.lockEth(eth)\n abstracts the token conversions needed to lock collateral in a CDP. It first converts the ETH to WETH, then converts the WETH to PETH, then locks the PETH in the CDP.\nNote:\n this process is not atomic, so it's possible for some of the transactions to succeed but not all three. See \nUsing DsProxy\n for executing multiple transactions atomically.\nreturn\n \nawait\n cdp\n.\nlockEth\n(\n10000000000000000000\n,\n \nETH\n.\nwei\n);\n// or equivalently\nreturn\n \nawait\n cdp\n.\nlockEth\n(\n100\n,\n \nETH\n);\ndrawSai\nParams:\n amount to draw (in Sai, as string)\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.drawSai(sai)\n withdraws the specified amount of Sai as a loan against the collateral in the CDP. As such, it will fail if the CDP doesn't have enough PETH locked in it to remain at least 150% collateralized.\nreturn\n \nawait\n cdp\n.\ndrawSai\n(\n10000000000000000000\n,\n \nSAI\n.\nwei\n);\n// or equivalently\nreturn\n \nawait\n cdp\n.\ndrawSai\n(\n100\n,\n \nSAI\n);\nwipeSai\nParams:\n amount to repay (in Sai, as string)\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.wipeSai(sai)\n sends Sai back to the CDP in order to repay some (or all) of its outstanding debt.\nNote:\n CDPs accumulate MKR governance debt over their lifetime. This must be paid when wiping sai debt, and thus MKR must be acquired before calling this method.\nreturn\n \nawait\n cdp\n.\nwipeSai\n(\n10000000000000000000\n,\n \nSAI\n.\nwei\n);\n// or equivalently\nreturn\n \nawait\n cdp\n.\nwipeSai\n(\n100\n,\n \nSAI\n);\nfreePeth\nParams:\n amount of Peth collateral to free from the CDP, in units defined by the price service.\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.freePeth(peth)\n withdraws the specified amount of PETH and returns it to the owner's address. As such, the contract will only allow you to free PETH that's locked in excess of 150% of the CDP's outstanding debt.\nreturn\n \nawait\n cdp\n.\nfreePeth\n(\n100\n,\n \nPETH\n);\n// or equivalently\nreturn\n \nawait\n cdp\n.\nfreePeth\n(\n10000000000000000000\n,\n \nPETH\n.\nwei\n);\ngive\nParams:\n Ethereum address (string)\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.give(address)\n transfers ownership of the CDP from the current owner to the address you provide as an argument.\nreturn\n \nawait\n cdp\n.\ngive\n(\n'0x046ce6b8ecb159645d3a605051ee37ba93b6efcc'\n);\nshut\nParams:\n none\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.shut()\n wipes all remaining sai, frees all remaining collateral, and deletes the CDP. This will fail if the caller does not have enough DAI to wipe all the sai debt and enough MKR to pay for all the accrued stability fee\nreturn\n \nawait\n cdp\n.\nshut\n();\nbite\nParams:\n none\nReturns:\n promise (resolves to \ntransactionObject\n once mined)\ncdp.bite()\n will initiate the liquidation process of an undercollateralized CDP\nreturn\n \nawait\n cdp\n.\nbite\n();\nPrevious\nSingle-Collateral Sai\nNext\nCDP Service\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/collateralized-debt-position", "title": "Collateralized Debt Position"}}
{"page_content": "CDP Service\nSummary\nThis page applies only to Single-Collateral Dai.\nRetrieve the ETH CDP Service through Maker.service('cdp'). The ETH CDP Service exposes risk parameter information for the Ether CDP type (in single-collateral Dai, this is the only CDP Type).\nconst\n service \n=\n maker\n.\nservice\n(\n'cdp'\n);\ngetLiquidationRatio\nParams:\n none\nReturns:\n promise (resolves to liquidation ratio)\ngetLiquidationRatio()\n returns a decimal representation of the liquidation ratio, e.g. 1.5\nconst\n ratio \n=\n \nawait\n service\n.\ngetLiquidationRatio\n();\ngetLiquidationPenalty\nParams:\n none\nReturns:\n promise (resolves to liquidation penalty)\ngetLiquidationPenalty()\n returns a decimal representation of the liquidation penalty, e.g. 0.13\nconst\n penalty \n=\n \nawait\n service\n.\ngetLiquidationPenalty\n();\ngetAnnualGovernanceFee\nParams:\n none\nReturns:\n promise (resolves to yearly governance fee)\ngetAnnualGovernanceFee()\n returns a decimal representation of the annual governance fee, e.g. 0.005.\nconst\n fee \n=\n \nawait\n service\n.\ngetAnnualGovernanceFee\n();\nNote:\n This is often referred to as the \nStability Fee\n, even though technically the \nStability Fee\n is the fee that is paid in Sai, and the \nGovernance Fee\n is the fee that is paid in MKR. But since fees are only paid in MKR in Single-Collateral Dai, and only paid in Dai in Multi-Collateral Dai, the fee in Single-Collateral Sai is often referred to as the \nStability Fee\n to be consistent with the term that will be used in Multi-Collateral Dai and to avoid unduly confusing regular users.\nPrevious\nCollateralized Debt Position\nNext\nPrice Service\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/eth-cdp-service", "title": "CDP Service"}}
{"page_content": "Exchange Service\nSummary\nRetrieve the OasisExchangeService (or alternative implementation) through \nmaker.service('exchange')\n. The exchange service allows to buy and sell DAI, MKR, and other tokens. The default OasisExchangeService implementation uses the OasisDEX OTC market for this.\nRequires one of the exchange \nplugins\n to be in use.\nconst\n exchange \n=\n maker\n.\nservice\n(\n'exchange'\n);\nsellDai\nSell a set amount of DAI and receive another token in return.\nParameters\ndaiAmount\n - Amount of DAI to sell.\ntokenSymbol\n - Token to receive in return.\nminFillAmount\n - Minimum amount to receive in return.\nReturns:\n promise (resolves to \nOasisOrder\n once mined)\n// Sell 100.00 DAI for 0.30 WETH or more.\nconst\n sellOrder \n=\n \nawait\n exchange\n.\nsellDai\n(\n'100.0'\n,\n \n'WETH'\n,\n \n'0.30'\n);\nbuyDai\nBuy a set amount of DAI and give another token in return.\nParameters\ndaiAmount\n - Amount of DAI to buy.\ntokenSymbol\n - Token to give in return.\nminFillAmount\n - Maximum amount to give in return.\nReturns:\n promise (resolves to \nOasisOrder\n once mined)\n// Buy 100.00 DAI for 0.30 WETH or less.\nconst\n buyOrder \n=\n \nawait\n exchange\n.\nbuyDai\n(\n'100.0'\n,\n \n'WETH'\n,\n \n'0.35'\n);\nOasisOrder\nOasisOrders\n have a few methods: \nfillAmount\n: amount of token received in exchange \nfees()\n: amount of ether spent on gas \ncreated()\n: timestamp of when transaction was mined\nconst\n buyOrder \n=\n \nawait\n exchange\n.\nbuyDai\n(\n'100.0'\n,\n \n'WETH'\n,\n \n'0.35'\n);\nconst\n fillAmount \n=\n buyOrder\n.\nfillAmount\n();\nconst\n gasPaid \n=\n buyOrder\n.\nfees\n();\nconst\n created \n=\n buyOrder\n.\ncreated\n();\nPrevious\nToken Conversion\nNext\n - Building on top of the Maker Protocol\nPymaker\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/exchange-service", "title": "Exchange Service"}}
{"page_content": "Price Service\nSummary\nRetrieve the PriceService through \nMaker.service('price')\n. The PriceService exposes the collateral and governance tokens' price information that is reported by the oracles in the Maker system.\nconst\n price \n=\n maker\n.\nservice\n(\n'price'\n);\ngetEthPrice\nGet the current USD price of ETH, as a \nUSD_ETH\n \nprice unit\n.\nconst\n ethPrice \n=\n \nawait\n price\n.\ngetEthPrice\n();\ngetMkrPrice\nGet the current USD price of the governance token MKR, as a \nUSD_MKR\n \nprice unit\n.\nconst\n mkrPrice \n=\n \nawait\n price\n.\ngetMkrPrice\n();\ngetPethPrice\nGet the current USD price of PETH (pooled ethereum), as a \nUSD_PETH\n \nprice unit\n.\nawait\n pethPrice \n=\n price\n.\ngetPethPrice\n();\nsetEthPrice\nSet the current USD price of ETH. This requires the necessary permissions and will only be useful in a testing environment.\nawait\n price\n.\nsetEthPrice\n(\n475\n);\nsetMkrPrice\nSet the current USD price of the governance token MKR. This requires the necessary permissions and will only be useful in a testing environment.\nawait\n price\n.\nsetMkrPrice\n(\n950.00\n);\ngetWethToPethRatio\nReturns the current WETH to PETH ratio.\nawait\n price\n.\ngetWethToPethRatio\n();\nPrevious\nCDP Service\nNext\nSystem Status\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/price-service", "title": "Price Service"}}
{"page_content": "System Status\nSummary\nTo access system status information, retrieve the ETH CDP Service through Maker.service('cdp').\nconst\n service \n=\n maker\n.\nservice\n(\n'cdp'\n);\ngetSystemCollateralization\nParams:\n none\nReturns:\n promise (resolves to system collateralization ratio)\ngetSystemCollateralization()\n returns the collateralization ratio for the entire system, e.g. 2.75\nconst\n systemRatio \n=\n \nawait\n service\n.\ngetSystemCollateralization\n();\ngetTargetPrice\nParams:\n none\nReturns:\n promise (resolves to target price)\ngetTargetPrice()\n returns the target price of Sai in USD, that is, the value to which Sai is soft-pegged, which historically has been 1. It returns a \nUSD_SAI\n \nprice unit\n.\nconst\n targetPrice \n=\n \nawait\n service\n.\ngetTargetPrice\n();\nPrevious\nPrice Service\nNext\nTokens\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/system-status", "title": "System Status"}}
{"page_content": "Token Conversion\nGet the token conversion service with maker.service('conversion').\nconst\n conversionService \n=\n maker\n.\nservice\n(\n'conversion'\n);\nThe token conversion service offers functions to convert between Eth, Weth and Peth, handling allowances when necessary.\nconvertEthToWeth\nreturn\n \nawait\n conversionService\n.\nconvertEthToWeth\n(\nETH\n(\n10\n));\nParams: amount of Eth to convert\nReturns: promise (resolves to transactionObject once mined)\nNote:\n this is the same as weth.deposit\nconvertEthToWeth\n deposits ETH into the WETH contract\nconvertWethToPeth\nreturn\n \nawait\n conversionService\n.\nconvertWethToPeth\n(\nWETH\n(\n10\n));\nParams: amount of Weth to convert\nReturns: promise (resolves to transactionObject once mined)\nconvertWethToPeth\n joins WETH into PETH, first giving token allowance if necessary.\nNote:\n this process is not atomic if a token allowance needs to be set, so it's possible for one of the transactions to succeed but not both. See \nDsProxy\n for executing multiple transactions atomically. Also, \npeth.join\n can be called instead if you do not want the allowance to be set first automatically.\nconvertEthToPeth\nreturn\n \nawait\n conversionService\n.\nconvertEthToPeth\n(\nETH\n(\n10\n));\nParams: amount of Eth to convert\nReturns: promise (resolves to transactionObject once mined)\nconvertEthToPeth\n awaits convertEthToWeth, then calls convertWethToPeth\nNote:\n this process is not atomic, so it's possible for some of the transactions to succeed but not all. See Using DsProxy for executing multiple transactions atomically.\nconvertWethToEth\nreturn\n \nawait\n conversionService\n.\nconvertconvertWethToEth\n(\nWETH\n(\n10\n));\nParams: amount of Weth to convert\nReturns: promise (resolves to transactionObject once mined)\nconvertWethToEth\n withdraws Eth from Weth contract\nNote:\n this is the same as weth.withdraw\nconvertPethToWeth\nreturn\n \nawait\n conversionService\n.\nconvertPethToWeth\n(\nPETH\n(\n10\n));\nParams: amount of Peth to convert\nReturns: promise (resolves to transactionObject once mined)\nconvertPethToWeth\n exits PETH into WETH, first giving token allowance if necessary\nNote:\n this process is not atomic if a token allowance needs to be set, so it's possible for one of the transactions to succeed but not both. See Using DsProxy for executing multiple transactions atomically. Also, peth.exit can be called instead if you do not want the allowance to be set first automatically.\nconvertPethToEth\nreturn\n \nawait\n conversionService\n.\nconvertPethToEth\n(\nPETH\n(\n10\n));\nParams: amount of Peth to convert\nReturns: promise (resolves to transactionObject once mined)\nconvertPethToEth\n awaits convertPethToWeth, then calls convertWethToEth\nNote:\n this process is not atomic, so it's possible for some of the transactions to succeed but not all. See Using DsProxy for executing multiple transactions atomically.\nPrevious\nTokens\nNext\nExchange Service\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/token-conversion", "title": "Token Conversion"}}
{"page_content": "Tokens\nGet a token object through the \ngetToken(tokenSymbol)\n function on the tokenService.\nThe list of tokens that can be passed into \ngetToken()\n are: SAI, MKR, WETH, PETH, ETH.\nThis list can also be obtained with \ntokenService.getTokens()\n. This function returns a string representation of the token symbol, e.g. 'SAI', which can also be passed into \ngetToken\n.\nWhen the Multi-Collateral Dai plugin is in use, \ngetToken('DAI')\n will return a token object for Dai.\nconst\n tokenService \n=\n maker\n.\nservice\n(\n'token'\n);\nconst\n sai \n=\n tokenService\n.\ngetToken\n(\n'SAI'\n);\nconst\n weth \n=\n tokenService\n.\ngetToken\n(\n'WETH'\n);\nconst\n peth \n=\n tokenService\n.\ngetToken\n(\n'PETH'\n);\nMost of the methods below can be called on any token object. \ndeposit\n and \nwithdraw\n are for WETH only, and \njoin\n and \nexit\n are for PETH only.\nallowance\nconst\n allowance \n=\n \nawait\n dai\n.\nallowance\n(\n'0x...owner'\n,\n \n'0x...spender'\n);\nParams:\ntokenOwner\n - address of token owner\nspender\n - address of token spender\nReturns: promise (resolves to token allowance)\nallowance\n returns a \ncurrency unit\n representing the token allowance.\nbalance\nconst\n balance \n=\n \nawait\n dai\n.\nbalance\n();\nParams: none\nReturns: promise (resolves balance of current account)\nbalance\n returns a \ncurrency unit\n representing the token balance of the current account\nbalanceOf\nconst\n balanceOf \n=\n \nawait\n dai\n.\nbalanceOf\n(\n'0x...f00'\n);\nParams: address to check\nReturns: promise (resolves balance of address)\nbalanceOf\n returns a \ncurrency unit\n representing the token balance of the supplied account.\ntotalSupply\nconst\n totalSupply \n=\n \nawait\n dai\n.\ntotalSupply\n();\nParams: none\nReturns: promise (resolves total supply of token)\ntotalSupply\n returns a \ncurrency unit\n representing the total token supply\napprove\nreturn\n \nawait\n dai\n.\napprove\n(\n'0x...f00'\n,\n \nDAI\n(\n10\n));\nParams:\nspender - address of token spender\namount - amount of token to allow\nReturns: promise (resolves to \ntransactionObject\n once mined)\napprove\n approves the spending address to spend up to \namount\n of \nmsg.sender\n's tokens.\napproveUnlimited\nreturn\n \nawait\n dai\n.\napproveUnlimited\n(\n'0x...f00'\n);\nParams: address of token spender\nReturns: promise (resolves to \ntransactionObject\n once mined)\napproveUnlimited\n approves the spending address to spend the maximum amount of \nmsg.sender\n's tokens.\ntransfer\nreturn\n \nawait\n dai\n.\ntransfer\n(\n'0x...f00'\n,\n \nDAI\n(\n10\n));\nParams:\nto - address to send to\namount - amount of token to send\nReturns: promise (resolves to \ntransactionObject\n once mined)\ntransfer\n transfers \namount\n of token to \nto\n address.\ntransferFrom\nreturn\n \nawait\n dai\n.\ntransferFrom\n(\n'0x...fr0m'\n,\n \n'0x...t0'\n,\n \nDAI\n(\n10\n));\nParams:\nfrom - address to send tokens from\nto - address to send to\namount - amount of token to send\nReturns: promise (resolves to \ntransactionObject\n once mined)\ntransferFrom()\n transfers \namount\n of token from \nfrom\n address to \nto\n address. Transaction will fail if \nmsg.sender\n does not have allowance to transfer the amount of tokens \nfrom\n the from address.\ndeposit (WETH only)\nreturn\n \nawait\n weth\n.\ndeposit\n(\nETH\n(\n10\n));\nParams: amount of Eth to deposit\nReturns: promise (resolves to \ntransactionObject\n once mined)\ndeposit\n converts \namount\n of Eth to \namount\n of Weth.\nwithdraw (WETH only)\nreturn\n \nawait\n weth\n.\nwithdraw\n(\nWETH\n(\n10\n));\nParams: amount of Weth to withdraw\nReturns: promise (resolves to \ntransactionObject\n once mined)\nwithdraw\n converts \namount\n of Weth to \namount\n of Eth.\njoin (PETH only)\nreturn\n \nawait\n peth\n.\njoin\n(\nWETH\n(\n10\n));\nParams: amount of Weth to join\nReturns: promise (resolves to \ntransactionObject\n once mined)\njoin\n converts \namount\n of Weth to Peth, at the \nWeth to Peth Ratio\n.\nexit (PETH only)\nreturn\n \nawait\n peth\n.\nexit\n(\nPETH\n(\n10\n));\nParams: amount of Peth to exit\nReturns: promise (resolves to \ntransactionObject\n once mined)\nwithdraw\n converts \namount\n of Peth to Weth, at the \nWeth to Peth Ratio\n.\nPrevious\nSystem Status\nNext\nToken Conversion\nLast modified \n3yr ago", "metadata": {"source": "https://docs.makerdao.com/build/dai.js/single-collateral-dai/tokens", "title": "Tokens"}}
